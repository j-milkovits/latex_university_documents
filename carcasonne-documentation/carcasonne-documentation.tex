\input{../reference_sheet_preamble}


\begin{titlepage}
  \title{Dokumentation Projektarbeit Carcasonne} % document_name-type_of_document
  \author{Leopold Keller, Laurenz Kammeyer, Frederick Wichert, Jonas Milkovits}
  \date{}
\end{titlepage}

\lstset {
	literate={~} {$\sim$}{1},
    language=Java,
    basicstyle=\footnotesize,
    numbers=left,
    stepnumber=1,
    showstringspaces=false,
    tabsize=1,
    breaklines=true,
    breakatwhitespace=false,
    inputencoding=utf8,
    extendedchars=true   
}


\begin{document}

\pagenumbering{gobble}
\maketitle
\pagenumbering{roman} % i, ii, iii on beginning pages, that don't have content
\tableofcontents
\clearpage
\pagenumbering{arabic} % 1,2,3 on content pages


\section{Dokumentation - 6.1.4(b)}
Die 6.1.4(b) befasst sich mit der Berechnung der Spielpunkte während und am Ende des Spieles.

\begin{itemize}

\item \textbf{Grundgerüst}
	\begin{itemize}
	\item[]
	Als Grundlage für die Punkteberechnung haben wir eine allgemeine Funktion geschrieben, die alle nötigen Randwerte für die Punkteberechnung generiert und diese anschließend je nach übergebenem Parameter entsprechend der Regeln für Burgen, 	Straßen oder Feldern weiterverarbeitet. Die Punkte werden dem berechtigten Spieler anschließend angerechnet.
	
	
	Zuerst wird eine Liste \texttt {nodeList} mit allen Kanten des Graphen erstellt. Anschließend wird das erste Element von \texttt {nodeList} der Funktion \texttt {goToAllConnectedNodes()} übergeben, die eine Liste mit allen mit diesem 		
	Knoten verbundenen Knoten des selben Typen erstellt. Sie erzeugt also einen Subgraphen, speziell den Subgraphen der den an \texttt {goToAllConnectedNodes()} übergeben Knoten enthält. Anschließend werden alle diese Elemente aus \texttt 	
	{nodeList} entfernt. Jeder Subgraph wird dann einzeln behandelt. Dieser Prozess wiederholt sich solange, bis 
	\texttt {nodeList} leer ist, der Spielfeldgraph also in alle Teilgraphen eines Types zerlegt wurde.

	Der momentan behandelte Subgraph aus  \texttt{Node<FeatureType>} Elementen wird in der ArrayDeque \texttt{queue} gespeichert. Jetzt erden noch zwei weitere Listen befüllt.
	Einmal die ArrayList$<$ FeatureNode$>$ 	\\
	\texttt{connectedFeatureNodes()}, dass alle FeatureNodes des Subgraphen enthält und die ArrayList$<$Tile$>$  
	\texttt{connectedTiles}, die jede Kachel enthält, 
	die mindestens einen Knoten aus \texttt{queue} enthält. Beide werden aufgefüllt 	indem durch alle Kacheln und ihre \texttt{FeatureNodes} iteriert wird und die entsprechenden Elemente herausgefiltert werden.
	
	\item[]
		\begin{lstlisting}
		ArrayList<Tile> connectedTiles = new ArrayList<>();   
		ArrayList<FeatureNode> connectedFeatureNodes = new ArrayList<>(); 
				
		for (int width = 0; width < board.length; width++) {
			for (int height = 0; height < board[1].length; height++) {
				for (Node<FeatureType> node : queue) {
					if (isTileAtPosition(width, height)) {
						if (board[width][height].getNodes().contains(node)) {
							for (Position pos : Position.getAllPosition()) { 
								if (board[width][height].getNodeAtPosition(pos) != null) {
								if (board[width][height].getNodeAtPosition(pos).equals(node)) {
									connectedFeatureNodes.add(board[width][height].getNodeAtPosition(pos));
									}
								}
							}
							if (!connectedTiles.contains(board[width][height])) {
							connectedTiles.add(board[width][height]);
							}
						}
					}
				}
			}
		}
	\end{lstlisting}
	\end{itemize}
	
\clearpage	
	
\item \textbf{Gewinner feststellen}
	\begin{itemize}
	
	\item[]
		Nun wird ein IntArray \texttt{spieler[]} erstellt, in dem jede Position für eine \texttt{MeepleColor} steht.
		Jetzt werden die Meeple aller Knoten des Subgraphen gezählt und entsprechend ihrer Farbe im Array gezählt. Wir haben uns für diesen Weg entschieden, um die Anzahl der Meeple kompakt speichern zu können. Danach werden alle Meeple 		
		ihren Spielern wieder gutgeschrieben.
	
	\item[]
		\begin{lstlisting}
		for (FeatureNode meepleNode : connectedFeatureNodes) {
			if (meepleNode.hasMeeple()) {
				FeatureNodesWithMeeples.add(meepleNode);
					for (int i = 0; i < 6; i++) {
						if (MeepleColor.YELLOW == meepleNode.getPlayer().getColor()) {
							spieler[0]++;
						}
						if (MeepleColor.BLACK == meepleNode.getPlayer().getColor()) {
							spieler[1]++;
						}
						if (MeepleColor.BLUE == meepleNode.getPlayer().getColor()) {
							spieler[2]++;
						}
						if (MeepleColor.GREEN == meepleNode.getPlayer().getColor()) {
							spieler[3]++;
						}				
						if (MeepleColor.GREY == meepleNode.getPlayer().getColor()) {
							spieler[4]++;
						}				
						if (MeepleColor.RED == meepleNode.getPlayer().getColor()) {
							spieler[5]++;
						}
					}
			}
		}
					
		for (FeatureNode node : FeatureNodesWithMeeples) {
			for (Player play : Players.getPlayers()) {
				if(node.getPlayer() != null){
					if (node.getPlayer().equals(play)) {
						node.setPlayer(null);
						play.returnMeeple();
				  	}
				}
			}
		}
		
		\end{lstlisting}
		
	\item[]
		Nun wird der Spieler ermittelt, der die meisten Meeple auf dem Subgraphen hatte und somit Anspruch auf die Punkte hat.
		
	\item[]
		\begin{lstlisting}
		ArrayList<Integer> highestColor = new ArrayList<>();
		highestColor.add(0);						
		int compare = spieler[0];  //Vergleichswert fuer evtl gleiche Punktzahlen
		for (int i = 0;i<6;i++) {
			if(spieler[i]>compare) {
				highestColor.set(0, i);
				compare=spieler[i];
			}
		}
		for(int i = 0;i<6 && i != highestColor.get(0);i++){
			if(spieler[i] == compare){
				highestColor.add(i);
			}
		}
		\end{lstlisting}	
		
	
	\item[]
		Im Anschluss wird die Position in \texttt{spieler[]} wieder in eine \texttt{MeepleColor} zurückübersetzt.
	
	\end{itemize}	
	
\clearpage	
	
\item \textbf{Punkte addieren}
	\begin{itemize}
	\item[]
		Da jetzt feststeht wer die Punkte erhalten soll, können diese nun berechnet werden.
		Dies geschieht abhängig von dem übergeben FeatureType \texttt{type}. Je nach seinem Wert, aktiviert sich 
		eine der If-Verzweigungen und setzt den zu addierenden \texttt{score}. Dessen Berechnung ist dank der 
		bereits 
		erstellten 
		Eckdaten, 	wie Menge an Kacheln des Subgraphen und Zahl der Kanten vergleichsweise simpel. Eine 
		Hilfsmethode \texttt{structureCompleted()} stellt fest, ob ein Subgraph abgeschlossen ist, indem sie 
		überprüft, 
		ob alle relevanten 
		Knoten mit einer weiteren Kachel verbunden sind. Der vorhin erstellte \texttt{score} kann jetzt 
		aufaddiert werden.
	
	\end{itemize}		
	
\clearpage
	
\end{itemize}
\section{Dokumentation - 6.1.5}

\begin{enumerate}

\item \textbf{Der Graph ist ein azyklischer Graph}
	\begin{itemize}
	\item[]
		\textbf{Die Behauptung ist falsch.} Durch das Aneinanderlegen zweier Klosterkarten
		mit Straße (siehe Abschnitt 3, Abb. 9a) an ihren Straßen, wird ein zyklischer
		Wiesengraph erzeugt
	\end{itemize}
	
\item \textbf{Gegeben seien $k$ gespielte Legekarten $\{l_1,. . . ,l_k\}$. Die Anzahl $n$ der
		Zusammenhangskomponenten im dazugehörigen Graphen ist durch die
		Ungleichung $n \leq k * 9$ beschränkt}
		\begin{itemize}
		
		\item[]
			\textbf{Die Behauptung ist wahr.} Betrachten wir ein theoretisches Szenario, indem wir 
			auch Karten betrachten, die so nicht im Spiel implementiert sind. Diese theoretischen Karten können 
			beliebig viele verbundene oder nicht verbundene Nodes besitzen. Dies bedeutet, dass die maximale
			Anzahl an Zusammenhangskomponenten der Anzahl der maximal möglichen unverbundenen Nodes entspricht.
			Mit der Annahme, dass eine Karte nur maximal 9 Nodes besitzen kann, ist die maximale Anzahl an
			Zusammenhangskomponenten einer Karte gleich 9. Die maximal mögliche Anzahl an 
			Zusammenhangskomponenten, die durch das Anlegen einer neuen Karte hinzukommen, ist somit auch 9. 
			Nämlich genau dann, wenn eine Karte angelegt wird und beim Anlegen keine der Nodes verbunden
			werden. Somit ist bewiesen, dass $n > k*9$ nicht erfüllt sein kann. Gehen wir desweiteren davon
			aus, dass es möglich ist, dass beim Anlegen Nodes verbunden werden. Durch das Verbinden beim 
			Anlegen wird nicht mehr die volle Anzahl der Zusammenhangskomponenten der angelegten Karte zum
			Graphen hinzugefügt. Desweiteren kann die Anzahl der Zusammenhangskomponenten einer Karte kleiner
			gleich 9 sein. Somit ist die Anzahl der Zusammenhangskomponenten bei $k$ gelegten Karten durch
			$n \leq k*9$ festgelegt.   
		\end{itemize}
		
\item \textbf{Sei der Graph $G = (V,E)$ mit der Menge der Knoten $V$ und der Menge der Kanten $E$ gegeben. Die Komplexität einer Suche nach einem Element in einer Liste legen wir der Einfachheit halber mit $O(1)$ fest. Die
			Laufzeit der Methode \texttt{calculatePoints(FeatureType type, State state)} ist durch $O(|E||V |)$ beschränkt}
			\begin{itemize}
			\item[]
				\textbf{Die Behauptung ist falsch.} Obwohl die Zerlegung des Graphen in Subgraphen durch $|E| · |V |$ beschränkt ist, berücksichtigt dies nicht die zusätzliche
				Laufzeit, die zum Addieren der Punkte und Auswerten der Meeple benötigt
				wird. Die Laufzeit fur die gesamte Funktion kann somit höher liegen.
			\end{itemize}

\end{enumerate}

\clearpage

\section{Dokumentation - 6.3.1}

Die graphische Oberfläche wurde um folgende Elemente erweitert:
\begin{itemize}
	\item  \textbf{Tabelle}
		\begin{itemize}
		\item \textbf{Ziel der Spaltengestaltung:}
			\begin{enumerate}
			\item Möglichst übersichtliche Gestaltung der Spalten
			\item kurze, aussagekräftige Namen
			\item Informationen so übersichtlich wie möglich $\rightarrow$ wenige Spalten
			\end{enumerate}
		\item Die Tabelle wurde mit folgendem Code erstellt:
		\begin{lstlisting}
			private JTable scoreTable;
			List<ScoreEntry> list = resources.getScoreEntries();
			Object[] column = { "Date", "Name", "Score" };
			Object[][] data = new Object[list.size()][3];
			scoreTable = new JTable(data, column);	
		\end{lstlisting} 
		
		\item Das zweidimensionale Array \texttt{data} wurde mit folgendem Code befüllt:
		\begin{lstlisting}
		for (int i = 0; i < list.size(); i++) {
			if (list.get(i) != null) {
				data[i][0] = list.get(i).getDate();
				data[i][1] = list.get(i).getName();
				data[i][2] = list.get(i).getScore();
			}
		}
		\end{lstlisting}
		
		\item \textbf{Problem:} Beim Standardmodell editierbare Zellen
			\begin{itemize}
				\item[$\Rightarrow$] \textbf{Lösung:} Eigenes Table-Modell
				\item[]
						Das Überschreiben der Methode \texttt{isCellEditable(int row, int column}) erlaubt es 
						uns das Editieren der Zellen zu verhindern. Das Überschreiben der zweiten Methode
						benötigen wir später für das Sortieren der Spalten.
			\end{itemize}
	
		\begin{lstlisting}
		DefaultTableModel tableModel = new DefaultTableModel(data, column) {

			@Override
			public boolean isCellEditable(int row, int column) {
				// all cells false
				return false;
			}

			public Class<?> getColumnClass(int columnIndex) {
				return getValueAt(0, columnIndex).getClass();
			}			

		};
		
		scoreTable.setModel(tableModel);
		\end{lstlisting}
		
		\item \textbf{Ergebnis:}		

		\item[]
		
		Wir haben eine Tabelle mit drei Spalten (Datum, Name, Punkte) erstellt.
		Das Datumsformat ist absichtlich kürzer gehalten, da unserer Meinung nach der Tag des Spiels ausreichend 		ist.
		\end{itemize}
		
	\clearpage	
	
	\item \textbf{Scrollbar}
		\begin{itemize}
		\item Eine Scrollbar wird benötigt, falls zuviele Daten vorhanden sind
		\item Die Scrollbar wurde mit folgendem Code erstellt:
		\begin{lstlisting}
		private JScrollPane scrollPane;
		scrollPane = new JScrollPane(scoreTable);
		add(scrollPane);
		\end{lstlisting}
		\item Dies verknüpft die Tabelle mit der Scrollbar
		\end{itemize}
	
	\item \textbf{Sortierbarkeit der Spalten}
		\begin{itemize}
		\item[]
			 Die Sortierbarkeit der Spalten	wurde uns hier zwar nicht vorgegeben, war für uns aber ein wichtiges
			 Feature bei einer Highscore-Tabelle. Diese dient auch der einfacheren Verwendbarkeit für den
			 Endnutzer. Alle Spalten sind nach ihren jeweiligen Werten sortierbar.
		\item Dies wurde mit folgendem Code erreicht:
		\begin{lstlisting}
		TableRowSorter<TableModel> sorter = new TableRowSorter<TableModel>(scoreTable.getModel());
		scoreTable.setRowSorter(sorter);
		\end{lstlisting}
		\item[]
			Die Vorarbeit, die hierfür benötigt wurde, ist weiter oben in der Erstellung von 
			\texttt{DefaultTableModel} zu finden. Dies erlaubt es uns, auch das Datum sowie die Punktzahl zu
			sortieren. Ohne diese Vorarbeit könnte man das Ganze nur korrekt nach Namen sortieren, da der
			Autosorter den Wert des Strings vergleicht, was bei dem Datum und der Punktzahl zu falschen
			Sortierungen führt.
		
		
		\end{itemize}
	
	
\end{itemize}

\clearpage

\section{Dokumentation - 6.3.2}

\begin{itemize}
\item[]
	Eine Wiese soll 3 Bonuspunkte einbringe für jede enthaltene oder angrenzende abgeschlossene Burg.
	Dazu iterieren wir durch alle Kacheln des Subgraphen durch, um festzustellen welche von ihnen Burgabschnitte enthalten und ob dieser Burgabschnitt bereits besucht wurde. Dies wird mittel einer 'Blacklist' entschieden, der jeder besuchte 
	Knoten einer Burg und die ihrer Zusammenhangskomponente hinzugefügt werden. So wird die Doppelz\"ahlung von Burgen vermieden. Was der Subgraph einer Burg ist, wird durch die Hilfsmethode \texttt{returnAllConnectedFeatureNodes()} 
	entschieden. Diese Methode ruft wiederum eine eigene Hilfsmethode auf, die sich analog zu \texttt{goToAllConnectedNodes()} verhält und konvertiert das Ergebnis anschließend in FeatureNodes analog zu dem Code in \textbf{1.}. Weiterhin 
	gibt es die Funktion \texttt{allowedTile()}, die Randfälle für besondere Kacheln abdeckt.

	Für jede neu besuchte Burg wird \texttt{score} um 3 erhöht.
\end{itemize}

\clearpage

\section{Dokumentation - 6.3.3}

\begin{itemize}

\item \textbf{Mission 1:}
	\begin{itemize}
	\item[]
		Endet eine Runde in der ein Spieler 3 Burgen mehr, oder mehr, als einer seiner Kontrahenten besetzt, gilt die Bedingung von Mission 1 als erfüllt und das Spiel wird sofort beendet mit diesem Spieler als Gewinner. In diesem Fall soll 	
		ein zweites Fenster ge\"offnet werden, dass Die Namen, Anzahl an besetzten Burgen und Punkte aller Mitspieler enthält.

		Dafür haben wir der Playerklasse einen Parameter \texttt{public int castles} hinzugefügt, der die Anzahl an besetzten Burgen eines Spielers enthält. Er wird jedes mal incrementiert, wenn ein Spieler eine neue Burg besetzt. Außerdem 
		haben wir die GamePlay Klasse um die Flag \texttt{private boolean castleWin} erweitert, die mit \texttt{false} initialisiert wird.
		Außerdem haben wir die Methode \texttt{winByCastle()} in der Gameboard Klasse geschrieben. Diese stellt fest, ob Mission 1 abgeschlossen wurde.
		
		Diese wird nun in der GamePlay Klasse in der Methode \texttt{nextRound()} in einem If-Zweig aufgerufen. Falls sie \texttt{true} zurückgibt, wird die \texttt{castleWin}-Flag gesetzt und der Spielzustand wir in\texttt{State.Game\_Over} 
		geändert.

		Unter diesen Bedingungen wird in der \texttt{game\_Over\_Mode()}-Methode eine alternative Schlussnachicht aufgerufen, die in der Klasse \texttt{MessagesConstants} unter \texttt {showCastleWinner()}beschrieben ist und ein Fenster mit 
		allen in 6.3.3.1 geforderten Informationen \"offnet.
	\end{itemize}


\item \textbf{Mission 2:}
	\begin{itemize}
	\item[]
		Die zweite Mission lautet "besitze 3 Kloster und stelle diese fertig". Zu diesem Zweck wurde der 	
		\texttt{Player.java}  ein neues Attribut \texttt{public int finishedMonasteries} hinzugefügt, 
		welches in 	\\
		\texttt{calculateMonasteries} jedes mal wenn ein Kloster fertiggestellt wird,
		für den jeweiligen Spieler inkerementiert wird. 
		Nun wird in \texttt{Gameboard.java} in der Methode \texttt{winByMonasteries}
		, die in der Methode \texttt{nextRound} aufgerufen 
		wird, geprüft, ob ein Spieler aus
		\texttt{getPlayers()} 3 oder mehr fertiggestellte Kloster besitzt.
		(3 oder mehr da es theoretisch möglich ist 2 	
		Kloster in einer Runde fertigzustellen) 
		Sollte dies der Fall sein gibt die Methode true zurück und die vorher definierte Flagge 
		\texttt{private boolean winByMonasteries} wird auf \texttt{true} gesetzt.
		Desweiteren wird der Gamestate \texttt{GAME\_OVER} gesetzt.
		In der Methode \texttt{game\_Over\_Mode()}  wurde eine extra Verzweigung eingerichtet, die prüft ob ein 
		Sieg durch Klosterbesitz vorliegt.
		Sollte dies der Fall sein wird eine in \texttt{showMonasteriesWinner} 
		in \texttt{MessagesConstants.java} definierte 
		Nachricht ausgegeben.
	\end{itemize}

\end{itemize}

\clearpage

\section{Dokumentation - 6.3.4}
Der Computergegner besteht aus zwei Methoden:
\begin{itemize}

\item \textbf{\texttt{draw(GamePlay gp, Tile tile)}}
	\begin{itemize}
	
	\item[]
		Als ersten Schritt suchen wir uns alle möglichen Platziermöglichkeiten. \\
		Dies geschieht indem wir die Liste der platzierten Tiles des Boards durchlaufen und bei jedem Tile 
		alle Positionen (nördlich, südlich, westlich, östlich) überprüfen und diese, falls das zu 
		platzierende Tile anlegbar ist, abspeichern. \\
		Dieses Abspeichern geschieht in einer Liste einer selbst erstellten Klasse namens PointRotation, die 
		Koordinaten und die Rotation der Position abspeichern. Danach lassen wir uns eine zufällige Zahl 
		(zwischen 0 und der Länge Liste - 1) ausgeben und verwenden diese zufällige Position dann um an 
		dieser Stelle dann das zu platzierende Tile zu platzieren.
	
	\item Suche der möglichen Platzierungsmöglichkeiten:
	\begin{lstlisting}
	List<Tile> tiles = gc.getGameBoard().getTiles();
		List<PointRotation> possibleLocations = new ArrayList<PointRotation>();

		for (Tile t : tiles) {
			// check top
			for (int r = 0; r < 4; r++) {
				if (gc.getGameBoard().isTileAllowed(topTile, t.x, t.y - 1) && !	
				gc.getGameBoard().isTileAtPosition(t.x, t.y - 1)) {
					possibleLocations.add(new PointRotation(t.x, t.y - 1, topTile.getRotation()));
				}
				topTile.rotateRight();
			}

			// check right
			for (int r = 0; r < 4; r++) {
				if (gc.getGameBoard().isTileAllowed(topTile, t.x + 1, t.y) && !
				
				gc.getGameBoard().isTileAtPosition(t.x + 1, t.y)) {
					possibleLocations.add(new PointRotation(t.x + 1, t.y, topTile.getRotation()));
				}
				topTile.rotateRight();
			}

			// check left
			for (int r = 0; r < 4; r++) {
				if (gc.getGameBoard().isTileAllowed(topTile, t.x - 1, t.y) && !
				gc.getGameBoard().isTileAtPosition(t.x - 1, t.y)) {
					possibleLocations.add(new PointRotation(t.x - 1, t.y, topTile.getRotation()));
				}
				topTile.rotateRight();
			}

			// check bottom
			for (int r = 0; r < 4; r++) {
				if (gc.getGameBoard().isTileAllowed(topTile, t.x, t.y + 1) && !
				gc.getGameBoard().isTileAtPosition(t.x, t.y + 1)) {
					possibleLocations.add(new PointRotation(t.x, t.y + 1, topTile.getRotation()));
				}
				topTile.rotateRight();
			}
		}
	\end{lstlisting}
	
	\item Suche nach zufälliger Zahl:
	\begin{lstlisting}
		Random randomGen = new Random();
		int randomNum = randomGen.nextInt(possibleLocations.size());
		PointRotation randomLocation = possibleLocations.get(randomNum);
	\end{lstlisting}	
	
	\clearpage	
	
	\item Rotation der zu platzierenden Tile und Platzieren dieser:
	\begin{lstlisting}
		// Rotate tile to be placed
		while (topTile.getRotation() != randomLocation.getRotation()) {
			topTile.rotateRight();
		}
		
		// Add rotated tile to GameBoard
		gc.getGameBoard().newTile(topTile, randomLocation.getX(), randomLocation.getY());
	\end{lstlisting}
	
	\end{itemize}
\item \textbf{\texttt{placeMeeple(GamePlay gp)}}
	\begin{itemize}
	
	\item[]
			Das Platzieren des Meeples läuft folgendermaßen ab. Wir speichern mithilfe der Methode 
			\texttt{getMeepleSpots()} alle möglichen MeepleSpots des zuletzt platzierten Tiles ab und nutzen 
			diese um uns eine ArrayList des Types Position zu erstellen. In dieser werden alle Positionen
			gespeichert, an denen ein Meeple platzierbar ist. Wir lassen uns dann wieder eine zufällige Zahl
			ausgeben (basierend auf der Länge der ArrayListe) und platzieren den Meeple an dieser Stelle,
			falls die Anzahl der Meeple größer als 0 ist. \\
			Falls es keinen verfügbaren MeepleSpot gibt, wird die Methode \texttt{nextRound()} aufgerufen,
			die die momentane Runde beendet.
			
	\item Überprüfung, ob MeepleSpot vorhanden ist:
	\begin{lstlisting}
		if (meepleSpots == null) {
			gp.nextRound();
			return;
		}
	\end{lstlisting}
	
	\item Abspeichern aller möglichen MeepleSpots:
	\begin{lstlisting}
		// boolean array of length 9, true where meeple can be placed on current tile
		boolean[] meepleSpots = gc.getGameBoard().getMeepleSpots();
		
		// array with all positions
		Position[] positions = Position.getAllPosition();
		
		// Puts all positions with a valid meeple spot into an ArrayList
		ArrayList<Position> possibleMeepleSpots = new ArrayList<Position>();
		
		for (int i = 0; i < positions.length; i++) {
			if (meepleSpots[i] == true) {
				possibleMeepleSpots.add(positions[i]);
			}
		}
	\end{lstlisting}
	
	\item Zufälliger MeepleSpot und Platzieren des Meeples:
	\begin{lstlisting}
		// Getting random meeple spot
		Random randomGen = new Random();
		int randomNum = randomGen.nextInt(possibleMeepleSpots.size());
		
		Position randomMeepleSpot = possibleMeepleSpots.get(randomNum);
		
		if(meeples > 0) {
			gp.placeMeeple(randomMeepleSpot);
		}
		else {
			gp.nextRound();
		}
	\end{lstlisting}
	
	\end{itemize}

\end{itemize}



\end{document}