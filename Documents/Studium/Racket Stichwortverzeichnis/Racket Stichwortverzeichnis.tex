\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage[T1]{fontenc}
\usepackage{multirow}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[margin=0.5cm]{geometry}
\usepackage{xcolor}
\usepackage{makecell} 
\usepackage{longtable}
\usepackage{adjustbox}

\title{HtDP-TL Stichwortverzeichnis}

%\renewcommand{\cellalign}{br} % v -> t,c,b | h -> l,c,r for all cells using thead and makecell
%\renewcommand\theadalign{cl}
%\renewcommand\theadfont{\bfseries}
%\renewcommand\theadgape{\Gape[4pt]}
%\renewcommand\cellgape{\Gape[4pt]}

\begin{document}

\maketitle

\begin{center}

\setlength{\tabcolsep}{0,25cm}
\renewcommand{\arraystretch}{1.7}


\begin{longtable}[h]{ | p{3cm} | p{3cm} | p{11cm} | p{1.2cm} | } 	\hline

	{\large Akkumulatoren} & Zweck & $\bullet$ Zwischenspeicher bei rekursiven Funktionen & 4B/128 \\ \cline{2-4}
	& Verwendung & \makecell[l]{$\bullet$ Rekursiver Aufruf einer Hilfsfunktion mit \\ \hspace{0.2cm} zusammengesetzter Funktion als Parameter \\ 
	$\bullet$ z.B.: ...(counter (+ accu 1))... } & 4B/128\\
	\hline
	
	\multicolumn{3}{c}{} \\ 
	\hline 
		
	{\large \makecell[l]{Arithmetrische \\ Operationen}} & Operationen & $\bullet$ ( + . . ) ( - . . ) ( * . . ) ( / . . ) ( modulo . . ) & 4A/66 \\ \cline{2-4}
	& Operanden & $\bullet$ atomar oder zusammengesetzt möglich & 4A/70 \\ \cline{2-4}
	& \makecell[l]{mehr als 2 \\ Operanden} & \makecell[l]{$\bullet$ z.B.: ( + 1 2 3 4 ) \\ 
	$\bullet$ Jedoch bei - und / $\rightarrow$ erste Zahl Minuend bzw. Dividend } & 4A/73 \\ \cline{2-4}
	& \makecell[l]{nicht exaktes \\ Ergebnis} & $\bullet$ Darstellung der Zahl mit \#i... & 4A/75 \\ \cline{2-4}
	& Operationen & \makecell[l]{$\bullet$ auf ganzen Zahlen: \\ \hspace{0.4cm} $\bullet$ ( floor . ) ( ceiling . ) ( gcd . . ) ( modulo . . ) } & 4A/79 \\ 
	\hline
	
	\multicolumn{3}{c}{} \\ 
	\hline

	{\large \makecell[l]{Boolsche \\ Operationen}} & Literale & $\bullet$ \#t $\rightarrow$ true | \#f $\rightarrow$ false & 4A/86 \\ \cline{2-4}
	& Verknüpfung & $\bullet$ ( and . . . ) ( or . . . ) ( not . ) & 4A/87 \\ \cline{2-4}
	& Vergleiche & \makecell[l]{$\bullet$ ( = . . . ) ( < . . . ) ( <= . . . ) \\ \hspace{0.4cm} $\rightarrow$ Vergleich von zwei aufeinanderfolgenden Parametern} & 4A/89 \\ \cline{2-4}
	& Verzweigung(if) & $\bullet$ ( if ( Bedingung ) (falls true) (falls false) ) & 4A/92 \\ \cline{2-4}
	& Funktionen & \makecell[l]{$\bullet$ integer? $\rightarrow$ \#t falls Parameter ganze Zahl \\ $\bullet$ number? $\rightarrow$ \#t falls Parameter Zahl \\ 
	$\bullet$ real? $\rightarrow$ \#t falls Imaginärteil exakt 0 \\ $\bullet$ rational $\rightarrow$ \#t falls Parameter rational ist \\ 
	$\bullet$ natural $\rightarrow$ \#t falls Parameter natürliche Zahl \\
	$\bullet$ string? $\rightarrow$ \#t falls Parameter String \\ $\bullet$ my-struct? $\rightarrow$ \#t falls Element von Klasse my-struct} & 4A/93 \\ 
	\hline
	
	\multicolumn{3}{c}{} \\ 
	\hline 

	{\large Funktion} & Syntax & \makecell[l]{$\bullet$ ( define ( my-function Parameter ) ( Anweisung ) ) \\ 
	\hspace{0.4cm} $\rightarrow$ Präfixnotation (zuerst der Operand, dann Operanden) } & 4A/43 \\ \cline{2-4}
	& Aufruf & $\bullet$ ( my-function Parameter ) & 4A/49 \\ \cline{2-4}
	& \makecell[l]{Verstecken von \\ Definitionen} & \makecell[l]{$\bullet$ ( local ... )  \\ \hspace{0.4cm} $\bullet$ nur letzter Ausdruck Wert des local Ausdrucks \\ 
	\hspace{0,4cm} $\bullet$ Erstellung von lokalen Definitionen} & 4A/135 \\ \cline{2-4}
	& cond & \makecell[l]{$\bullet$ Syntax: ( cond [ (Bedingung 1) Folge 1 ] \\ \hspace{2.8cm} [ (Bedingung 2) Folge 2 ] [ else ... ] )  } & 4B/61 \\ \cline{2-4}
	& \makecell[l]{Funktionen \\ als Daten} & \makecell[l]{ $\bullet$ z.B.: ( define add + ) \\ 
	\hspace{0.4cm} $\rightarrow$ add ist Konstante vom Typ aller Funktionen, die zwei \\ \hspace{0.9cm} Zahlen als Parameter haben und eine Zahl zurückliefern \\ 
	\hspace{0.4cm} $\rightarrow$ ;; Type: number number $\rightarrow$ number \\ \hspace{0.4cm} $\bullet$ ( add 2 3 ) $\rightarrow$ 5 } & 4C/9 \\ \cline{2-4}
	& Höherer Ordnung & \makecell[l]{$\bullet$ Funktionen, die Funktionen als Parameter oder Rückgabe haben \\ 
	$\bullet$ Vertrag: z.B.: (number $\rightarrow$ number) number $\rightarrow$ number } & 4C/18  \\ \cline{2-4}
	& Aufweichung & \makecell[l]{ $\bullet$ Zeitliche Abläufe in Racket: \\ $\bullet$ \#<void> als Wert $\rightarrow$ Konstante mit leerem Wert \\
	$\bullet$ (begin ...) $\rightarrow$ Block, der mehrere Anweisungen enthalten kann \\ \hspace{0.4cm} $\rightarrow$ Letzter Ausdruck = Rückgabewert \\ 
	$\bullet$ (set! my-constant value) $\rightarrow$ Überschreibt Konstante } & 4D/56 \\
	\hline
	
	\multicolumn{3}{c}{} \\ 
	\hline 

	{\large \makecell[l]{Funktionales \\ Programmieren }} & Funktionen & \makecell[l]{$\bullet$ zentrale Bausteine des funktionalen Programmierens\\ 
	$\bullet$ Zerlegung der zu erstellenden Funktionalität in Funktionen} & 4A/23 \\ \cline{2-4}
	& \makecell[l]{Deklaratives \\ Programmieren} & \makecell[l]{$\bullet$ Nur Verwendung der Formel des Ergebnis \\ \hspace{0.4cm} $\rightarrow$ keine zeitlichen Abläufe \\ 
	\hspace{0.4cm} $\rightarrow$ keine Vorstellung vom Computerspeicher} & 4A/31 \\ \cline{2-4}
	& \makecell[l]{referentielle \\ Transparenz} & \makecell[l]{$\bullet$ Einziger Effekt von Funktionen ist der Rückgabetyp \\ 
	\hspace{0.4cm} $\rightarrow$ void Methoden sinnlos}  & 4A/32 \\ 
	\hline
	
	\multicolumn{3}{c}{} \\ 
	\hline 
		
	{\large Klammern} & atomar & $\bullet$ Einzelne Bestandteile müssen nicht geklammert werden (atomar) & 4A/69 \\ \cline{2-4}
	& \makecell[l]{Zusammengesetzter \\ Ausdruck} & $\bullet$ Klammern sind notwendig & 4A/69 \\ \cline{2-4}
	& Notwendig & \makecell[l]{$\bullet$ Keine Punkt vor Strich Rechnung \\ \hspace{0.4cm} $\rightarrow$ Klammern notwendig} & 4A/70 \\ 
	\hline
	
	\multicolumn{3}{c}{} \\ 
	\hline 		
		
	{\large Kommentare} & Einzeilig & $\bullet$ ; ... & 4A/56 \\ \cline{2-4}
	& Funktion & \makecell[l]{$\bullet$ Festlegung der Eingabeparameter und Ausgabeparameter \\ \hspace{0.4cm} $\rightarrow$ Bsp.: ;; Type: number number $\rightarrow$ number \\ 
	\hspace{1.9cm} ;; Returns: ... \\ \hspace{0.4cm} $\rightarrow$ Vertrag der Funktion \\ $\bullet$ ;; Precondition: ... $\rightarrow$ siehe Laufzeitchecks \\ 
	$\bullet$ höhere Ordnung: z.B. (number $\rightarrow$ number) number $\rightarrow$ number} & 4A/106 \\ \cline{2-4}
	& iff & $\bullet$ gängige Abkürzung für 'if, and only if,..' & 4B/75 \\
	\hline
	
	\multicolumn{3}{c}{} \\ 
	\hline 
	
	{\large Konstanten} & Häufigkeit & $\bullet$ nur Konstanten in Racket & 4A/33 \\ \cline{2-4}
	& Syntax & \makecell[l]{$\bullet$ ( define myConstant Wert ) \\ $\bullet$ zusammengesetzter Ausdruck $\rightarrow$ Wert in Klammern } & 4A/53  \\ 
	\hline
	
	\multicolumn{3}{c}{} \\ 
	\hline 	
	
	{\large Konventionen} & Identifier & \makecell[l]{$\bullet$ Keine Großbuchstaben \\ $\bullet$ Bindestriche zwischen Wörtern \\ 
	\hspace{0.4cm} $\rightarrow$ my-identifier } & 4A/58 \\ \cline{2-4}
	& Kommentare & $\bullet$ einzeilig: ;; statt ; (bessere Sichtbarkeit) &  \\  
	\hline
	
	\multicolumn{3}{c}{} \\ 
	\hline 	
	
	
	
	{\large Laufzeitchecks} & Funktion & \makecell[l]{$\bullet$ Unterbrechen des Programms und Testen der Funktion \\ 
	\hspace{0.4cm} $\bullet$ falls true $\rightarrow$ Programm wird weitergeführt \\
	\hspace{0.4cm} $\bullet$ falls false $\rightarrow$ Abbruch des Programms mit Fehlermeldung } & 4A/112 \\ \cline{2-4}
	& check-expect & \makecell[l]{$\bullet$ ( check-expect ( divide 15 3 ) 5 ) \\ \hspace{0.4cm} $\bullet$ Test ob 15/3 = 5} & 4A/112 \\ \cline{2-4}
	& check-within & \makecell[l]{$\bullet$ ( check-within ( divide pi e ) 1.15 0.01 ) \\ \hspace{0.4cm} $\bullet$ Test ob pi/e weniger als 0.01 von 1.15 abweicht} & 4A/113 \\ \cline{2-4}
	& check-error & \makecell[l]{$\bullet$ ( check-error ( divide 15 0 ) “/: division by zero“ ) \\ \hspace{0.4cm} $\bullet$ Überprüfen ob Fehlermeldungen gleich (Dokumentation) \\ 
	\hspace{0.4cm} $\bullet$ Fehlermeldungen sind Strings } & 4A/114 \\ \cline{2-4}
	& In Funktion & \makecell[l]{$\bullet$ z.B.: Division ( if ( = y 0 ) ( error "Divison by 0")( / x y ) ) } & 4A/117 \\ 
	\hline
	
	\multicolumn{3}{c}{} \\ 
	\hline 	
	
	{\large \makecell[l]{Lambda-\\Ausdrücke}} & Syntax & \makecell[l]{$\bullet$ (lambda (x y) (+(* x x)(* y y))) } & 4C/99 \\ \cline{2-4}
	& Beispiel & \makecell[l]{$\bullet$ ;; Type: (number -> number) (number -> number) \\ \hspace{0.3cm};; \hspace{1.2cm}-> (number number -> number)\\ 
	$\bullet$ (define ( name fct1 fct2 ) \\ \hspace{1.5cm} (lambda (x,y) (+(fct1 x)(fct2 y))) \\ 
	\hspace{0.4cm} $\rightarrow$ zurückgelieferter Wert auch Funktion }  & 4C/105 \\ \cline{2-4}
	& \makecell[l]{Beispiel \\ Verwendung} & \makecell[l]{$\bullet$ ( (name bspfct1 bspfct2) param1 param2)) \\ 
	$\rightarrow$ Return aus Funktion "name" wird danach mit \\ \hspace{0.4cm} param1 und param2 aufgerufen \\ $\rightarrow$ Anwendung von bspfct1 auf param1}  & 4C/108 \\ \cline{2-4}
	& filter & \makecell[l]{$\bullet$ Filterung abhängig von Prädikat \\ $\bullet$ Beispiel: (define (my-filter prädikat liste)...) \\ 
	\hspace{0.4cm} $\bullet$ (my-filter (lambda(x) (< x 10)) liste) \\ $\bullet$ Durch Verwendung von Lambda $\rightarrow$ variable Filter} & 4C/110 \\ \cline{2-4}
	& map & \makecell[l]{$\bullet$ Anwendung einer Funktion auf jedes Element der Liste \\ $\bullet$ Beispiel: (define (my-map fct list)...) \\
	\hspace{0.4cm} $\bullet$ (my-map (lambda(x) (* x 10) list) \\ $\bullet$ Durch Verwendung von Lambda $\rightarrow$ variable Anpassung } & 4C/125 \\ \cline{2-4}
	& fold & \makecell[l]{$\bullet$ Zusammenrechnen einer Liste nach Vorschrift \\ \hspace{0.4cm} $\bullet$ foldr von rechts, foldl von links \\
	$\bullet$ Beispiel: (define (my-fold init fct list)...) \\ \hspace{0.4cm} $\bullet$ (my-fold 0 (lambda(x,y) (+ x y) list) \\ 
	$\bullet$ Durch Verwendung von Lambda $\rightarrow$ variable Verrechnung } & 4C/139 \\
	\hline	
	
	\multicolumn{3}{c}{} \\ 
	\hline 	
	
	{\large Listen} & Syntax & $\bullet$ ( define my-list ( list 1 2 3 ) ) & 4B/3 \\ \cline{2-4}
	& cons & \makecell[l]{$\bullet$ Anhängen an Liste \\ $\bullet$ z.B.: ( define my-list2 ( cons 0 list1 ) ) \\ \hspace{0.4cm} $\rightarrow$ 0 1 2 3} & 4B/6 \\ \cline{2-4}
	& empty & $\bullet$ leere Liste (z.B.: (... ( cons 0 empty ) ) & 4B/8 \\ \cline{2-4}
	& Funktionen & \makecell[l]{$\bullet$ ( first my-list ) $\rightarrow$ erstes Element \\ $\bullet$ ( rest my-list ) $\rightarrow$ Alle Elemente außer Erstes } & 4B/9 \\ \cline{2-4}
	& Vertrag & \makecell[l]{$\bullet$ ;; Type: ( list of ... ) $\rightarrow$ ... \\ $\bullet$ ;; Type: ( list of ANY ) $\rightarrow$ ... , falls Typ beliebig \\ 
	$\bullet$ ;; Type: X $\rightarrow$ X , Eingabetyp beliebig, Ausgabe vom selben Typ \\ 
	$\bullet$ ;; Type: ANY $\rightarrow$ ANY , Eingabetyp beliebig, Ausgabetyp auch} & 4B/16 \\ \cline{2-4}
	& Rekursion & \makecell[l]{$\bullet$ Beispiel Summe: \\ \hspace{0.2cm} $\rightarrow$ ( if (empty? list ) 0 ( + ( first list ) ( sum ( rest list ) ) ) ) \\ 
	$\bullet$ Beispiel Liste als Ausgabe: \\
	\hspace{0.2cm} $\rightarrow$ .. ( if ( empty? list ) empty ( \\ \hspace{2.5cm} cons ( sqrt ( first list ) ( sqrts ( rest list ))))) } & 4B/41 \\ \cline{2-4}
	& Filter & \makecell[l]{$\bullet$ Aussortieren von gewissen Elementenn \\ \hspace{0.2cm} $\bullet$ ( define ( filter list ) (if (Sortierbedingung)  
	\\ \hspace{0.2cm} $\rightarrow$ ( cons ( first list ) ( filter list ) ) , falls \#t \\ 
	\hspace{0.2cm} $\rightarrow$ ( filter list ))) , falls \#f } &  4B/42 \\ \cline{2-4}
	& \makecell[l]{homogen \\ heterogen} & \makecell[l]{$\bullet$ Listen auch mit unterschiedlichen Typen möglich $\rightarrow$ heterogen \\ 
	\hspace{0.4cm} $\rightarrow$ ;; Type: ( list of ANY )... } & 4B/107 \\
	\hline
	
	\multicolumn{3}{c}{} \\ 
	\hline 
	
	{\large Objektmodell} & nur Konstanten & \makecell[l]{$\rightarrow$ Werte werden immer kopiert} & 4A/126 \\ \cline{2-4}
	& Idealisiert & \makecell[l]{$\bullet$ Abweichung vom Modell im Hintergrund zur Optimierung} & 4A/129 \\ 
	\hline
	
	\multicolumn{3}{c}{} \\ 
	\hline 
	
	{\large Rekursion} & Zweck & $\bullet$ grundlegendes Konzept zur Steuerung des Programmablaufs &  4A/161 \\ 
	\hline
	
	\multicolumn{3}{c}{} \\ 
	\hline
	
	{\large Streams} & Eigenschaften & \makecell[l]{$\bullet$ nicht in DrRacket (HtDP-TL), sondern nur in Racket \\ 
	$\bullet$ Variante von Listen, ziemlich ähnlich \\ $\bullet$ Einziger Unterschied: Elemente müssen nicht unbedingt physisch existieren} & 8/122\\ \cline{2-4}

	& Funktionen & \makecell[l]{$\bullet$ (stream-cons x str): Hängt x vorne an str \\
	$\bullet$ (stream-first str): Gibt erstes Element von str zurück \\
	$\bullet$ (stream-rest str): Stream ohne erstes Element \\
	$\bullet$ (stream-empty? str): Abfrage ob Stream leer ist \\ 
	$\bullet$ Map, Filter und fold analog zu Listen  } & 8/129  \\
	\hline	
	
	\multicolumn{3}{c}{} \\ 
	\hline 	
	
	{\large Struct} & Zweck & \makecell[l]{$\bullet$ Zusammenfassung von Elementen \\ 
	\hspace{0.4cm} $\rightarrow$ Vergleichbar mit Klasse mit public Attributen  \\ \hspace{5cm} aber ohne Methoden } & 4B/94 \\ \cline{2-4}
	& Syntax & \makecell[l]{$\bullet$ ( define-struct my-struct ( attribut1 attribut2 )) \\ \hspace{0.4cm} $\rightarrow$ Attribute werden auch 'Felder' genannt  } & 4B/99 \\ \cline{2-4}
	& 'Konstruktor' & \makecell[l]{$\bullet$ ( define my-struct-name ( make-my-struct wert1 wert2 )) } & 4B/101 \\ \cline{2-4}
	& Attributzugriff & $\bullet$ .. ( my-struct-attribut1 my-struct-name ) .. & 4B/104 \\ \cline{2-4}
	& mystruct? & $\bullet$ \#t falls Element von Typ my-struct & 4B/112 \\ \cline{2-4}
	& \makecell[l]{Funktionen \\ als Attribute} & \makecell[l]{$\bullet$ ( define-struct functions ( fct1 fct2 )) \\ \hspace{0.4cm} $\bullet$ z.B.: ( define a ( make-functions + * )) \\ 
	\hspace{0.4cm} $\rightarrow$ fct1 von a ist Summe, fct2 von a ist Multiplikation } & 4C/11 \\
	\hline
	
	\multicolumn{3}{c}{} \\ 
	\hline 	
	
	{\large Symbole} & Syntax & $\bullet$ ( define my-symbol 'helloworld ) & 4A/83 \\ \cline{2-4}
	& Verwendung & \makecell[l]{$\bullet$ Symbole stehen nur für sich selbst \\  \hspace{0.4cm} $\rightarrow$ keine Bedeutung für Racket }& 4A/83 \\ \cline{2-4}
	& Gleichheit & $\bullet$ ( if (symbol=? my-symbol1 my-symbol2) (falls \#t) (falls \#f) ) & 4A/84 \\  
	\hline
	
	\multicolumn{3}{c}{} \\ 
	\hline 	
	
	{\large Zahlen} & Exakte Zahlen & \makecell[l]{$\bullet$ ganzzahlig (z.B.: 5) \\ $\bullet$ rational (z.B.: 3/5 $\rightarrow$ wird auch als Bruch gespeichert) } & 4A/61 \\ \cline{2-4}
	& \makecell[l]{Nichtexakte \\ Zahlen} & $\bullet$ irrationale Zahlen (z.B.: ( sqrt 2 ) & 4A/62 \\ \cline{2-4}
	& \makecell[l]{Komplexe \\ Zahlen} & \makecell[l]{$\bullet$ komplexe Zahlen \\ \hspace{0.4cm} $\bullet$ Realteil + Imaginärteil (i nach Imaginärteil) } & 4A/63 \\
	\hline
	
	\multicolumn{3}{c}{} \\ 
	\hline
	
	{\large } & & $\bullet$ & \\ \cline{2-4}
	&  & $\bullet$  &  \\ \cline{2-4}
	&  & $\bullet$  &  \\ \cline{2-4}
	&  & $\bullet$  &  \\ \cline{2-4}
	&  & $\bullet$  &  \\ 
	\hline
	
	\multicolumn{3}{c}{} \\ 
	\hline 
	 
	 
\end{longtable}
\end{center}

\end{document}