\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage[T1]{fontenc}
\usepackage{multirow}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[margin=0.5cm]{geometry}
\usepackage{xcolor}
\usepackage{makecell} 
\usepackage{longtable}
\usepackage{adjustbox}


\title{Java Stichwortverzeichnis}

%\renewcommand{\cellalign}{br} % v -> t,c,b | h -> l,c,r for all cells using thead and makecell
%\renewcommand\theadalign{cl}
%\renewcommand\theadfont{\bfseries}
%\renewcommand\theadgape{\Gape[4pt]}
%\renewcommand\cellgape{\Gape[4pt]}

\begin{document}

\maketitle

\begin{center}

\setlength{\tabcolsep}{0,25cm}
\renewcommand{\arraystretch}{1.7}


\begin{longtable}[h]{ | p{2.3cm} | p{2.3cm} | p{12.6cm} | p{1.2cm} | }
    \hline
    \textcolor{blue}{{\large Kategorie}} & \textcolor{blue}{{\large Unterkategorie}} & 
    \textcolor{blue}{{\large Beschreibung}} & \textcolor{blue}{{\large Skript}} \\ \hline
    
    
    
	{\large Arrays} & Initialisierung & $\bullet$ Datentyp[] myArray = new Datentyp[length]; & 1D/4 \\ \cline{2-4}
	
	& Indizes & $\bullet$ Zugriff auf Speicherort, startet bei [0] &  \\ \cline{2-4}
	
	& Literal null & $\bullet$ Referenz auf keine Speicheradresse, führend ins 'Nichts' & 1D/17 \\ \cline{2-4}
	
	& Längenabfrage & $\bullet$ myArray.length; & 1D/24 \\ \cline{2-4}
	
	& Durchlauf & \makecell[l]{$\bullet$ for(int i = 0; i < myArray.length; i++) \{\}; \\ 
	$\bullet$ Kurzform: for(Datentyp myNewArray : myArray) \{\} \\ 
	\hspace{0.4cm} $\bullet$ statt myArray[i]...; $\rightarrow$ myNewArray...;} & 1D/26 \\ \cline{2-4}
		
	& \makecell[l]{Gemischte \\ Klassen} & $\bullet$ Mithilfe von Vererbung möglich (statischer/dynamischer Typ) & 1F/89 \\  
	\hline    
	
	
    
	\multicolumn{3}{c}{} \\ 
	\hline        
    
    
    
	{\large \makecell[l]{ Arith-  \\metrische \\  Ergebnis- \\ typen}} & Kombinationen & \makecell[l]{$\bullet$ Kombination immer int, außer einer der Operanden ist long \\
	$\bullet$ falls float vorhanden, dann Ergebnis float (selbiges für double) \\ 
	$\bullet$ double > float > long > int} & 1B/205 \\ 
	\hline
	
	
	
	\multicolumn{3}{c}{} \\ 
	\hline     
    
    
    
	{\large \makecell[l]{ Arith- \\ metrische \\ Operationen }} & \makecell{Regeln} & $\bullet$ Punkt vor Strich & 1A/106 \\ \cline{2-4}   
	
	& \makecell[l]{Division \\ bei int} & \makecell[l]{$\bullet$ 2 + 7/3 = 4, falls alle Zahlen vom Datentyp int sind \\
	$\bullet$ $\rightarrow$ Abschneiden der Nachkommastelle} & 1A/107 \\ \cline{2-4}    
	
    & modulo & $\bullet$ Ganzzahlige Division mit Rest (Beispiel: 11 mod 4 = 3) & 1A/108 \\ \cline{2-4}
    
    & Kurzformen & \makecell[l]{$\bullet$ i = i + 5; $\rightarrow$ i += 5; (-=, *=, /=, \%=)\\ 
    $\bullet$ i = i + 1; $\rightarrow$ i++;} & 1B/194 \\ \cline{2-4}
    
	& \makecell[l]{binär und \\ Infix} & \makecell[l]{$\bullet$ Binär: jeder zwei Operanden \\ $\bullet$ Infix: Operator zwischen Operanden \\ 
	$\bullet$ Operationen: + - * / \%} & 1B/195 \\ \cline{2-4}
	
	& \makecell[l]{unär und \\  präfix  }& \makecell[l]{$\bullet$ Unär: nur ein Operand \\ $\bullet$ Präfix: Operator vorangestellt \\ 
	$\bullet$ Vorzeichen: + -} & 1B/196 \\ \cline{2-4}
	
	& \makecell[l]{Inkrement \\ Dekrement} & \makecell[l]{$\bullet$ Unär und Postfix (nachgestellt) | i++; i--; \\ 
	$\bullet$ Auch als Präfix: ++n; --n; \\ \hspace{0.4cm} $\rightarrow$ Zurückliefern des neuen Werts von n \\ 
	\hspace{0.4cm} $\bullet$ erst n, dann erhöhen | erst erhöhen, dann n } & 1B/197 \\ \cline{2-4}
	
	& \makecell[l]{Zuweisungs- \\basiert} & $\bullet$ = += -= *= /= \%= & 1B/198 \\ \cline{2-4}
	
	& Vergleiche & $\bullet$ == != < > <= >= & 1B/199 \\ \cline{2-4}
	
	& Ternär & \makecell[l]{$\bullet$ Bedingungsoperator: '?' \\ $\bullet$ z.B.: x = (Bedingung b) ? Falls b true : Falls b false} & 1B/226 \\
	\hline    
	
	
    
	\multicolumn{3}{c}{} \\ 
	\hline     
	
	
	
	{\large \makecell{Begriffs- \\ erklärung}} & Variablen & \makecell[l]{$\bullet$ Container, deren Werte veränderbar sind \\ 
	\hspace{0.3cm}(z.B.: Integer, myVariable,..)} & 1B/95 \\ \cline{2-4}
	
	& Referenz & \makecell[l]{$\bullet$ Dadurch wird ein Objekt referenziert (Verweis) \\ 
	\hspace{0.3cm} (z.B.: Name eines Objekte von Klassen, Arrays,..)} & 1B/96  \\ \cline{2-4}
	
	& Objekt & \makecell[l]{$\bullet$ Der Teil, der mit dem Operator new reserviert wird \\ 
	$\bullet$ Objekte != Variablen/ Konstanten und andersrum }  &  \\ \cline{2-4}
	
	& Konstante & \makecell[l]{$\bullet$ Syntax: final ...; \\ $\bullet$ Wert kann nicht mehr geändert werden \\ 
	$\bullet$ Referenzen auch nicht änderbar (referenziertes Objekt schon)} & 1B/100 \\
	\hline
	
	
	
	\multicolumn{3}{c}{} \\ 
	\hline 
	
	
	
	{\large Bytedaten} & Eigenschaften & \makecell[l]{$\bullet$ byteweises Lesen bzw Schreiben in Dateien \\
	$\bullet$ in Praxis jedoch wahrscheinlich irrelevant \\
	\hspace{0.4cm} $\rightarrow$ Binärdateien einfacher über Bibliotheken zugänglich \\
	$\bullet$ hier sinnvoll bei Zugriff auf Bilder oder Videos} & 8/134 \\ \cline{2-4}
	
	& InputStream & \makecell[l]{$\bullet$ Abstrakte Klasse \\
	$\bullet$ z.B. FileInputStream für Lesezugriff auf Dateien \\
	$\bullet$ Subtypen: \\
	\hspace{0.4cm} $\rightarrow$ java.util.zip.ZipInputStream (für Zip-Dateien) \\
	\hspace{0.4cm} $\rightarrow$ java.util.jar.JarInputStream (für Jar-Dateien) \\
	\hspace{0.4cm} $\rightarrow$ javax.sound.sampled.AudioInputStream} & 8/142 \\ \cline{2-4}
	
	& Einlesen & \makecell[l]{$\bullet$ Einlesen mithilfe While-Schleife (z.B.: while(true)\{\} \\
	$\bullet$  Speichern als int: int n = InputStream.read(); \\
	$\bullet$ Erreichen des Dateiendes: if ( n == -1 ) \{ return; \} \\
	$\bullet$-1 als Konvention für unmöglichen Wert} & 8/135 \\ \cline{2-4}
	
	& Schreiben & \makecell[l]{$\bullet$ Ziel eines OutputStream: Datensenke \\
	$\bullet$ Analog zu InputStream \\
	$\bullet$ Methode FileOutputStream.write(int); }  & 8/145 \\ \cline{2-4}
	
	& \makecell[l]{Buffered-\\ Inputreader} & \makecell[l]{$\bullet$ Kann mehrere Bytes auf einmal einlesen \\
	$\bullet$ Erhält intern ein Array von Bytes und gibt immer eins davon aus (Puffer)\\
	$\bullet$ Wenn Array leer, wird neues Array eingelesen \\
	$\bullet$ Bei Write genau umgekehrt, Byte wird in Puffer zwischengespeichert \\
	\hspace{0.4cm} $\rightarrow$ Sobald Puffer voll $\rightarrow$ komplett geschrieben }  & 8/150 \\ \cline{2-4}
	
	& PrintStream & \makecell[l]{$\bullet$ Dient als Konvertierer in byteweise Repräsentation \\
	$\bullet$ System.out: Klassenattribut out ist von Klasse PrintStream \\
	$\bullet$ System.in: Klasssenattribut in ist von Klasse InputStream \\ 
	$\bullet$ System.err: Seperates Log für Fehlerdateien \\ 
	\hspace{0.4cm} $\rightarrow$ Um z.B. Fehlermeldungen aus anderem Output zu filtern (Log-Datei) }  & 8/157 \\ \cline{2-4}
	
	&  & \makecell[l]{$\bullet$  }  &  \\ 
	\hline
	
	
	
	\multicolumn{3}{c}{} \\ 
	\hline 
	
	
	
	{\large Collections } & Definition  & \makecell[l]{$\bullet$ Sammlungen von Elementen eines bestimmten Typs \\ 
	$\bullet$ Typ als generischer Typparameter offen \\
	$\bullet$ alle im Package java.util } & 7/2 \\ \cline{2-4}
	
	& \makecell[l]{ Zentrale \\ Elemente } & \makecell[l]{$\bullet$ Collection (Interface): \\ 
	\hspace{0.4cm} $\rightarrow$ Alle Collections implementieren dieses Interface \\
	$\bullet$ Collections (Klasse): \\ 
	\hspace{0.4cm} $\rightarrow$ nützliche Basisalgorithmen (Sortieren)\\
	$\bullet$ List (Interface) \\
	\hspace{0.4cm} $\rightarrow$ Erweitert Collection (z.B.: Reihenfolge auf Elementen) \\
	\hspace{0.4cm} $\rightarrow$ Elemente in Reihenfolge (definierte Position) \\
	$\bullet$ Iterator (Interface): \\ 
	\hspace{0.4cm} $\rightarrow$ Durchlauf aller Elemente einer Collection \\
	$\bullet$ Beispiele Collection-Klasssen: \\
	\hspace{0.4cm} $\rightarrow$ Vector, LinkedList, ArrayList, TreeSet, HashSet}  & 7/3 \\ \cline{2-4}
	
	& Syntax & \makecell[l]{$\bullet$ Collection<Number> c1 = new ArrayList<Number>; \\ 
	\hspace{0.4cm} $\rightarrow$ Variable vom Interface Collection instanziiert mit Number \\
	\hspace{0.4cm} $\rightarrow$ Objekt von Klasse ArrayList (implementiert Collection) }  & 7/10 \\ \cline{2-4}
	
	& Collection & \makecell[l]{$\bullet$ boolean add (T element) throws ... \\
	\hspace{0.4cm} $\rightarrow$ Hinzufügen von Elementen zur Liste / true falls erfolgreich \\
	$\bullet$ addAll, Parameter Typ Collection \\
	\hspace{0.4cm} $\rightarrow$ Fügt alle Objekte aus übergebener Collection in Aufruf ein \\
	$\bullet$ size \\ 
	\hspace{0.4cm} $\rightarrow$ Gibt Anzahl der Elemente in Collection aus \\
	$\bullet$ isEmpty \\ 
	\hspace{0.4cm} $\rightarrow$ Liefert dann true, wenn Collection keine Elemente enthält \\
	$\bullet$ contains, Parameter Typ Object \\
	\hspace{0.4cm} $\rightarrow$ überprüft ob Object in Collection enthalten ist \\
	$\bullet$ containsAll, Parameter Typ Collection \\
	\hspace{0.4cm} $\rightarrow$ true, falls contains für alle Elemente der Collection true \\ 
	$\bullet$ clear \\
	\hspace{0.4cm} $\rightarrow$ Entfernt alle Elemente aus der aufrufenden Collection \\
	$\bullet$ remove, Parameter Typ Object \\ 
	\hspace{0.4cm} $\rightarrow$ Liefert true, falls Object vorhanden und entfernt dieses} & 7/18 \\ \cline{2-4}
	
	
	& List & \makecell[l]{
	$\bullet$ indexOf, Parameter Typ Object \\
	\hspace{0.4cm} $\rightarrow$ Liefert ersten Index zurück, an dem Object zu finden ist \\
	\hspace{0.4cm} $\rightarrow$ Liefert -1 zurück, falls Object nicht enthalten ist\\
	$\bullet$ set, Parameter Typ int und Typ Object \\ 
	\hspace{0.4cm} $\rightarrow$ Ersetzt Wert an der Stelle int durch Object \\
	\hspace{0.4cm} $\rightarrow$ Gibt Element zurück, das vorher an der Position war \\
	$\bullet$ add, Parameter Typ int und Typ Object \\
	\hspace{0.4cm} $\rightarrow$ Fügt Object an Stelle int ein \\
	\hspace{0.4cm} $\rightarrow$ Schiebt alle Elemente ab int um eins nach hinten \\
	\hspace{0.4cm} $\rightarrow$ Ohne int: an Ende der Liste (add von Collection) \\
	$\bullet$ get, Parameter Typ int \\
	\hspace{0.4cm} $\rightarrow$ Zugriff auf Element in Liste}  & 7/30 \\ \cline{2-4}
	
	& Wildcards & \makecell[l]{$\bullet$ Funktionsweise synchron zu Generics (siehe Generics }  & 7/52 \\ \cline{2-4}
	
	& \makecell[l]{Lambda in \\ Liste} & \makecell[l]{$\bullet$ Funktionsweise synchron zu Arrays \\
	\hspace{0.4cm} $\rightarrow$ List<IntPredicate> pred = new ...; \\
	\hspace{0.4cm} $\rightarrow$ pred.add(n -> n \% 2 == 1); }  & 7/65 \\ \cline{2-4}
	
	& Sortieren & \makecell[l]{$\bullet$  mit Comparator (siehe Generics) \\ 
	\hspace{0.4cm} $\rightarrow$ Collections.sort(list, new BedingungComparator()); \\
	\hspace{0.4cm} $\rightarrow$ Sortierlogik durch zweiten Parameter vorgegeben \\
	\hspace{0.4cm} $\rightarrow$ Comparator Klasse mit selben Typparameter wie list}  & 7/66 \\ \cline{2-4}
	
	& Iterator & \makecell[l]{$\bullet$ Syntax:  (Collection<Number> c1 = ArrayList<Number>();) \\
	\hspace{0.4cm} $\rightarrow$ Iterator<Number> it1 = c1.iterator(); \\
	\hspace{0.4cm} $\rightarrow$ Gibt Interface Iterator von eigener Iterator Klasse zurück \\ 
	$\bullet$ Verwendung: \\
	\hspace{0.4cm} $\rightarrow$ while(it1.hasNext()) \{   \\
	\hspace{1cm} it1.next().function(); \} \\
	\hspace{0.4cm} $\bullet$ hasNext() \\
	\hspace{0.6cm} $\rightarrow$ min. 1 Element noch nicht vom Iterator zurückgeliefert \\
	\hspace{0.4cm} $\bullet$ next() \\
	\hspace{0.6cm} $\rightarrow$ nächstes Element in Collection \\
	\hspace{0.6cm} $\rightarrow$ bei Collection Reihenfolge unbestimmt \\
	\hspace{0.6cm} $\rightarrow$ bei Liste Reihenfolge nach Index (ab 0) \\
	$\bullet$ Kurzform for-Schleife: \\
	\hspace{0.4cm} $\rightarrow$ for(String str : coll) \{...\} \\
	\hspace{0.6cm} $\rightarrow$ Alle Strings der Collection coll nacheinander}  & 7/75 \\ \cline{2-4}
	
	& Map & \makecell[l]{$\bullet$ Zwei Parameter: Key und Value \\
	\hspace{0.4cm} $\rightarrow$ Beispiel Map<String, X> = ... ; \\
	\hspace{0.4cm} $\rightarrow$ Value wird zum jeweiligen Key gespeichert \\
	\hspace{0.4cm} $\rightarrow$ Abbildung von den Keys ind die Values \\
	$\bullet$ Keys müssen immer unterschiedlich sein, Values nicht \\
	$\bullet$ Methode put(key,value); \\
	\hspace{0.4cm} $\rightarrow$ fügt Element ein \\
	$\bullet$ Methode get: X x1 = map.get(key); \\
	\hspace{0.4cm} $\rightarrow$ Liefert Value zu übergebenen Key zurück \\
	\hspace{0.4cm} $\rightarrow$ Falls Key nicht vorhanden, return null}  & 7/90 \\ \cline{2-4}
	
	& \makecell[l]{Eigene \\ LinkedList} & \makecell[l]{$\bullet$ public class ListItem <T> \{ \\ 
	\hspace{5cm} public T key; \\ 
	\hspace{5cm} public ListItem<T> next; \} \\
	\hspace{0.4cm} $\rightarrow$ Verkettung der Elemente durch Attribut der eigenen Klasse \\ 
	$\bullet$ public class MyLinkedList<T> implements List \{ \\
	\hspace{3cm} private ListItem<T> head; \} \\
	\hspace{0.4cm} $\rightarrow$ Verweis auf den Kopf der Liste (erstes Element)\\
	$\bullet$ Durchlauf durch alle Elemente: \\ 
	\hspace{0.4cm} $\rightarrow$ Laufpointer: ListItem<T> p = head; (Laufvariable) \\
	\hspace{0.4cm} $\rightarrow$ Nächster Schritt: p = p.next; \\
	\hspace{0.4cm} $\rightarrow$ Vorwärtsschritt = Verweis auf nächstes Element \\
	\hspace{0.4cm} $\rightarrow$ Abbruchkriterium p gleich null, da Liste zu Ende \\
	\hspace{0.4cm} $\rightarrow$ for(ListItem<T> p = head; p != null; p = p.next) \{\} \\
	$\bullet$ Element hinzufügen: \\
	\hspace{0.4cm} $\bullet$ An den Anfang (Index 0): \\
	\hspace{0.6cm} $\rightarrow$ ListItem<T> tmp = new ListItem<T>(); \\
	\hspace{0.6cm} $\rightarrow$ tmp.key = head; \\
	\hspace{0.6cm} $\rightarrow$ tmp.next = head; \\
	\hspace{0.6cm} $\rightarrow$ head = tmp; \\
	\hspace{0.6cm} $\rightarrow$ Reihenfolge WICHTIG! head ist einziger Verweis auf Liste \\ 
	\hspace{0.4cm} $\bullet$ Beliebige Stelle (Index n): \\
	\hspace{0.6cm} $\rightarrow$ Arbeiten mithilfe des Laufpointers p \\
	\hspace{0.6cm} $\rightarrow$ Code erst dann ausführen wenn p an Stelle n-1 \\
	\hspace{0.6cm} $\rightarrow$ tmp.key = key;\\
	\hspace{0.6cm} $\rightarrow$ tmp.next = p.next; \\
	\hspace{0.6cm} $\rightarrow$ p.next = tmp; \\
	$\bullet$ Methode add in java.util.List: \\
	\hspace{0.4cm} $\rightarrow$ public void add (int pos, T key) \{\} \\ 
	\hspace{0.4cm} $\rightarrow$ Position und einzufügendes Objekt \\
	$\bullet$ Entfernen eines Elements: \\ \
	\hspace{0.4cm} $\bullet$ Am Anfang (Index 0): \\
	\hspace{0.6cm} $\rightarrow$ head = head.next; \\
	\hspace{0.6cm} $\rightarrow$ Überspringen des erstes Elements\\
	\hspace{0.4cm} $\bullet$ Beliege Stelle (Index n): \\
	\hspace{0.6cm} $\rightarrow$ Analog zum Einfügen \\
	\hspace{0.6cm} $\rightarrow$ p.next = p.next.next; \\ 
	$\bullet$ Iterator: \\
	\hspace{0.4cm} class MyLinkedListIterator<T> implements Iterator <T> \{ \\ 
	\hspace{0.4cm} private ListItem<T> p; ... \} \\
	\hspace{0.4cm} Iterator intern = Verweis auf Listenelement \\
	\hspace{0.6cm} Wird durch Konstruktor auf Kopf der Liste gesetzt} \\
	\hline


	
	\multicolumn{3}{c}{} \\ 
	\hline 
	
	
	
	{\large Enums} & Syntax & $\bullet$ Modifier enum myEnum \{\} & 1E/6 \\ \cline{2-4}
	
	& Zweck & \makecell[l]{$\bullet$ Zusammenfassung mehrerer Konstanten zu einer Einheit \\ 
	$\bullet$ vordefinierte Menge an Objekten} & 1E/7 \\ \cline{2-4}
	
	& Verwendung & $\bullet$ myEnum.ENUM; & 1E/9 \\ \cline{2-4}
	\hline
	
	
	
	\multicolumn{3}{c}{} \\ 
	\hline 	
	
	
	
	{\large Exceptions} & Laufzeitfehler & \makecell[l]{$\bullet$ werden nicht vom Compiler entdeckt \\ 
	$\bullet$ Abbruch des Programms \\ 
	$\bullet$ Fehlermeldung mit Call-Stack und Zeilennummer \\ $\bullet$ z.B.: Teilen durch 0 } & 5/2 \\ \cline{2-4}
	
	& Definition & \makecell[l]{$\bullet$ Klasse java.lang.Exception und alle die davon abgeleitet sind } & 5/12 \\ \cline{2-4}
	
	& Werfen & \makecell[l]{$\bullet$ Exception wird in Methodenkopf geworfen: \\ 
	\hspace{0.4cm} $\rightarrow$ my-method (...) throws Exception \{...\} \\
	\hspace{0.4cm} $\rightarrow$ auch mehrere Exceptions möglich \\ $\bullet$ Wurf: throw new Exception (''Fehlermeldungstext''); \\ 
	\hspace{0.4cm} $\rightarrow$ Wirft Exception mit String als Konstruktorparameter \\ 
	\hspace{0.4cm} $\bullet$ Führt zu Methodenabbruch an der Stelle} & 5/13 \\ \cline{2-4}
	
	& Fangen & \makecell[l]{$\bullet$ Falls Methoden potenziell Exceptions werfen könnte: \\
	\hspace{0.4cm} $\bullet$ Einfassen in try-Block: try \{ .. Methode.. \} \\
	\hspace{0.4cm} $\bullet$ Bei Exceptionwurf $\rightarrow$ Abbruch des try-Blocks \\ 
	$\rightarrow$ Fangen durch catch-Block: catch (Exception name) \{...\}\\ 
	\hspace{0.4cm} $\bullet$ Kein anderer Code zwischen try und catch Block} & 5/24 \\ \cline{2-4}
	
	& Methoden & \makecell[l]{$\bullet$ exc.getMessage() Gibt gespeicherte Fehlermeldung aus \\ 
	$\bullet$ exc.printStackTrace() Gibt Call-Stack aus}   & 5/33 \\ \cline{2-4}
	
	& Overwrite & \makecell[l]{$\bullet$ In überschreibender Methode Ersetzen der Exception durch \\ 
	\hspace{0.3cm}abgeleitete Exception erlaubt} & 5/44 \\ \cline{2-4}
	
	& \makecell[l]{Eigene \\ Klassen} & \makecell[l]{ $\bullet$ public myClass extends Exception \{\} \\ 
	$\bullet$ Konstruktor: .. super(String);.. } & 5/52 \\ \cline{2-4}
	
	& \makecell[l]{Mehrere \\ Exceptions}&  \makecell[l]{$\bullet$ throws Excep1, Excep2 \{\} \\ 
	\hspace{0.4cm} $\rightarrow$ mehrere catch-Blöcke \\ 
	$\bullet$ Jedoch auch allgemein throws Exception möglich, \\ \hspace{0.2cm} da Supertyp aller Exceptions \\ 
	\hspace{0.2cm} $\rightarrow$selbes Prinzip lässt sich auf catch-Blöcke übertragen \\ 
	\hspace{0.2cm} $\rightarrow$ Erster Block in den Exception passt wird verwendet \\	
	$\bullet$ 2 Exceptions im selben catch-Block: \\ \hspace{0.4cm} $\rightarrow$ catch (ExcpA | ExcpB) \{...\}}& 5/82\\ \cline{2-4}
	
	& Weiterreichen & \makecell[l]{$\bullet$ Methode mit Exception in anderer Methode \\ 
	$\bullet$ Weiterreichen der Exception an aufrufende Methode: \\
	\hspace{0.4cm} $\rightarrow$ ... throws Exception \{\} in aufrufender Methode \\ 
	\hspace{0.4cm} $\rightarrow$ Dadurch kein try und catch Block für aufgerufene Methode \\
	$\bullet$ Spätestens main muss alle weitergereichten Exceptions fangen} & 5/93 \\ \cline{2-4}
	
	& try-with-ressources & $\bullet$ Dokumentation $\rightarrow$ Parameter bei try-Block & 5/98 \\ \cline{2-4}
	
	& \makecell[l]{Run-Time-\\Exceptions} & \makecell[l]{ $\bullet$ Ausnahme: Diese müssen nicht gefangen werden \\ 
	$\bullet$ Hauptsächlich zur Übersichtlichkeit, da häufige Verwendung \\
	$\bullet$ z.B.: IndexOutOfBoundsException \\ \hspace{0.4cm} 
	$\rightarrow$ Sonst jeder Arrayaufruf in try/catch-Block } & 5/99 \\ \cline{2-4} 
	
	& Testphase & \makecell[l]{$\bullet$ Throwable und Error  \\ \hspace{0.4cm} $\bullet$ Exception und Error von Throwable abgeleitet \\
	\hspace{0.4cm} $\bullet$ Error-Klassen führen immer zum Programmabbruch, \\ \hspace{0.8cm} werden generell nicht gefangen
	\\ $\bullet$ Sonderform AssertionError \\ \hspace{0.4cm} $\bullet$ Funktionstest innerhalb Methode \\
	\hspace{0.4cm} $\bullet$ Kurzform: assert Bedingung: ''String''; \\ \hspace{0.4cm} $\rightarrow$ negierte Bedingung in Kurzform! \\
	\hspace{0.4cm} $\bullet$ Warum? Abschaltbar durch Compiler!} & 5/117 \\ \cline{2-4}
	
	& JUnit-Tests & \makecell[l]{ $\bullet$ Zweck: Funktionstest der Methode als Ganzes \\ $\bullet$ Imports: \\ 
	\hspace{0.4cm} import static org.junit.Assert.assertEquals; \\ \hspace{0.4cm} import static org.junit.Assert.assertTrue; \\
	\hspace{0.4cm} import static org.junit.jupiter.api.Assertions.assertThrows; \\
	\hspace{0.4cm} import org.junit.jupiter.api.Test; \\ \hspace{0.4cm} import org.junit.jupiter.api.BeforeEach; \\ $\bullet$ Verwendung: \\
	\hspace{0.4cm} $\bullet$ Verwenden eigener Quelldatei und Import der Testdatei \\ 
	\hspace{0.4cm} $\bullet$ @Test führt zur direkten Ausführung der Methode \\ 
	\hspace{0.4cm} $\bullet$ @BeforeEach Ausführung dieser Methode vor @Test Methoden \\
	\hspace{0.4cm} $\bullet$ Erstellung von void Methoden zum Testen \\ $\bullet$ Funktionen: \\
	\hspace{0.4cm} $\bullet$ assertEquals( param1, param2); \\ 
	\hspace{0.6cm} $\rightarrow$ Test auf Gleichheit von 2 Parametern \\ 
	\hspace{0.6cm} $\rightarrow$ Mit 3 Parametern: 3. Parameter = Intervall für Abweichung \\ 
	\hspace{0.4cm} $\bullet$ assertSame(...);\\ \hspace{0.6cm} $\bullet$ Objektidentität\\ \hspace{0.4cm} $\bullet$ assertThrows(...); \\ 
	\hspace{0.6cm} $\bullet$ Überprüft ob erwarteter Error geworfen wird} & 5/132 \\
	\hline
	
	
	
	\multicolumn{3}{c}{} \\ 
	\hline 
	
	
	
	{\large Fehler} & Compiler & \makecell[l]{$\bullet$ werden vom Compiler erkannt \\ 
	$\bullet$ z.B.: falsche Klammerung, fehlendes ;, etc } & 3A/3 \\ \cline{2-4}
	
	& Runtime & \makecell[l]{$\bullet$ werden während Laufzeit erkannt \\ 
	$\bullet$ z.B.: Division durch 0, Array out of bounds, etc.} & 3A/4 \\ \cline{2-4} 
	\hline
	
	
	
	\multicolumn{3}{c}{} \\ 
	\hline 
	
	
	
	{\large Files} & Wissenswertes & \makecell[l]{$\bullet$ Package java.nio.file\\
	$\bullet$ Sammlung von Klassenmethoden } & 8/184 \\ \cline{2-4}
	
	& Methoden & \makecell[l]{$\bullet$ Path path = Paths.get(...);  \\
	$\bullet$ if(Files.exists(path)\{\} (True, falls dort etwas existiert) \\
	$\bullet$ if(Files.isReadable(path)\{\} (True, falls Leserechte vorhanden) \\
	$\bullet$ if(Files.isWritable(path)\{\} (True, falls Schreibrechte vorhanden) \\
	$\bullet$ if(Files.isRegularFile(path)\{\} (True, falls Typ der Datei regulär ist) \\
	$\bullet$ if(Files.isDirectory(path)\{\} (True, falls Typ Verzeichnis) \\
	$\bullet$ long size = File.size(path); (Ruft Länge der Datei ab)}  & 8/186 \\ \cline{2-4}
	
	& Manipulation & \makecell[l]{$\bullet$ Files.createFile(path) (Erzeugt Datei an Pfadstelle \\
	$\bullet$ Files.copy(path1,path2); (Kopiert Datei an Pfad 1 nach Pfad 2) \\
	$\bullet$ Files.move(path3, path4); (Bewegt bzw benennt die Dateien um) \\
	$\bullet$ Files.delete(path); (Entfernt das Objekt an der Pfadstelle) \\
	\hspace{0.4cm} $\rightarrow$ NoSuchFileException bei Nichtexistieren des Objekts \\
	$\bullet$ Files.deleteIfExists(path); (Falls nicht vorhanden, passiert nichts)}  & 8/194 \\ 
	\hline
	
	
			
	\multicolumn{3}{c}{} \\ 
	\hline 
	
	
	
	{\large GUI} & \makecell[l]{Window \\Manager} & \makecell[l]{$\bullet$ Systemprozess $\rightarrow$ Wird beim Booten gestartet \\
	$\bullet$ Läuft als Service im Hintergrund \\
	$\bullet$ Stellt generelle Funktionen zur Verfügung } & 10/2 \\ \cline{2-4}
	
	& Frame & \makecell[l]{$\bullet$ Window mit Rahmen (Subtyp von Klasse Window) \\
	$\bullet$ Teil des Packages java.awt (abstract window toolkit) \\
	$\bullet$ Standardmäßig unsichtbar \\
	$\bullet$ Erzeugung: \\
	\hspace{0.4cm} $\rightarrow$ Frame frame = new Frame(new String("Hello World!")); \\
	\hspace{0.4cm} $\rightarrow$ Ein Konstruktor z.B. mit String $\rightarrow$ Titel des Rahmens \\
	$\bullet$ Umgang: \\
	\hspace{0.4cm} $\rightarrow$ Erzeugung eines Subtypes von Frame um Sachen hinzuzufügen\\
	\hspace{0.4cm} $\rightarrow$ ActionListener werden oft in SubFrame geschrieben (private class) \\
	$\bullet$ Methoden: \\
	\hspace{0.4cm} $\rightarrow$ frame.setVisible(true); (Fenster sichtbar) \\
	\hspace{0.4cm} $\rightarrow$ frame.setVisible(false); (Fenster unsichtbar) \\
	\hspace{0.4cm} $\rightarrow$ frame.setBackground(new Color(0, 0, 0)); (setzt Farbe) \\
	\hspace{0.4cm} $\rightarrow$ frame.dispose(); (alle Ressourcen werden freigegeben) \\
	\hspace{0.4cm} $\rightarrow$ frame.setExtendedState(Frame.ICONIFIED); (ikonifiiert) \\
	\hspace{0.4cm} $\rightarrow$ frame.setExtendedState(Frame.NORMAL); (deikonifiziert) \\
	\hspace{0.4cm} $\rightarrow$ frame.setExtendedState(Frame.MAXIMIZED\_HORIZ); \\
	\hspace{0.6cm} $\rightarrow$ Setzte Framebreite auf Bildschirmbreite \\
	\hspace{0.4cm} $\rightarrow$ frame.add(...); (Hinzufügen von z.B. Buttons)}  & 10/11 \\ \cline{2-4}
	
	& Buttons & \makecell[l]{$\bullet$ Erzeugung: \\
	\hspace{0.4cm} $\rightarrow$ Button button1 = new Button(''String'');\\
	\hspace{0.4cm} $\rightarrow$ String = Text auf Button \\
	\hspace{0.4cm} $\rightarrow$ Größe des Buttons wird durch String determiniert \\
	$\bullet$ Werden mithilfe von frame.add(button1); ins Frame eingefügt \\
	$\bullet$ Methoden: \\
	\hspace{0.4cm} $\rightarrow$ button.setFont(new Font(''font'', Font.BOLD, size);\\
	\hspace{0.4cm} $\rightarrow$ button.addActionListener(actionListenerClass); \\
	\hspace{0.4cm} $\rightarrow$ button.setLabel(''String''); (ändert Titel) }  & 10/25 \\ \cline{2-4}
	
	& \makecell[l]{Action- \\ Listener} & \makecell[l]{$\bullet$ Klasse die ActionListener (java.awt.event) implementiert benötigt \\
	$\bullet$ funktionale Methode: void actionPerformed (ActionEvent event) \{\} \\
	$\bullet$ Dann Hinzufügen zum Button: \\
	\hspace{0.4cm} $\rightarrow$ button.addActionListener(actionListenerClass);  \\
	\hspace{0.4cm} $\rightarrow$ Verwendung eines Lambda-Ausdrucks hier auch möglich (Folie 69) \\
	\hspace{0.4cm} $\rightarrow$ Automatische Erzeugung eines Threads, der auf Eingaben wartet \\
	\hspace{0.4cm} $\rightarrow$ Event Dispatch Thread}  & 10/33 \\ \cline{2-4}
	
	& ActionEvent & \makecell[l]{$\bullet$ Hier Verwendung als Parameter für actionPerformed(ActionEvent event) \\
	$\bullet$ Methoden: \\
	\hspace{0.4cm} $\rightarrow$ event.getWhen(); (Rückgabe des Zeitpunkt als long in ms seit 1970) \\
	\hspace{0.4cm} $\rightarrow$ Hilfreiche Umrechnung dieser mithilfe der Klasse Timestamp \\
	\hspace{0.4cm} $\rightarrow$ Methoden von Timestamp: getHour(), getMinute() }  & 10/50 \\ \cline{2-4}
	
	& \makecell[l]{ Weitere \\ Listener \\ und Events}  & \makecell[l]{$\bullet$ Aufbau: Listener / Event\\
	$\bullet$ KeyListener / KeyEvent \\
	$\bullet$ MouseListener / MouseEvent \\
	$\bullet$ MouseMotionListener / MouseEvent \\
	$\bullet$ MouseWheelListener / MouseWheelEvent \\
	$\bullet$ WindowFocusListener / WindowEvent \\
	$\bullet$ WindowListener / WindowEvent \\
	$\bullet$ WindowStateListener / WindowEvent \\
	$\bullet$ frame.addKeyListener(new MyKeyListener(..));
	\hspace{0.4cm} $\rightarrow$ analog für Rest }  & 10/70 \\ \cline{2-4}
	
	& \makecell[l]{KeyListener} & \makecell[l]{
	$\bullet$ public interface KeyListener \{ \\
	\hspace{1cm} public void keyPressed (KeyEvent event); \\
	\hspace{1cm} public void keyReleased (KeyEvent event); \\
	\hspace{1cm} public void keyTyped (KeyEvent event); \} \\
	$\bullet$ Jede dieser Methoden ähnlich wie actionPerformed\\
	$\bullet$ Zu jedem nicht functional Listener-Interface gibt \\
	\hspace{0.4cm} es eine zugehörige Adapter-Klasse \\
	\hspace{0.4cm} $\rightarrow$ Damit nicht alle Methoden implementiert werden müssen \\
	\hspace{0.4cm} $\rightarrow$ Sondern hier z.B. mithilfe von ''extends KeyAdapter'' nur keyPressed} & 10/77 \\ \cline{2-4}
	
	& \makecell[l]{Mouse \\ Listener} & \makecell[l]{$\bullet$ public interface MouseListener \{
	\hspace{1cm} public void mouseClicked(MouseEvent event); \\
	\hspace{1cm} public void mousePressed(MouseEvent event); \\
	\hspace{1cm} public void mouseReleased(MouseEvent event); \\
	\hspace{1cm} public void mouseEntered(MouseEvent event); \\
	\hspace{1cm} public void mouseExited(MouseEvent event); \} \\
	$\bullet$ public interface MouseMotionListener \{ \\
	\hspace{1cm} public void mouseDragged(MouseEvent event); \\
	\hspace{1cm} public void mouseMoved(MouseEvent event); \} \\
	$\bullet$ public interface MouseWheelListener \{ \\
	\hspace{1cm} public void mouseWheelMoved(MouseWheelEvent event); \}
	$\bullet$ MouseAdapter implementiert hier alle Interfaces \\ }  & 10/88 \\ \cline{2-4}
	
	& \makecell[l]{Window\\ Listener} & \makecell[l]{$\bullet$ public interface WindowListener \{ \\
	\hspace{1cm} public void windowOpened(WindowEvent event); \\
	\hspace{1cm} public void windowClosing(WindowEvent event);  \\
	\hspace{1cm} public void windowClosed(WindowEvent event);  \\
	\hspace{1cm} public void windowActivated(WindowEvent event);  \\
	\hspace{1cm} public void windowDeactivated(WindowEvent event);  \\
	\hspace{1cm} public void windowIconified(WindowEvent event);  \\
	\hspace{1cm} public void windowDeiconified(WindowEvent event); \} \\
	$\bullet$ public interface WindowStateListener \{ \\
	\hspace{1cm} public void windowStateChanged (WindowEvent event); \} \\
	$\bullet$ public interface WindowFocusListener \{ \\
	\hspace{1cm} public void windowGainedFocus(WindowEvent event);\\
	\hspace{1cm} public void windowLostFocus(WindowEvent event); \} \\
	 }  & 10/98 \\ \cline{2-4}
	 
	
	& Adapter & \makecell[l]{$\bullet$ Verbindung zwischen Interfaces und der Klasse Adapter:\\
	$\bullet$ abstract public class KeyAdapter implements KeyListener \\
	$\bullet$ abstract public class MouseAdapter implements MouseListener,\\
	\hspace{2cm} MouseMotionListener, MouseWheelListener \\
	$\bullet$ abstract public class WindowAdapter implements WindowListener, \\
	\hspace{2cm} WindowFocusListener, WindowStateListener }  & 10/101 \\ \cline{2-4}
	
	& Canvas & \makecell[l]{$\bullet$ abgegrenzte Zeichenfläche in einem Fenster \\
	$\bullet$ public class MyCanvas extends Canvas \{ ... \}\\
	\hspace{0.4cm} $\rightarrow$ Eigener Subtyp um Methode paint selbst zu implementieren \\
	$\bullet$ Zeichenbeispiel mit Code ab 10/112 }  & 10/107 \\ \cline{2-4}
	
	& Checkbox & \makecell[l]{$\bullet$ Besteht aus kleinem Button und kurzem Text \\
	$\bullet$ Interface ItemListener mit funktionaler Methode: \\
	\hspace{0.4cm} $\rightarrow$ public void itemStateChanged(ItemEvent event); \\
	$\bullet$ checkbox.isSelected(): True, falls checkbox an ist \\ }  & 10/132 \\ \cline{2-4}
	
	& Choice & \makecell[l]{$\bullet$ Repräsentiert ein Auswahlmenü \\
	$\bullet$ Choice choice = new Choice(); (am Anfang leer) \\
	$\bullet$ choice.add("Yes"); choice.add("No"); \\
	$\bullet$ choice.select(int); (Zur Anfangswahl) \\
	$\bullet$ Greift auch auf ItemListener zurück \\
	$\bullet$ choice.getSelectedItem() (Wird benötigt für Listener) \\
	\hspace{0.4cm} $\rightarrow$ Zugriff auf ausgewähltes Item }  & 10/146 \\ \cline{2-4}
	
	& Label & \makecell[l]{$\bullet$ Rechteck mit Text / Nicht vom User interagierbar \\
	$\bullet$ Label label = new Label(''String''); \\
	$\bullet$ label.setAligment(Label.CENTER); (LEFT,RIGHT) \\
	$\bullet$ label.setBackground(Color); \\
	$\bullet$ Benötigt anderen Komponenten für Veränderungen, z.B. Button}  & 10/154 \\ \cline{2-4}
	
	& List & \makecell[l]{$\bullet$ Diese List in java.awt, andere List (Generics) in java.util \\
	$\bullet$ Menü mit Auswahlpunkten \\ 
	$\bullet$ List list = new List(int, boolean); \\
	\hspace{0.4cm} $\rightarrow$ int gibt an, wieviele Menüpunkte gleichzeitig angezeigt werden \\
	\hspace{0.4cm} $\rightarrow$ Mehr Objekte als Int $\rightarrow$ Scrollbar \\
	\hspace{0.4cm} $\rightarrow$ boolean gibt an, ob mehrere Menüpunkte auswählbar sind \\
	$\bullet$ int[] selectedIndexes = list.getSelectedIndexes; \\
	\hspace{0.4cm} $\rightarrow$ Speichert Positionen der Punkte, die ausgewählt sind }  & 10/167 \\ \cline{2-4}
	
	& Scrollbar & \makecell[l]{$\bullet$ Scrollbar bar = new Scrollbar(..,..,..,..); \\
	$\bullet$ 4 Parameter: \\
	\hspace{0.4cm} $\rightarrow$ Scrollbar.VERTICAL oder Srollbar.HORIZONTAL \\
	\hspace{0.4cm} $\rightarrow$ Startwert als int \\
	\hspace{0.4cm} $\rightarrow$ Minimalwert z.B. 0 (keinen Einfluss auf Größe) \\
	\hspace{0.4cm} $\rightarrow$ Maximalwert z.B. 255 (keinen Einfluss auf Größe) \\
	$\bullet$ Funktionales Interface AdjustmentListener mit Methode: \\
	\hspace{0.4cm} $\rightarrow$ public void adjustmentValueChanged (AdjustmentEvent event); \\
	$\bullet$ Methode: event.getValue(); (Liefert Wert der Scrollbar) }  & 10/172 \\ \cline{2-4}
	
	& \makecell[l]{Text-\\Component} & \makecell[l]{$\bullet$ zwei Subtypen TextField und TextArea \\
	$\bullet$ TextField: \\
	\hspace{0.4cm} $\rightarrow$ Eingabezeile für den Nutzer (Passworteingabe) \\
	\hspace{0.4cm} $\rightarrow$ Textfield field = new TextField(maxLength); \\
	\hspace{0.4cm} $\rightarrow$ field.setEchorChar('*'); (Ersetzen der Zeichen) \\
	\hspace{0.4cm} $\rightarrow$ Reset mithilfe von field.setEchoChar(0); \\
	\hspace{0.4cm} $\rightarrow$ nutzt KeyListener bzw KeyAdapter \\
	\hspace{0.4cm} $\rightarrow$ Relevant: event.getKeyChar()\\
	$\bullet$ TextArea: \\
	\hspace{0.4cm} $\rightarrow$ Bereich mit beliebig vielen Eingabezeilen \\
	\hspace{0.4cm} $\rightarrow$ TextArea area = new TextArea(''String'', int1, int2, scrollbars); \\
	\hspace{0.4cm} $\rightarrow$ int1: Anzahl Zeilen | int2: Länge Zeilen \\
	\hspace{0.4cm} $\rightarrow$ scrollbars: TextArea.SCROLLBARS\_BOTH für beide Scrollbars \\
	\hspace{0.4cm} $\rightarrow$ VERTICAL\_ONLY | HORIZONTAL\_ONLY | NONE | BOTH \\
 	\hspace{0.4cm} $\rightarrow$ nutzt FocusListener mit focusGained und focusLost }  & 10/185 \\ \cline{2-4}
 	
 	& Hierarchie & \makecell[l]{$\bullet$ Von Component abgeleitet: \\
 	\hspace{0.4cm} $\rightarrow$ Button | Canvas | Checkbox | Choice \\
 	\hspace{0.4cm} $\rightarrow$ Label | List | Scrollbar | TextComponent \\
 	\hspace{0.4cm} $\rightarrow$ Container | Von Container abgeleitet: \\
 	\hspace{0.8cm} $\rightarrow$ Window | Von Window abgeleitet: \\
 	\hspace{1.2cm} $\rightarrow$ Frame }& 10/208 \\ \cline{2-4}
 	
 	& Container & \makecell[l]{$\bullet$ fasst mehrere Komponenten zu einer zusammen \\
 	$\bullet$ Wichtig: Kann auch andere Container enthalten \\ 
    $\bullet$ Methoden: \\
 	\hspace{0.4cm} $\rightarrow$ void paint (Graphics graphics)\\
 	\hspace{0.4cm} $\rightarrow$ void add (component) (wie bisher) \\
 	\hspace{0.4cm} $\rightarrow$ void add(component, Object constraints) (dazu gleich mehr) \\
 	\hspace{0.4cm} $\rightarrow$ void setLayout (LayoutManager manager) (Layout, nutzt constraints) \\
 	\hspace{0.4cm} $\rightarrow$ void validate() (Aktualisierung)}  & 10/216 \\ \cline{2-4}
	
	& Layout-Manager & \makecell[l]{$\bullet$ Automatische Erstellung bei Erstellung eines Containers/Subtyps \\
	\hspace{0.4cm} $\rightarrow$ Abhängig vom Typ | Window und Frame: BorderLayout \\
	$\bullet$ BorderLayout: \\
	\hspace{0.4cm} $\rightarrow$ Findet seine Verwendung in add-Methode mit constraints \\
	\hspace{0.4cm} $\rightarrow$ z.B. BorderLayout.NORTH (.CENTER,.WEST,.EAST,.SOUTH) \\
	\hspace{0.4cm} $\rightarrow$ Automatische Unterteilung des Frames in 5 Bereiche \\
	\hspace{0.4cm} $\rightarrow$ bei normaler add-Methode wird immer .CENTER angewandt \\
	$\bullet$ Andere LayoutManager: \\
	\hspace{0.4cm} $\rightarrow$ BoxLayout: Anlegung der Komponenten in Reihe \\
	\hspace{0.4cm} $\rightarrow$ GridLayout: Matrixartige Anlegung \\
	\hspace{0.4cm} $\rightarrow$ FlowLayout: Automatische Größenanpassung in Zeilen \\
	\hspace{0.4cm} $\rightarrow$ CardLayout: Anzeigung der Komponenten nacheinander \\
	$\bullet$ frame.validate(): \\
	\hspace{0.4cm} $\rightarrow$ MUSS nach Größen-/Anzahländerungen aufgerufen werden \\ 
	\hspace{0.4cm} $\rightarrow$ richtet Layout wieder richtig aus}	 & 10/226 \\ \cline{2-4}
	
	& Java Swing & \makecell[l]{ $\bullet$ Selbe Funktionen wie java.awt, jedoch mehr Funktionen \\
	$\bullet$ Package javax.swing enthält: \\
	\hspace{0.4cm} $\rightarrow$ JFrame extends java.awt.Frame \\
	\hspace{0.4cm} $\rightarrow$ JComponent extends Java.awt.container \\
	\hspace{0.4cm} $\rightarrow$ von JComponent abgeleitet: \\
	\hspace{0.8cm} $\rightarrow$ JButton | JCheckBox | JLabel | JList<T> \\
	\hspace{0.8cm} $\rightarrow$ JScrollBar | JTextComponent(JTextArea | JTextField) \\
	\hspace{0.8cm} $\rightarrow$ JButton z.B. indirekt über AbstractButton von JComponent \\
	$\bullet$ Tooltips: (MouseOver-Text) \\
	\hspace{0.4cm} $\rightarrow$ button.setToolTipText(''String'');
	$\bullet$ Randdarstellungen: \\
	\hspace{0.4cm} $\rightarrow$ .setBorder(Border border);
	\hspace{0.4cm} $\rightarrow$ Nutzung von Klasse BorderFactory \\
	\hspace{0.4cm} $\rightarrow$ Bsp: BorderFactory.createLineBorder(Color.RED, thickness); \\
	\hspace{0.4cm} $\rightarrow$ BorderFactory.createEmptyBorder(); \\
	$\bullet$ Look and Feel: Plattformunabhängig gleiches Aussehen \\
	\hspace{0.4cm} $\rightarrow$ Folien 10/260-267 \\
	$\bullet$ Key Bindings: \\
	\hspace{0.4cm} $\rightarrow$ sehr codelastig, deswegen Folie zum Verständnis \\
	\hspace{0.4cm} $\rightarrow$ 10/268-276   \\
	$\bullet$ Drag\&Drop\\
	$\bullet$ Assistive Technologies \\
	$\bullet$ Separierung Hauptmenü und eigentliches Fenster \\
	$\bullet$ Weitere Swing-Klassen: \\
	\hspace{0.4cm} $\rightarrow$ JFormattedTextField (einzugebender Text vorformattiert) \\
	\hspace{0.4cm} $\rightarrow$ JPasswordField \\
	\hspace{0.4cm} $\rightarrow$ JRadioButton (kleiner anklickbarer Kreis) \\
	\hspace{0.4cm} $\rightarrow$ JToolBar \\
	\hspace{0.4cm} $\rightarrow$ JSlider (Schieberegler) \\
	\hspace{0.4cm} $\rightarrow$ Popup \\
	\hspace{0.4cm} $\rightarrow$ JTable (TAbelle) \\
	\hspace{0.8cm} $\rightarrow$ JTable table = new JTable (Object[][], Object[]) \\ 
	\hspace{0.8cm} $\rightarrow$ Erstes Array Matrix | Zweites Array Namen der Spalten \\
	\hspace{0.8cm} $\rightarrow$ JScrollPane scrollPane = new JScrollPane(table); \\
	\hspace{0.8cm} $\rightarrow$ Einkapselung des Objekts | Zeigt nur Ausschnitt mit Scrollbars \\
	\hspace{0.8cm} $\rightarrow$ table.setFillsViewportHeight(true); \\
	\hspace{0.8cm} $\rightarrow$ Streckung der Tabelle auf die vertikal benötigte Höhe \\
	\hspace{0.8cm} $\rightarrow$ int[] selectedRows = table.getSelectedRows(); \\
	\hspace{0.8cm} $\rightarrow$ Abfragen der momentan angeklickten Zeilen  } & 10/240 \\
	\hline
	
	
	
	\multicolumn{3}{c}{} \\ 
	\hline 
	
	
	
	{\large if-Anweisung} & Syntax & \makecell[l]{$\bullet$ if (Bedingung) \{\} \\ 
	$\bullet$ bei Einzelner Anweisung auch ohne \{\} }; & 1B/49 \\ \cline{2-4}
	
	& Funktion & $\bullet$  Verzweigung des Programms an gewissen Stellen & 1B/49 \\ \cline{2-4}
	
	& else & \makecell[l]{$\bullet$ Syntax: else \{\} \\ $\bullet$ Fängt alle Fälle ab, die nicht bei if auftreten} & 1B/54 \\ \cline{2-4}
	
	& \makecell[l]{weitere \\ Verzweigung} & \makecell[l]{$\bullet$ switch (Typ) \{ \\ 
	\hspace{2.5cm} case myTyp: ... break; \\ \hspace{2.5cm} default: ... ; \} \\ 
	$\bullet$ myTyp keine  Variable, muss zur Laufzeit schon feststehen } & 3C/218 \\ 
	\hline
	
	
	
	\multicolumn{3}{c}{} \\ 
	\hline 	
	
	
	
	{\large Generics} & Wrapper-Klassen & \makecell[l]{$\bullet$ Zu jedem primitiven Datentypen eine Wrapper-Klasse \\ 
	$\bullet$ Selber Name mit großem Anfangsbuchstaben \\ 
	\hspace{0.4cm} $\bullet$ Außer int und char $\rightarrow$ Integer und Character \\ 
	$\bullet$ Konstruktor mit einzelnem Parameter seines Datentyps \\ $\bullet$ z.B.: in = new Integer; \\
	$\bullet$ Zugriff mit z.B.: in.intValue(); \\ $\bullet$ Boxing / Unboxing: \\ 
	\hspace{0.4cm} $\bullet$ Weitgehend austauschbar $\rightarrow$ automatische Umwandlung} & 6/1 \\ \cline{2-4}
	
	& Klassen & \makecell[l]{$\bullet$ Beispiel: public class Pair <T1, T2 > \{...\} \\ 
	\hspace{0.4cm} $\rightarrow$ Klasse Pair ist generisch bzw. mit T1 und T2 parametrisiert \\ 
	\hspace{0.4cm} $\rightarrow$ T1 und T2 sind Typparameter der Klasse Pair \\ 
	$\bullet$ Konstruktor: z.B.: \\ \hspace{0.2cm} $\rightarrow$ Pair <Integer,Double> p = new Pair<Integer,Double>(i, d); \\ 
	\hspace{0.2cm} $\rightarrow$ Instanziierung von Pair mit Integer und Double}  & 6/12 \\ \cline{2-4}
	
	& Typparameter & \makecell[l]{$\bullet$ Verwendung bei Attributen: \\ 
	\hspace{0.4cm} $\rightarrow$ z.B.: private T1 attribute1; \\ $\bullet$ Verwendung bei Methoden: \\ 
	\hspace{0.4cm} $\rightarrow$ als Rückgabetyp \\ 
	\hspace{0.4cm} $\rightarrow$ als aktualer Parameter (auch im Konstruktor) \\
	\hspace{0.4cm} $\rightarrow$ nur bei Objektmethoden \\
	$\bullet$ Mögliche Parameter: \\
	\hspace{0.4cm} $\rightarrow$ Eigene Klassen \\ \hspace{0.4cm} $\rightarrow$ Arrays (Primitiv/Referenz) \\
	\hspace{0.4cm} $\rightarrow$ Interfaces (eingeschränkt $\rightarrow$ später)\\ 
	\hspace{0.4cm} $\rightarrow$ Parametrisierte Klassen und Interfaces \\ }  & 6/15 \\ \cline{2-4}
	
	& Methoden & \makecell[l]{$\bullet$ In nicht generische Klasse: \\ 
	\hspace{0.4cm} $\rightarrow$ Parametrisierung vor Rückgabetyp \\ 
	\hspace{0.4cm} $\rightarrow$ z.B.: public <T1,T2> Pair<T1,T2> myMethod() ... \\ 
	$\bullet$ in generischer Klasse: \\ 
	\hspace{0.4cm} $\rightarrow$ param. Typarameter müssen nicht mehr angegeben werden}  & 6/38 \\ \cline{2-4}
	
	& Vererbung & \makecell[l]{$\bullet$ z.B.: void m (Pair<X,Y> paar) ... \\ 
	\hspace{0.4cm} $\rightarrow$ keine generische Methode, da Parameter fest \\ 
	\hspace{0.4cm} $\rightarrow$ X oder Y nicht durch abgeleitete Klassen ersetzbar}  & 6/59 \\ \cline{2-4}
	
	& Abkürzung & \makecell[l]{$\bullet$ Pair<String,Integer> pair \\ $\bullet$ pair = new Pair<> ("Hello", 123); \\
	$\rightarrow$ Weglassen der Typparameter bei Initialisierung}  & 6/65 \\ \cline{2-4}
	
	& \makecell[l]{Eingeschränkte \\ Typparameter} & \makecell[l]{$\bullet$ public class A <T extends X> $\rightarrow$ beschränkt auf X oder
	Subtyp \\ $\bullet$ Methoden aus X dann auch in der Klasse A verwendbar \\ 
	$\bullet$ z.B.: <T extends Number> für Zahlen (kein Character) \\
	$\bullet$ mehrfach eingeschränkt: (auch Interfaces) \\ \hspace{0.4cm} $\rightarrow$ <T extends X \& Int1 \& Int2> \\
	\hspace{0.4cm} $\rightarrow$ Klasse muss als Erstes kommen }  & 6/72 \\ \cline{2-4}
	 
	& Wildcards & \makecell[l]{$\bullet$ Einschränkungen auch bei nichtgenerischen Methoden \\ 
	$\bullet$ Aktualer Parameter:  \\
	\hspace{0.2cm} $\bullet$ Upper-Bounded: \\
	\hspace{0.4cm} $\rightarrow$ double m (X<? extends Number> n) ... \\ 
	\hspace{0.4cm} $\rightarrow$ Typ des Parameters n vom Typ Number oder Subtyp \\
	\hspace{0.2cm} $\bullet$ Lower-Bounded: \\
	\hspace{0.4cm} $\rightarrow$ double m (X<? super Double> d) ... \\
	\hspace{0.4cm} $\rightarrow$ Typ des Parameters n vom Typ Double, Basisklasse \\ 
	\hspace{1cm} von Double, allen von Double implementierten Interfaces \\ 
	\hspace{0.4cm} $\rightarrow$ Hier als Beispiel: Nur Double, Number und Object \\
	$\bullet$ Unterschied: \\
	\hspace{0.4cm} $\bullet$ generische Methode: \\ 
	\hspace{0.6cm} $\rightarrow$ public <T extends Number> double m (X<T> n) ... \\ 
	\hspace{0.4cm} $\bullet$ nichtgenerische Methode: \\
	\hspace{0.6cm} $\rightarrow$ public double m (X<? extends Number> n) ... \\
	$\bullet$ nur (X<?> x) $\rightarrow$ allgemeinster Fall (extends Object)\\
	$\bullet$ Verwendung: \\
	\hspace{0.4cm} $\rightarrow$ In-Parameter: extends \\
	\hspace{0.4cm} $\rightarrow$ Out-Parameter: super \\
	\hspace{0.4cm} $\rightarrow$ In/Out-Parameter: weder noch \\
	\hspace{0.4cm} $\rightarrow$ Rückgabe: weder noch} & 6/86 \\ \cline{2-4}
	
	& Comparator & \makecell[l]{$\bullet$ Methode compare mit 2 Typparametern und Rückgabetyp int \\
	\hspace{0.4cm} $\rightarrow$ public int compare (T t1, T t2) ... \\ 
	\hspace{0.4cm} $\Rightarrow$ in Klasse z.B. <T extends Number>\\ 
	$\bullet$ Rückgabewert int: \\
	\hspace{0.4cm} $\rightarrow$ -1, falls erster Parameter dem Zweiten vorangehend \\
	\hspace{0.4cm} $\rightarrow$ +1, falls zweiter Parameter dem Ersten vorangehend \\
	\hspace{0.4cm} $\rightarrow$ 0, falls beide äquivalent \\
	$\bullet$ Funktion: \\ 
	\hspace{0.4cm} $\rightarrow$ Erlaubt den Vergleich von Elementen auf verschiedenste Art\\ 
	$\bullet$ Beispiel mit Referenztypen: 6/120}  & 6/105 \\ \cline{2-4}
	
	& \makecell[l]{Einschränk-\\ungen} & \makecell[l]{$\bullet$ Keine primitiven Datentypen als Instanziierungen \\
	$\bullet$ Keine Erzeugung von Objekten / Arrays von Typparametern \\
	$\bullet$ Keine Klassenattribute von Typparametern \\
	$\bullet$ Kein Downcast oder instanceof mit Typparametern \\
	$\bullet$ Kein throw-catch mit Typparametern \\
	$\bullet$ Keine MethodenÜberladung auf Typparametern }  & 6/140 \\ 
	 
	\hline
	
	
	
	\multicolumn{3}{c}{} \\ 
	\hline 
	
	
	
	{\large \makecell[l]{Graphic\\ Fallbeispiel}} & Applets & \makecell[l]{$\bullet$ grafikorientiertes Programm (hier in HTML) \\ 
	$\bullet$ Syntax: public class myApplet extends Applet \{\} } & 2/11 \\ \cline{2-4}
	
	& Graphics & $\bullet$  & 2/14 \\ \cline{2-4}
	
	& GeomShape2D & $\bullet$  & 2/38 \\ \cline{2-4}
	
	& Beachte & $\bullet$ Folien nachlesen, zu spezifisch & 2 \\ \cline{2-4}
	\hline
	
	
	
	\multicolumn{3}{c}{} \\ 
	\hline 	
	
	
	
	{\large Interfaces} & Syntax & $\bullet$ public interface myInterface \{\} & 1G/68 \\ \cline{2-4}
	
	& Methoden & \makecell[l] {$\bullet$ Rückgabetyp myMethod(); (nicht implementiert, nur definiert) \\ 
	\hspace{0.4cm} $\rightarrow$ dürfen aber auch implementiert werden \\ 
	\hspace{0.4cm} $\rightarrow$ automatisch public \\ $\bullet$ Objektmethoden: default myMethod();} 1G/69 &  \\ \cline{2-4}
	
	& Attribute & $\bullet$ Möglich, allerdings nur als Klassenkonstanten (public final) & 4C/38 \\ \cline{2-4}
	
	& \makecell[l]{ Implement- \\ierung } & $\bullet$ public myClass implements MyInterface1,MyInterface2 \{\} & 1G/72 \\ \cline{2-4}
	
	& Zweck & $\bullet$ Auslagerung von häufigem Code in Interface & 1G/65 \\ \cline{2-4}
	& \makecell[l]{Unterschied \\ Abstrakte \\ Klassen} & \makecell[l]{$\bullet$ Interfaces können Mehrfachvererbung \\ 
	$\bullet$ Abstrakte Klassen können: \\ 
	\hspace{0.4cm} $\bullet$ von Klassen abgeleitet werden \\ 
	\hspace{0.4cm} $\bullet$ Methoden und Attribute, die nicht public sind} & 4C/47 \\ \cline{2-4}
	
	& \makecell[l]{Funktionale \\ Interfaces} & \makecell[l]{$\bullet$ Interfaces mit genau einer funktionalen Methode \\ 
	\hspace{0.4cm} $\rightarrow$ Methode, die weder default oder static ist } & 4C/52 \\
	\hline
	
	
	
	\multicolumn{3}{c}{} \\ 
	\hline 
	
	
	
	{\large Keywords} & Verwendung & $\bullet$ Kann nur an bestimmten Stellen stehen (for, int,while,..) & 1A/147 \\
	\hline
	
	
	
	\multicolumn{3}{c}{} \\ 
	\hline 	
	
	
	
	{\large Klassen} & Kopf & $\bullet$ Modifier class myClass \{\} & 1E/21 \\ \cline{2-4}
	
	& Attribute & $\bullet$ Eigenschaften der Objekte von myClass & 1E/24 \\ \cline{2-4}
	
	& Methoden & $\bullet$ TBD (siehe Methoden) &  \\ \cline{2-4}
	
	& Konstruktor & \makecell[l]{$\bullet$ Einrichtung von neuen Objekten von myClass \\ 
	\hspace{0.4cm} $\rightarrow$ Initialisierung der Attribute\\ 
	$\bullet$ Syntax: Modifier myClass (Parameter) \{\};}& 1E/115 \\ \cline{2-4}
	
	& String & $\bullet$ Aufrufe: (.length, .charAt, .indexOf, .matches) & 3B/75 \\ \cline{2-4}
	
	& Klassenobjekte & \makecell[l]{$\bullet$ Syntax: Modifier static ... \\ 
	$\bullet$ Klassenattribut $\rightarrow$ Zugriff auf immer selbe Speicherstelle \\ 
	$\bullet$ auch über myClass.myStaticVariable ansprechbar} & 3B/169 \\ \cline{2-4}
	
	& java.lang.object & $\bullet$ kein extends $\rightarrow$ Object als Basisklasse & 3B/198 \\ \cline{2-4}
	
	& \makecell[l]{Verborgene \\ Informationen} & \makecell[l]{$\bullet$ anonymes Objekt: \\ 
	\hspace{0.4cm} $\bullet$Informationen zur Verwendung der Klasse \\ 
	\hspace{0.4cm} $\bullet$ Methodentabelle: Erstellung zur Laufzeit (3C/35)}  & 3C/18 \\ \cline{2-4}
	
	& \makecell[l]{Klassen- \\ methoden} & \makecell[l]{$\bullet$ Zugriff auf Klassenmethoden/attribute \\ 
	\hspace{0.4cm} $\rightarrow$ jedoch nicht auf Objektmethoden/attribiute \\ 
	$\bullet$ Implementation vom statischen Typ abhängig (3C/113)} & 3C/52 \\ 
	\hline
	

	
	\multicolumn{3}{c}{} \\ 
	\hline 	
    
    
    
	{\large Kommentare} & Einzeilig & $\bullet$ // & 1A/186 \\ \cline{2-4}
	
	& Bereich & $\bullet$ /* - */ & 1A/187 \\ \cline{2-4}
	
	& Javadoc & \makecell[l]{$\bullet$ /** - */ (nach /** Enter) (3C/90)\\ $\bullet$ Tags @ und neue Zeilen mit * \\
	@param für Parameter \\ @throws für Fehlermeldungen \\ @return Für Rückgabewerte} & 1A/188 \\ 
	\hline
	
	
	
	\multicolumn{3}{c}{} \\ 
	\hline  
	
	
	
	{\large Konventionen} & Identifier & \makecell[l]{$\bullet$ Methoden/Variablen: myMethod/myVariable \\ 
	$\bullet$ Klassen: MyClass \\ 
	$\bullet$ Konstanten: MY\_CONSTANT (\_ statt Leerzeichen)
	\\ $\bullet$ Package: mypackage \\ \hspace{0.4cm} $\rightarrow$ Firmen: umgedrehter Domain Name mit \_\\ 
	$\bullet$ Erstes Zeichen darf keine Ziffer sein, keine Keywords}  & 1A/150 \\ \cline{2-4}
	\hline
	
	
	
	\multicolumn{3}{c}{} \\ 
	\hline   
	
	
	
	{\large Konversionen} & implizite & $\bullet$ Von größerem Datentyp in kleineren $\rightarrow$ ohne Probleme & 1B/211 \\ \cline{2-4}
	
	& explizite & $\bullet$ Zieltyp in Klammern angeben (z.B.: i = (int)myLong) & 1B/214 \\ \cline{2-4}
	\hline
	
	
	
	\multicolumn{3}{c}{} \\ 
	\hline 
	
	
	
	{\large Lambda-Ausdrücke} & Syntax & \makecell[l]{$\bullet$ myFunctionalInterface myVariable = ... -> ... \\ 
	$\bullet$ Einrichten unsichtbarer Klasse, die das Interface implementiert \\ } & 4C/59 \\ \cline{2-4}
	
	& Funktion & \makecell[l]{ $\bullet$ Abgekürzte Schreibweise für den Aufruf einer Hauptmethode \\ 
	\hspace{0.2cm} eines funktionalen Interfaces\\ 
	$\bullet$ Bilden der funktionalen Methode: \\ \hspace{0.4cm} $\rightarrow$ Parameter -> Methode \\ 
	$\bullet$ Allgemeine Form: \\ \hspace{0.4cm} $\rightarrow$ (int n, double d)-> \{return ...\} \\ 
	\hspace{0.4cm} $\rightarrow$ Kurzform nur in einfachen Fällen möglich} & 4C/63 \\ \cline{2-4}
	
	& Closure & \makecell[l]{$\bullet$ Information aus Entstehungskontext mitgespeichert (Variable) \\ 
	$\rightarrow$ Bei Verwendung des Lambda-Ausdrucks mitverwendet } & 4C/67 \\ \cline{2-4}
	
	& Definition & $\bullet$ Literale von Funktionstypen & 4C/70 \\ \cline{2-4}
	
	& \makecell[l]{Fallbeispiel \\ Prädikate} & $\bullet$ Beispiel zur Verdeutlichung  & 4C/71 \\ 
	\hline
	
	
	
	\multicolumn{3}{c}{} \\ 
	\hline 
	
	
    
	{\large Methoden} & Syntax & \makecell[l]{$\bullet$ Modifier Rückgabetyp myMethod (Parameterliste) \{\}; \\ 
 	$\bullet$ Signatur(unique): Name + Parameterliste } & 3C/75 \\ \cline{2-4}  
 	
	& \makecell[l]{Methoden-\\aufruf} & $\bullet$ myObject.myMethod(Parameterliste); & 1A/33 \\ \cline{2-4}
	
	& Rückgabetypen & \makecell[l]{$\bullet$ void $\rightarrow$ Liefert keinen Wert zurück \\ 
	$\bullet$ !void $\rightarrow$ zwingend return ...;}& 1E/32 \\ \cline{2-4}
	
	& Parameter & \makecell[l]{$\bullet$ in Parameterliste: (Datentyp myVariable,..) \\ 
	$\bullet$ mit this.myVariable wird das Attribut angesprochen \\ 
	$\bullet$ formale Parameter: \\ \hspace{0.4cm} $\bullet$ alle Parameter bei der Methodendefinition \\ 
	$\bullet$ aktuale Parameter: \\ 
	\hspace{0,4cm} $\bullet$ alle Parameter beim Methodenaufruf \\ 
	\hspace{0.4cm} $\bullet$ Nicht selber Datentyp benötigt, solange implizit konvertierbar} & 1E/107 \\ \cline{2-4}
	
	& Abstrakt & \makecell[l]{$\bullet$ Syntax: abstract Modifier myMethod() \\ $\bullet$ Erzwingt abstrakte Klasse \\ 
	$\bullet$ 'Rahmen' für andere Klassen} &  \\ \cline{2-4}
	& \makecell[l]{Variable \\ Parameterzahl}& \makecell[l]{$\bullet$ ... myMethod (double... d)\{\} \\ 
	$\bullet$ Entweder Übergabe eines Arrays oder viele double Werte \\ 
	\hspace{0.4cm} $\rightarrow$ Umwandlung in Array vom Typ Double }  & 3C/65 \\ \cline{2-4}
	
	& Überschreiben & \makecell[l]{$\bullet$ Eigenschaften: \\ \hspace{0,4cm} $\bullet$ Signatur zwingend gleich \\ 
	\hspace{0.4cm} $\bullet$ private $\rightarrow$ nichts $\rightarrow$ proctected $\rightarrow$ public 
	\\ \hspace{0.8cm} $\bullet$ Zugriff von Basis zu Subtyp erweitert (möglich) \\ 
	\hspace{0.4cm} $\bullet$ Bei Rückgabe von Referenz $\rightarrow$ durch Subtyp ersetzbar \\ 
	\hspace{0.8cm}$\rightarrow$ auch bei Exceptions} & 3C/95 \\ \cline{2-4}
	
	& Überladen & \makecell[l]{$\bullet$ Selber Name, andere Parameterliste ($\rightarrow$ unterschiedl. Signatur) \\ 
	$\bullet$ Modifier und Rückgabetyp können variieren } & 3C/115 \\ \cline{2-4}
	\hline    
    
    
    
	\multicolumn{3}{c}{} \\ 
	\hline   
	
	
	
	{\large Modifier} & Packages & \makecell[l]{$\bullet$ package myPackage; (oberster Befehl | klein)\\ 
	$\bullet$ import myPackage.*; (* $\rightarrow$ keine Subpackages) \\
	$\bullet$ Namenskonflikte $\rightarrow$ mypackage.myClass ... (Qualifizierung)}& 1F/93 \\ \cline{2-4}
	
	& Zugriff & \makecell[l]{$\bullet$ private: nur in Klasse selbst \\ $\bullet$ nichts: private + package \\ 
	$\bullet$ protected: nichts + Vererbung \\ 
	$\bullet$ public: protected + alle Imports \\
	$\bullet$ Nur eine public myClass oder myEnum pro Quelldatei} & 1F/100 \\ 
	\hline
	
	
	
	\multicolumn{3}{c}{} \\ 
	\hline 
	
	
	
	{\large \makecell[l]{Nested \\ classes}} & Wissenswertes & 
	\makecell[l]{$\bullet$ Verschaltelte Klassen $\rightarrow$ eine Klasse in der anderen eingebettet \\
	$\bullet$ Äußere und innere Klasse \\
	\hspace{0.4cm} $\rightarrow$ public oder package Klasse = Äußere Klasse \\
	\hspace{0.4cm} $\rightarrow$ public, private oder protected = innere Klasse \\
	\hspace{0.4cm} $\rightarrow$ Nur eine Klasse kann public sein! $\rightarrow$ Name der Quelldatei } & 9/2 \\ \cline{2-4}
	
	& Zugriff & \makecell[l]{$\bullet$ OuterClass.InnerClass \\
	\hspace{0.4cm} $\rightarrow$ nur möglich, falls innere Klasse public \\
	$\bullet$ Objekt von Y benötigt ein Objekt von X zum Bezug \\
	\hspace{0.4cm} $\rightarrow$ Attribut der äußeren Klasse vom Typ der inneren Klasse benötigt}   & 9/11 \\ 
	\hline
	
	
	
	\multicolumn{3}{c}{} \\ 
	\hline 
    
    
    
	{\large Objekte} & Erzeugung & $\bullet$ Klasse myClass = new Klasse (Parameterliste); & 1A/147 \\ \cline{2-4}
	\hline
	
	
	
	\multicolumn{3}{c}{} \\ 
	\hline 
	
	
	
	{\large \makecell{Optional}} & Eigenschaften & \makecell[l]{$\bullet$ Hilfsklasse aus dem Package java.lang \\
	 $\bullet$ Erzeugtes Objekt kapselt ein Objekt seines Typparameters ein \\ 
	 $\bullet$ bequeme Möglichkeit um mit Referenz null umzugehen} & 8/3 \\ \cline{2-4}
	
	& Methoden & \makecell[l]{$\bullet$ $\bullet$ Erzeugung: \\ 
	\hspace{0.4cm} $\rightarrow$ Optional<Number> opt1 = Optional.OfNullable(new Integer(123)); \\
	\hspace{0.4cm} $\rightarrow$ Optional<Number> opt1 = Optional.OfNullable(null); ("leer") \\
	$\bullet$ Abruf: \\ \hspace{0.4cm} $\rightarrow$ OptionalObject.get(); \\
	\hspace{0.4cm} $\rightarrow$ Bei null: NoSuchElementException \\
	$\bullet$ orElseGet: \\ \hspace{0.4cm} $\rightarrow$ Wenn Object leer, Zurücklieferung eines anderes Wertes \\
	\hspace{0.4cm} $\rightarrow$ opt1.orElseGet( () -> 0); $\rightarrow$ Gibt 0 zurück, falls Object == null \\
	$\bullet$ isPresent: \\ \hspace{0.4cm} $\rightarrow$ Wenn Object nicht null, Ausführung des Lambdas \\
	$\bullet$ map: \\ \hspace{0.4cm} $\rightarrow$ Optional<Number> opt3 = opt1.map(x -> x * x); \\
	\hspace{0.4cm} $\rightarrow$ opt3 verweist auf Optional-Object, das ein Number-Objekt \\ 
	\hspace{1cm} einkapselt mit dem Quadrat von opt1 \\
	\hspace{0.4cm} $\rightarrow$ Falls Object null auch Container null \\
	$\bullet$ filter: \\ \hspace{0.4cm} $\rightarrow$ Liefert Optional-Object vom selben generischen Typ zurück \\
	\hspace{0.4cm} $\rightarrow$ Wenn Lambda-Ausdruck true, dann speicher des Verweises \\
	\hspace{0.4cm} $\rightarrow$ Wenn Lambda-Ausdruck false, dann speicher von null \\
	\hspace{0.4cm} $\rightarrow$ Optional<Number> opt4 = opt3.filter(x -> x\%2 == 1);  }  & 8/4 \\ \cline{2-4}
	\hline
	


	\multicolumn{3}{c}{} \\ 
	\hline 	
	
	
	
	{\large \makecell[l]{Primitive \\Datentypen}} & Ganzzahlig & \makecell[l]{$\bullet$ byte: 8 Bits \\ 
	$\bullet$ short: 16 Bits \\ $\bullet$ int: 32 Bits \\ $\bullet$ long: 64 Bits \\  
	$\bullet$ Integer.MAX\_VALUE / Integer.MIN\_VALUE etc. }  & 1B/120 \\ \cline{2-4}
	
	& Gebrochen & \makecell[l]{$\bullet$ float: 32 Bits \\ $\bullet$ double: 64 Bits (Genauigkeit 500 Millionen mal höher) \\ 
	$\bullet$ Vergleich von gebrochenen Zahlen mit maximalen Fehler \\ 
	$\bullet$ Double.MAX\_VALUE / Double.POSITIVE\_INFINITY}  & 1B/134 \\ \cline{2-4}
	
	& Literale & \makecell[l]{$\bullet$ wörtlich hingeschriebene Werte, automatisch int \\ 
	\hspace{0.4cm} $\bullet$ Typ long: 123L \\ \hspace{0.4cm} $\bullet$ Typ byte / short: automatisch falls klein genug \\
	$\bullet$ gebroche Literale automatisch double \\ \hspace{0.4cm} $\bullet$ Typ float: 12.34F \\ 
	\hspace{0.4cm} $\bullet$ Exponenten 1.2E34 (1,2 * $10^{34}$) } &  1B/125 \\ \cline{2-4}
	
	& Logiktyp & \makecell[l]{$\bullet$ boolean: binär (true oder false $\rightarrow$ booleschen Literale) \\ 
	$\bullet$ Operationen: $\bullet$ Negation: !a \\ \hspace{2.5cm} $\bullet$ Und: a\&\&b \\
	\hspace{2.5cm} $\bullet$ Oder: a||b} & 1B/153  \\ \cline{2-4}
	
	& Zeichen & \makecell[l]{$\bullet$ char: Schriftzeichen in Einzelhochkommas ('a') \\ 
	\hspace{0.4cm} $\bullet$ Unicode: Kodierung als Zahl mit 16 Bit \\ 
	\hspace{0.7cm} $\rightarrow$ ASCII: Zeichen 0-127 | ISO-Latin-1: Zeichen 127-255 \\ 
	\hspace{0,4cm} $\bullet$ Unicode-Nummer auch hexadezimal '\textbackslash u....'}&  \\ \cline{2-4}
	
	& Overflow & \makecell[l]{$\bullet$ Falls Wert zu groß für Datentyp \\ 
	$\bullet$ Keine Fehlermeldung, Informationsverlust!} & 1B/129 \\ \cline{2-4}
	
	& Nullwert & \makecell[l]{$\bullet$ Falls nicht initialisiert, nur definiert: \\ 
	\hspace{0.4cm} $\bullet$ Zahlentypen: 0 \\ \hspace{0.4cm} $\bullet$ boolean: false \\
	\hspace{0.4cm} $\bullet$ Referenzen: null  } & 3C/154 \\
	\hline	
	
	\multicolumn{3}{c}{} \\ 
	\hline
	
	
	
	{\large \makecell[l]{Programm- \\ablauf}} & Programm & 
	$\bullet$ Sequenz von Informationen (Quelltext und Java-Bytecode) & 1A/61 \\ \cline{2-4}
	
	& Prozesse & \makecell[l]{$\bullet$ Werden nacheinander von CPU abgearbeitet (Warteschlange) \\
	$\bullet$ $\rightarrow$ Illusion von Multitasking} & 1A/61 \\ \cline{2-4}
	
	& Anweisung & $\bullet$ kleinste Einheit / der Reihe nach ausgeführt & 1A/72 \\
	\hline
	 
	 
	 
	\multicolumn{3}{c}{} \\ 
	\hline
	 
	 
	 
	{\large Referenztypen} & Definition & $\bullet$ !(Primitive Datentypen) & 3B/2 \\ \cline{2-4}
	
	& Aufzählung & $\bullet$ Klassen, Arrays, Interfaces, Enum & 3B/3 \\ \cline{2-4}
	
	& Enum & $\bullet$ Begründung: Sind auch Klassen, deswegen Referenzen & 3B/14 \\ \cline{2-4}
	
	& Gleichheit & \makecell[l]{$\bullet$ Test auf Gleichheit problematisch, da Referenzen \\ 
	\hspace{0.4cm} $\rightarrow$ Objektidentität vs. Wertgleichheit \\ 
	\hspace{0.4cm} $\rightarrow$ deep vs shallow copy} & 3B/49 \\ \cline{2-4}
	
	& \makecell[l]{statisch vs \\ dynamisch} & \makecell[l]{$\bullet$ Syntax: static myClass = new dynamic(); \\ 
	$\bullet$ statisch: \\ \hspace{0.2cm} $\bullet$ unveränderlich mit Referenz verknüpft (darüber definiert) \\ 
	\hspace{0.2cm} $\bullet$ entscheidet auf welche Methoden zugegriffen werden darf\\ 
	$\bullet$ dynamisch: Typ des Objekts der Referenz \\ 
	\hspace{0.2cm} $\bullet$ muss gleich oder Subtyp des statischen Typs sein \\ 
	\hspace{0.2cm} $\bullet$ entscheidet welche Implementation der Methode}& 3B/152 \\ 
	\hline
	
	
	
	\multicolumn{3}{c}{} \\ 
	\hline 	 
	 
	 
	 
	{\large Schleifen} & for-Schleife & \makecell[l]{$\bullet$ for (Ausführung davor; Bedingung; Ausführung danach) \{\}; 
	\\ $\bullet$ Beispiel: for(int i = 0; i < x; i++ \{\};\\ $\bullet$ bei Einzelner Anweisung auch ohne \{\}
	\\ $\bullet$ auch for(;;) möglich $\rightarrow$ 	 Endlosschleife }& 1A/130 \\ \cline{2-4}
	
	& while-Schleife & \makecell[l] {$\bullet$ while (Bedingung) \{\}; (kopfgesteuert) \\
	$\bullet$ do \{\} while(Bedingung); (fußgesteuert) \\ $\bullet$ bei Einzelner Anweisung auch ohne \{\}} & 1A/123 \\ \cline{2-4}
	
	& break; & \makecell[l]{ $\bullet$ Verlassen der nächsthöheren (inneren) Schleife \\ 
	$\bullet$ Fortfahren mit nächster Anweisung nach Schleife} & 1B/50\\ \cline{2-4}
	
	& continue; & \makecell[l]{$\bullet$ Beendet momentanen Schleifendurchlauf \\ $\bullet$ Als Nächstes wieder Prüfen der Bedingung}  & 1B/51\\ 
	\hline
	
	
	
	\multicolumn{3}{c}{} \\ 
	\hline 	
	
	
	
	{\large Scope} & Definition & $\bullet$ Gültigkeitsbereich von Identifiern & 3A/47 \\ \cline{2-4}
	
	& Modifier & $\bullet$ Klassen, Methoden, Variablen etc. $\rightarrow$ siehe oben & 3A/49 \\ \cline{2-4}
	
	& lokale Variablen & $\bullet$ Innerhalb von Methodenrümpfen, Schleifen, etc. & 3A/52 \\ \cline{2-4}
	
	& this & $\bullet$ Bei gleichen Namen von lokalen Variablen und Attribute $\rightarrow$ this & 3A/56 \\ 
	\hline
	
	
	
	\multicolumn{3}{c}{} \\ 
	\hline 
		
		
	
	{\large Semikolon} & Verwendung & $\bullet$ Semikolon nach jeder abgeschlossenen Anweisung (;) & 1A/22 \\ \hline
	 
	 
	 
	\multicolumn{3}{c}{} \\ 
	\hline
	
	
	
	{\large \makecell{Speicher- \\ modell}} & Abstraktion & \makecell[l]{$\bullet$ großes Feld von Maschinenwörtern (Länge immer gleich, \\
	\hspace{0.2cm}aber abhängig von der Hardware (32bit / 64bit)} & 1A/24 \\ \cline{2-4}
	
	& \makecell[l]{Speicher- \\nutzung} & \makecell[l]{$\bullet$ Name eines Objekts/Arrays wird als Referenz \\ 
	\hspace{0.35cm}auf Speicherort abgelegt \\ 
	$\bullet$ $\rightarrow$ deswegen Operator "new"} & 1A/28 \\ \cline{2-4}
	
	& \makecell[l]{Primitive \\ Datentypen} & $\bullet$ Name verweist tatsächlich auf konkrete Speicherstelle & 1A/139 \\ \cline{2-4}
	
	& Program Counter & $\bullet$ enthält Adresse der nächst auszuführenden Anweisung & 1A/143 \\ \cline{2-4}
	
	& \makecell[l]{Methoden- \\ aufruf} & $\bullet$ Einrichten des Stackpointers | Callstack | Frame & 1E/51 \\ \cline{2-4}
	
	& \makecell[l]{Referenzen vs \\ Objekte} & $\bullet$ Unterschiede im Speicher, siehe Folien & 3B/20 \\ \cline{2-4}
	
	& \makecell[l]{Garbage \\Collector } & $\bullet$ Teil des Laufzeitsystems, löscht unreferenzierte Objekte & 3B/210 \\ 
	\hline
	
	
	
	\multicolumn{3}{c}{} \\ 
	\hline 		
	
	
	
	{\large Streams} & Eigenschaften & \makecell[l]{$\bullet$ Klasse Optional fürs Verständnis relevant! (weiter oben) \\
	$\bullet$ generisches Interface im Package java.util.stream \\ 
 	$\bullet$ einheitliche Schnittstelle für Listen, Arrays, Dateien,... \\
 	$\bullet$ von potentiell unendlicher Länge}  & 8/19 \\ \cline{2-4}
 	
	& \makecell[l]{Stream aus \\ Listen} & \makecell[l]{$\bullet$ Stream<Number> stream1 = list.stream(); \\
	$\bullet$ Stream<Number> stream2 = stream1.filter( myPredicate ); \\
	\hspace{0.4cm} $\rightarrow$ Neuer Stream mit gefilteren Objekten abh. vom Prädikat \\
	$\bullet$ Stream<Number> stream3 = stream1.map( myFunction );  \\ 
	\hspace{0.4cm} $\rightarrow$ Neuer Stream mit angepassten Objekten abh. von der Funktion \\
	$\bullet$ Optional<Number> opt = stream3.max( new Comparator()); \\ 
	\hspace{0.4cm} $\rightarrow$ Gibt abhängig vom übergebenen Comparator ein Element zurück \\
	\hspace{0.4cm} $\rightarrow$ Da der Stream auch leer sein kann, Objekt vom Typ Optional \\
	$\bullet$ Funktioniert genauso mit Arrays \\ 
	\hspace{0.4cm} allerdings Parameter bei Arrays.stream mit Arraytyp}  & 8/21 \\ \cline{2-4}
	
	& Erzeugung & \makecell[l]{$\bullet$ Stream<Number> stream1 = Stream<Number>.of \\
	\hspace{3cm} (new Integer(1), new Integer(2)); }  & 8/41 \\ \cline{2-4}
	
	& Iteration & \makecell[l]{$\bullet$ Iteration iter = stream.iterator(); \\
	$\bullet$ while (iter.hasNext()) \{ Number n = iter.next(); ..code..\} }  & 8/48 \\ \cline{2-4}
	
	& \makecell[l]{ Liste aus \\ Stream} & \makecell[l]{$\bullet$ List<String> list = stream.collect(Collectors.toList()); \\
	$\rightarrow$ Collectors.toList() liefert generisches Interface Collector zurück \\ 
	$\bullet$ Number[] a = stream.toArray(Number[]::new); \\
	$\rightarrow$ Methodennamen als Lambda-Ausdrücke (Number[]::new): \\
	\hspace{0.4cm} $\bullet$ Fachbegriff method reference \\
	\hspace{0.4cm} $\bullet$ Folien 8/55 - 8/83 lesen | Dokumentation  }  & 8/49 \\ \cline{2-4}
	
	& \makecell[l]{Streams und \\ Dateien} & 
	\makecell[l]{$\bullet$ Erstellen eines Pfades: Path path = Paths.get(..,..,..); \\
	\hspace{0.4cm} $\rightarrow$ Path und Paths in der Package java.nio.file \\
	\hspace{0.4cm} $\rightarrow$ Paths.get() erzeugt einen Pfad anhand der Parameter \\
	$\bullet$ Stream<String> stream = Files.lines(path); \\
	\hspace{0.4cm} $\rightarrow$ Öffnet die Datei und gibt sie als Stream von String zurück \\
	\hspace{0.4cm} $\rightarrow$ Bei Fehlern IOException aus java.io (importieren) \\
	$\bullet$ String fileContentAsString = stream.reduce(String::concat); \\
	\hspace{0.4cm} $\rightarrow$ Erstellt aus allen Elementen des Streams einen einzelnen String}  & 8/95 \\ \cline{2-4}
	
	& IntStreams & \makecell[l]{$\bullet$ Auch LongStream und DoubleStream \\
	$\bullet$ Handhabung analog zu normalen Streams \\
	$\bullet$ IntStream stream1 = IntStream.of(1,2,3); }  & 8/102 \\ \cline{2-4}
	
	& \makecell[l]{Random \\ Zahlen} & \makecell[l]{$\bullet$ Klasse Random in java.util \\
	$\bullet$ Random random = new Random(); (Erzeugung eines Objekts) \\
	$\bullet$ random.nextDouble; (oder nextInt,..) \\
	$\bullet$ Bei Double/Float zwischen 0.0 und 0.1 \\
	$\bullet$ Bei Int/Long im Wertebereich \\
	$\bullet$ Bei Streams: IntStream stream1 = new Random().ints(); \\
	\hspace{0.4cm} $\rightarrow$ Füllt Stream mit int stream}  & 8/107 \\ 
	\hline
	
	
	
	\multicolumn{3}{c}{} \\ 
	\hline 
	
	
	
	{\large \makecell[l]{ System \\ Properties }} & Eigenschaften & \makecell[l]{$\bullet$ java.lang.System \\
	$\bullet$ Attribute der Umgebung, in der das Java-Programm läuft \\
	$\bullet$ Werden als String gespeichert, kriegen String übergeben} & 8/84 \\ \cline{2-4}
	
	& Methode & \makecell[l]{$\bullet$ String homeDirectory = System.getProperty (''user.home''); \\
	$\bullet$ Liefert String zurück, übernimmt String als Parameter}  & 8/86  \\ \cline{2-4}
	
	& \makecell[l]{Mögliche \\ Strings} & \makecell[l]{$\bullet$ ''user.home'': Name des Heimatverzeichnisses \\
	$\bullet$ ''user.dir'': Arbeitsverzeichnis des Prozesses \\
	$\bullet$ ''user.name'': Name des Nutzers \\
	$\bullet$ ''file.seperator'': Zeichen zur Trennung von Pfadnamen \\
	$\bullet$ ''line.seperator'': Zeichen zur Trennung von Zeilen }  & 8/87 \\
	\hline
	
	
	
	\multicolumn{3}{c}{} \\ 
	\hline 
	
	
	
	{\large Textdateien} & Wissenswertes & \makecell[l]{$\bullet$ Textdatei besteht aus Zeichen (chars) \\
	$\bullet$ jeder Char ist zwei Byte groß \\
	$\bullet$ Suche nach bequemeren Zugriff für Textdateien (nicht byteweise) } & 8/170 \\ \cline{2-4}
	
	& Reader & \makecell[l]{$\bullet$ Klasse zum Einlesen von Textdateien \\
	$\bullet$ viele reader.read Methoden, Bsp. reader.read(char[] c); \\
	\hspace{0.4cm} $\rightarrow$ Liest soviele Zeichen ein bis Array voll oder Datenquelle erschöpft\\
	\hspace{0.4cm} $\rightarrow$ Gibt Anzahl der eingelesenen Chars aus \\
	$\bullet$ BufferedReader: reader.readLine();\\
	\hspace{0.4cm} $\rightarrow$ Richtet StringObjekt ein und liest ganze Zeile ein  \\
	$\bullet$ Byteweises Einlesen in Zeichenweises Einlesen: \\
	\hspace{0.4cm} $\rightarrow$ InputStream in = ...; \\
	\hspace{0.4cm} $\rightarrow$ Reader reader = new InputStreamReader(in);}  & 8/172 \\ \cline{2-4}
	
	& Writer & \makecell[l]{$\bullet$ Klasse zum Schreiben von Textdateien \\
	$\bullet$ writer.write(char); (schreibt einzelnen Char) \\
	$\bullet$ writer.write(String); (schreibt ganzen String) \\
	$\bullet$ Umwandlung von Byteweise in Zeichenweise analog zu Reader \\
	\hspace{0.4cm} $\rightarrow$ OutputStreamReader }  & 8/181 \\ 
	\hline
	
	
	
	\multicolumn{3}{c}{} \\ 
	\hline 
	
	
	
	{\large Threads } & Wissenswertes & \makecell[l]{$\bullet$ Verweis auf Kapitel Nested Classes weiter oben \\
	$\bullet$ Organisation von parallel laufenden Prozessen \\
	$\bullet$ Beschleunigung eines Vorgangs aufgrund der Aufteilung in mehrere Prozesse \\
	$\bullet$ Aber nicht immer unbedingt schneller, Wissen notwendig\\
	$\bullet$ Starten und Vergessen ("fire and forget")} & 9/21 \\ \cline{2-4}
	
	& \makecell[l]{Implement- \\ ierung} & \makecell[l]{$\bullet$ Inhalt eines Threads: \\
	\hspace{0.4cm} $\rightarrow$ Klasse, die das Interface Runnable implementiert\\
	\hspace{0.4cm} $\rightarrow$ Funktionale Methode public void run() \{...\} \\
	$\bullet$ Einrichtung der Runnable Klasse (9/29-44) \\
	$\bullet$ new Thread(runnable).start(); \\
	\hspace{0.4cm} $\rightarrow$ Kein späterer Zugriff mehr nötig, Thread läuft ab sofort \\
	\hspace{0.4cm} $\rightarrow$ Programmausführung besteht nun aus zwei Threads\\
	\hspace{0.4cm} $\rightarrow$ Hier: Main Methode und gestarteter Thread  }  & 9/23 \\ \cline{2-4}
	
	& Methoden & \makecell[l]{$\bullet$ static currentThread \\
	\hspace{0.4cm} $\rightarrow$ Keine Parameter, liefert ThreadObjekt zurück \\
	\hspace{0.4cm} $\rightarrow$ Repräsentiert Thread, in dem die Methode aufgerufen wurde \\
	$\bullet$ dumpStack \\
	\hspace{0.4cm} $\rightarrow$ Schreiben des Call-Stacks auf System.err \\
	$\bullet$ getAllStackTraces \\
	\hspace{0.4cm} $\rightarrow$ Liefert Call-Stacks von allen aktiven Threads im Programm \\
	\hspace{0.4cm} $\rightarrow$ Rückgabe als Map mit Threads als Keys \\
	$\bullet$ getId \\
	\hspace{0.4cm} $\rightarrow$ Gibt ID vom Typ long zurück, bleibt gleich solange Thread aktiv \\
	$\bullet$ getName \\
	\hspace{0.4cm} $\rightarrow$ Gibt Namen zurück \\
	$\bullet$ getPriority / setPriority \\
	\hspace{0.4cm} $\rightarrow$ Prioritätswert vom Typ int
	 $\bullet$ static sleep \\
	 \hspace{0.4cm} $\rightarrow$  Setzt Pause in Millisekunden }  & 9/51 \\ \cline{2-4}
	
	& Streams & \makecell[l]{$\bullet$ Verknüpfung von Output in Input \\
	\hspace{0.4cm} $\rightarrow$ Pipe = Verbindung zwischen Lesen und Schreiben \\
	\hspace{0.4cm} $\rightarrow$ PipedOutputStream out = new PipedOutputStream(); \\
	\hspace{0.4cm} $\rightarrow$ PipedInputStream in = new PipedInputStream(out); \\
	\hspace{0.4cm} $\rightarrow$ Runnable runnable = new WriteRunner(out); \\
	\hspace{0.4cm} $\rightarrow$ new Thread(runnable).start(); \\
	\hspace{0.4cm} $\rightarrow$ Neuer Thread, der Output ausgibt, der in 2. Stream erzeugt wird \\
	\hspace{0.4cm} $\rightarrow$ Hier müsste WriteRunner implements Runnable noch erstellt werden}  & 9/60 \\ \cline{2-4}
	
	& \makecell[l]{Interferierende \\ Threads} & \makecell[l]{$\bullet$ Mehrere Threads Zugriff auf selbe Ressource \\
	\hspace{0.4cm} $\rightarrow$ Reihenfolge unklar \\
	\hspace{0.4cm} $\rightarrow$ z.B. printen beide auf Standard Output (System.out)
	\hspace{0.4cm} $\rightarrow$ Vermischung komplett zufällig }  & 9/79 \\ \cline{2-4}
	
	& Parallelisierung & \makecell[l]{$\bullet$ Aufspaltung von Prozessen zur Lautzeitoptimierung \\
	$\bullet$ Beispiel auf Folien nachzulesen \\
	\hspace{0.4cm} $\rightarrow$ Beispiel aber schlecht auf andere Situationen übertragbar \\
	$\bullet$ (Functional Interfaces, Runnable-Klasse,..) \\
	$\bullet$ Abfragen der Prozessorenanzahl: \\
	\hspace{0.4cm} $\rightarrow$ Runtime.getRunTime().avaiableProcessors(); }  & 9/82 \\ \cline{2-4}
	
	& Terminierung & \makecell[l]{$\bullet$ Hier Verwendung eines booleans toBeTerminated \\
	$\bullet$ Falls true, Beenden der While-Schleife in run() \\
	\hspace{0.4cm} $\rightarrow$ Führt zur Beendigung des Threads \\
	$\bullet$ Überprüfung allerdings nur an gewissen Stellen, nicht überall }  & 9/126 \\  \cline{2-4}
	
	& \makecell[l]{Parallele \\ Streams} & \makecell[l]{ $\bullet$ Threads schon in Streams eingebaut \\
	$\bullet$ stream.parallelStream().otherStuff()...\\
	\hspace{0.4cm} Verteilt Arbeit an Stream selbstständig auf mehrere Threads } & 9/151 \\
	\hline
	
	
	
	\multicolumn{3}{c}{} \\ 
	\hline 	
	
	
	
	{\large Vererbung} & Syntax & $\bullet$ mySubClass extends myClass & 1F/3 \\ \cline{2-4}
	
	& Allgemein & \makecell[l]{$\bullet$ mySubClass erbt alle Funktionalitäten von myClass } & 1F/12 \\ \cline{2-4}
	
	& Konstruktor & \makecell[l]{$\bullet$ Aufruf des Konstruktors von myClass mit super(...); \\ 
	\hspace{0.4cm} $\rightarrow$ muss die erste Anweisung im Konstruktor sein \\ 
	$\bullet$ Default Constructor, falls nicht definiert \\ $\bullet$ Konstuktoren werden nicht vererbt} & 1F/26 \\ \cline{2-4}
	
	& Overwrite & \makecell[l]{$\bullet$ Neue Methoden Implementierung in mySubClass \\ 
	\hspace{0.4cm} $\rightarrow$ Nützlich: super.myMethod(); \\ 
	\hspace{0.4cm} $\rightarrow$ Letzte Implementation wird vererbt } & 1F/45 \\ \cline{2-4}
	
	& Overload & \makecell[l]{$\bullet$ Methode: Selber Name $\rightarrow$ unterschiedliche Parameterliste \\ 
	$\bullet$ auch bei Konstruktoren möglich \\ 
	\hspace{0.4cm} $\rightarrow$ Aufruf in anderem Konstruktor in selber Klasse mit this()} & 1E/70 \\ \cline{2-4}
	
	& Subtypen & \makecell[l]{$\bullet$ alles per "extends" abgeleitete \\ $\bullet$ "extends" | "implements" + Subklassen \\ 
	$\bullet$ Arrays deren Komponententyp ein Subtyp ist \\ 
	$\bullet$ Referenztyp (Supertyp $\longleftrightarrow$ Subtyp)} & 3B/135 \\ \cline{2-4}
	
	& \makecell[l]{Static \\ Initializer} & \makecell[l]{$\bullet$ Syntax: static \{\} \\ 
	$\bullet$ Initialisierung von Klassenkonstaten falls sonst nicht möglich \\ 
	\hspace{0.4cm} $\bullet$ z.B.: Beim Setzen vom Prozessstartdatum} & 3C/138 \\
	\hline
	
	
	
	\multicolumn{3}{c}{} \\ 
	\hline 
	
	
	
	{\large } & & \makecell[l]{$\bullet$  } &  \\ \cline{2-4}
	
	&  & \makecell[l]{$\bullet$  }  &  \\ \cline{2-4}
	
	&  & \makecell[l]{$\bullet$  }  &  \\ \cline{2-4}
	
	&  & \makecell[l]{$\bullet$  }  &  \\ \cline{2-4}
	
	&  & \makecell[l]{$\bullet$  }  &  \\ \cline{2-4}
	
	&  & \makecell[l]{$\bullet$  }  &  \\ \cline{2-4}
	
	&  & \makecell[l]{$\bullet$  }  &  \\ 
	\hline
	
	
	
	\multicolumn{3}{c}{} \\ 

	
	 
	 
\end{longtable}
\end{center}

\end{document}c