\input{../reference_sheet_preamble}


\begin{titlepage}
  \title{Rechnerorganisation} % document_name-type_of_document
  \author{Jonas Milkovits}
  \date{Last Edited: \today}
\end{titlepage}

\begin{document}

\pagenumbering{gobble}
\maketitle
\pagenumbering{roman} % i, ii, iii on beginning pages, that don't have content
\tableofcontents
\clearpage
\pagenumbering{arabic} % 1,2,3 on content pages

\section{Einführung}

\subsection{Begrifflichkeiten und Grundlagen}
    \begin{itemize}
        \item \textbf{Abstraktion}
            \begin{itemize}
                \item Wichtiges und zentrales Konzept der Informatik
                \item Verstecken unnötiger Details (für spezielle Aufgabe unnötig)
            \end{itemize}
        
        \item \textbf{Schichtenmodell}
        \item[]
            \begin{minipage}{0.3\textwidth}
            \includegraphics[width=5cm]{schichtenmodell.PNG}
            \end{minipage}
            \begin{minipage}[t]{0.6\textwidth}
            \vspace{-3cm}
                \begin{itemize}
                    \item Untere Schicht erbringt Dienstleistungen für höhere Schicht
                    \item Obere Schicht nutzt Dienste der niedrigeren Schicht
                    \item Eindeutige Schnittstellen zwischen den Schichten
                    \item Vorteile:
                        \begin{itemize}
                            \item Austauschbarkeit einzelner Schichten
                            \item Nur Kenntnis der bearbeitenden Schicht notwendig
                        \end{itemize}
                    \item Nachteile:
                        \begin{itemize}
                            \item ggf. geringere Leistungsfähigkeit des Systems
                        \end{itemize}
                \end{itemize}
            \end{minipage}
        
        \item \textbf{Grundbegriffe}
            \begin{itemize}
                \item Computer:
                    \begin{itemize}
                        \item Datenverarbeitungssystem
                        \item Funktionseinheit zur Verarbeitung und Aufbewahrung von Daten
                        \item Auch Rechner, Informationsverarbeitungssystem, Rechnersystem,..
                        \item Steuerung eines Rechnersystems folgt über ladbares Programm (Maschinenbefehle)
                    \end{itemize}
                \item Grundfunktionen, die ein Rechner ausführt
                    \begin{itemize}
                        \item Verarbeitung von Daten (Rechnen, logische Verknüpfungen,..)
                        \item Speichern von Daten (Ablegen, Wiederauffinden, Löschen)
                        \item Umformen von Daten (Sortieren, Packen, Entpacken)
                        \item Kommunizieren (Mit Benutzer, mit anderen Rechnersystemen)
                    \end{itemize}
            \end{itemize}

        \item \textbf{Komponenten eines Rechnersystems}
            \begin{itemize}
                \item Prozessor
                    \begin{itemize}
                        \item Zentraleinheit, Central Processing Unit (CPU)
                        \item Ausführung von Programmen
                    \end{itemize}
                \item Speicher
                    \begin{itemize}
                        \item Enthält Programme und Daten (Speichersystem)
                    \end{itemize}
                \item Kommunikation
                    \begin{itemize}
                        \item Transfer von Informationen zwischen Speicher und Prozessor
                        \item Kommunikation mit der Außenwelt (Ein-/Ausgabesystem)
                    \end{itemize}
                \item[] \includegraphics[width=8cm]{rechnersystem.PNG}
            \end{itemize}

        \item \textbf{Nähere Informationen zum Speicher} 
            \begin{itemize}
                \item Explizite Nutzung des Speichersystem
                    \begin{itemize}
                        \item Internet Prozessorspeicher/Register
                            \begin{itemize}
                                \item schnelle Register zur temporären Speicherung von Daten/Befehlen
                                \item direkter Zugriff durch Maschinenbefehle
                                \item Technologie: Halbleiter ICs
                            \end{itemize}
                        
                        \item Hauptspeicher
                            \begin{itemize}
                                \item relativ großer und schneller Speicher für Programme/Daten 
                                \item direkter Zugriff durch Maschinenbefehle 
                                \item Technologie: Halbleiter ICs
                            \end{itemize}

                        \item Sekundärspeicher
                            \begin{itemize}
                                \item großer, aber langsamer Speicher für permanente Speicherung
                                \item indirekter Zugriff über E/A-Programme (Daten $\rightarrow$ Hauptspeicher)
                                \item Technologie: Halbleiter ICs, Magnetplatten, optische Laufwerke
                                \item z.B.: Festplatte
                            \end{itemize}
                    \end{itemize}

                \item Implizite (transparente) Nutzung 
                    \begin{itemize}
                        \item Für das Maschinenprogramm transparent
                        \item bestimmte Register auf dem Prozessor 
                        \item Cache-Speicher
                    \end{itemize}
                
                \item[] \includegraphics[width=12cm]{speicherhierarchie}
                
                \item Speicherorganisation: Big-Endian und Little-Endian 
                \item[]
                    \begin{minipage}{0.2\textwidth}
                    \includegraphics[width=4cm]{bigLittleEndian.PNG}
                    \end{minipage}
                    \begin{minipage}[t]{0.7\textwidth}
                    \vspace{-1.2cm}
                        \begin{itemize}
                            \item Schemata für Nummerierung von Bytes in einem Wort
                            \item Big-Endian: Bytes werden vom höchstwertigen Ende gezählt
                            \item Little-Endian: Bytes werden vom niederstwertigen Ende gezählt
                        \end{itemize}
                    \end{minipage}
            \end{itemize}
            
    \end{itemize}

\subsection{Streifzug durch die Geschichte}

    \begin{itemize}
        \item \textbf{Übersicht über die geschichtliche Entwicklung mit wichtigsten Meilensteinen}
        \begin{itemize}
            \item[] \includegraphics[width=12cm]{geschichtsTabelle1.PNG}
        \end{itemize}
        
        \item \textbf{Fünf Rechnergenerationen im Überblick:}
            \begin{itemize}
                \item[] \includegraphics[width=12cm]{rechnergenerationen} 
            \end{itemize}
        
        \item \textbf{Rechner im elektronischen Zeitalter}
            \begin{itemize}
                \item 1954: Entwicklung der Programmiersprache Fortran
                \item 1955: Erster Transistorrechner
                \item 1957: Entwicklung Magnetplattenspeicher, Erste Betriebssysteme für Großrechner
                \item 1968: Erster Taschenrechner
                \item 1971: Erster Mikroprozessor
                \item 1981: Erster IBM PC, Beginn des PC-Zeitalters
            \end{itemize}
    \end{itemize}

\subsection{Ethik in der Informatik}

    \begin{itemize}
        \item Ethik in der Informatik
            \begin{itemize}
                \item Ethik: Bewertung menschlichen Handelns
                \item Verbindung zur Informatik: Anwendung von Rechnern für kriegisches Handelns
                \item \textbf{Dual-Use-Problematik}: Verwendbarkeit von Rechnern für zivile als auch militärische Zwecke
            \end{itemize}
        
        \item Digitale Souveränität
            \begin{itemize}
                \item Souveränität: Fähigkeit zur Selbstbestimmung (Eigenständigkeit, Unabhängigkeit)
                \item Digitale Souveränität: Souveränität im digitalen Raum
            \end{itemize}
    \end{itemize}

\section{Einführung in die maschinennahe Programmierung}

\subsection{Begrifflichkeiten und Grundlagen}
    \begin{itemize}
        \item \textbf{Allgemein}
            \begin{itemize}
                \item Architektur / Programmiermodell
                    \begin{itemize}
                        \item Programmierersicht auf Rechnersystem 
                        \item Definiert durch Maschinenbefehle und Operanden
                    \end{itemize}
                \item Mikroarchitektur
                    \begin{itemize}
                        \item Hardware-Implementierung der Architektur
                    \end{itemize}
            \end{itemize}
        
        \item \textbf{Programmierparadigmen}
            \begin{itemize}
                \item Synonyme: Denkmuster, Musterbeispiel
                \item Bezeichnet in der Informatik ein übergeordnetes Prinzip
                \item Dieses Prinzip ist für eine ganze Teildisziplin typisch
                \item Manifestiert sich an Beispielen, keine konkrete Formulierung
                \item Maschinensprache (Assembler) ist ein primitives Paradigma              
            \end{itemize}

        \item \textbf{Programmiermodell}
            \begin{itemize}
                \item Bei höheren Programmiersprachen:
                    \begin{itemize}
                        \item Grundlegende Eigenschaften einer Programmiersprache 
                    \end{itemize} 
                \item Bei maschinennaher Programmierung:
                    \begin{itemize}
                        \item Bezeichnet dort den \textbf{Registersatz} eines Prozessors 
                        \item Registersatz besteht aus:
                            \begin{itemize}
                                \item Register, die durch Programme angesprochen werden können
                                \item Liste aller verfügbaren Befehle (\textbf{Befehlssatz})
                            \end{itemize}
                        \item Register, die prozessorintern verwendet werden (IP/PC) zählen nicht zum Registersatz
                            \begin{itemize}
                                \item IC: Instruction Pointer 
                                \item PC: Program Counter
                            \end{itemize}
                    \end{itemize}
            \end{itemize}

        \item \textbf{Verfeinerung des Rechensystems}
            \begin{itemize}
                \item[] \includegraphics[width=9cm]{modernesRechnersystem.PNG}
                \item {\makebox[6cm][l]{CPU/Prozessor:}} führt die im Hauptspeicher abgelegten Befehle aus 
                \item {\makebox[6cm][l]{ALU/Arithmethic Logical Unit:}} Ausführung der Operationen
                \item {\makebox[6cm][l]{PC/Program Counter:}} Verweis auf nächsten Maschinenbefehl im Hauptspeicher
                \item {\makebox[6cm][l]{Register:}} Schneller Speicher für Operanden
                \item {\makebox[6cm][l]{Hauptspeicher:}} Speichert Befehle und Daten 
                \item {\makebox[6cm][l]{Bus Interface:}} Verbinden der einzelnen Komponenten
            \end{itemize}

        \item \textbf{Assembler}
            \begin{itemize}
                \item Programmieren in der Sprache des Computers
                    \begin{itemize}
                        \item {\makebox[3cm][l]{Maschinenbefehle:}} Einzelnes Wort
                        \item {\makebox[3cm][l]{Befehlssatz:}} Gesamtes Vokabular
                    \end{itemize}
                \item Befehle geben Art der Operation und ihre Operanden an 
                \item Zwei Darstellungen:
                    \begin{itemize}
                        \item Assemblersprache: Für Menschen lesbare Schreibweise für Instruktionen
                        \item Maschinensprache: maschinenlesbares Format (1 und 0)
                    \end{itemize}
            \end{itemize}
        
        \item \textbf{ARM-Architektur - Hier verwendetes Rechnersystem}
            \begin{itemize}
                \item z.B. verwendet bei Raspberry Pi 
                \item ARM: Acorn RISC Machines / Advanced RISC Machines 
                \item Große Verbreitung heutzutage in Smartphones
            \end{itemize}

    \end{itemize}

\pagebreak

\subsection{Phasen der Übersetzung}

        \begin{itemize}
            \item Beispielhaftes \texttt{C}-Programm:
            \item[]
                \begin{minted}[autogobble]{c}
                #include<stdio.h> /* Standard Input/Output */ /* Header-Datei*/
                int main() {
                printf("Hello World\n");
                return 0;
                }
                \end{minted}
            \item \texttt{C}-Programm an sich für den Menschen verständlich
            \item Übersetzung in Maschinenbefehle für Ausführung auf dem Rechnersystem:
            \item[] \includegraphics[width=12cm]{übersetzungsPhasen.PNG}
            \item 1. Phase \textbf{(Preprocessor)}
                \begin{itemize}
                    \item Aufbereitung durch Ausführung von Direktiven (Code mit \#)
                    \item z.B.: Bearbeiten von \texttt{\#include <stdio.h>}
                        \begin{itemize}
                            \item Lesen des Inhalts der Datei \texttt{stdio.h}
                            \item Kopieren des Inhalts in die Programmdatei
                        \end{itemize}
                    \item Ausgabe: \texttt{C}-Programm mit der Endung \texttt{.i} 
                \end{itemize}
            
            \item 2. Phase \textbf{(Compiler)}
                \begin{itemize}
                    \item Übersetzt \texttt{C-}Programm \texttt{hello.i} in Assemblerprogramm \texttt{hello.s}
                \end{itemize}
            \item 3. Phase \textbf{(Assembler)}
                \begin{itemize}
                    \item Übersetzt \texttt{hello.s} in Maschinensprache
                    \item Ergebnis ist das Objekt-Programm \texttt{hello.o}
                \end{itemize}
            \item 4. Phase \textbf{(Linker)}
                \begin{itemize}
                    \item Zusammenfügen verschiedener Module
                        \begin{itemize}
                            \item Code von \texttt{printf} exisitert bereits als \texttt{print.o}-Datei
                        \end{itemize}
                    \item Linker kombiniert \texttt{hello.o} und \texttt{printf.o} zu ausführbarem Programm
                    \item Ausgabe des Bindevorgangs: ausführbare \texttt{hello}-Objektdatei
                \end{itemize}
        
        \end{itemize}

\pagebreak

\subsection{Ausführung eines Programms im Rechnersystem}
        
        \begin{itemize}
            \item Ausgangspunkt
                \begin{itemize}
                    \item Ausführbares Objektprogramm \texttt{hello} auf der Festplatte 
                    \item Starten der Ausführung des Programms unter Nutzung der Shell 
                \end{itemize}
            
            \item Ablauf:
                \begin{itemize}
                    \item Shell liegt Zeichen des Kommandos ins Register
                    \item Speichert den Inhalt dann im Hauptspeicher aber
                    \item[] \includegraphics[width=9cm]{ausführung1.PNG}
                    \item Schrittweises Kopieren der Befehle/Daten von Festplatte in Hauptspeicher
                    \item[] \includegraphics[width=9cm]{ausführung2.PNG}
                    \item Ausführen der Maschinenbefehle des \texttt{hello}-Programms
                    \item[] \includegraphics[width=9cm]{ausführung3.PNG} 
                \end{itemize}
        \end{itemize}

\pagebreak

\subsection{Befehle eines Rechnersystems}
    \begin{itemize}
        \item Wieviele Befehle und was für Befehle soll ein Rechnersystem haben?
        \item Viele komplexe Befehle: 
            \begin{itemize}
                \item \textbf{CISC-Maschinen} (Complex Instruction Set Computer)
                \item Befehlsausführung direkt im Speicher möglich
                \item Verwendet von Intel-Architektur 
            \end{itemize}
        \item Weitgehend identische Ausführungszeit der Befehle
            \begin{itemize}
                \item \textbf{RISC-Maschinen} (Reduce Instruction Set Computer)
                \item Ermöglicht effizientes Pipeling
                \item Werden auch als Load/Store-Architekturen bezeichnet (Nur Ausführung im Register)
                \item Verwendet von ARM-Architektur
            \end{itemize}
        \item Jedoch viele Befehle, die jeder Prozessor hat (AND, OR, NOT,..)
        \item Unterschiedliche Befehlsformate:
            \begin{itemize}
                \item Erlauben Flexibilität
                \item z.B. \texttt{add} und \texttt{sub} mit drei Registern als Operanden
                \item z.B. \texttt{ldr} und \texttt{str} verwenden zwei Register und Konstante
                \item Anzahl an Formaten sollte jedoch klein sein 
                    \begin{itemize}
                        \item Hardware weniger aufwendig
                        \item Erlaubt evtl. höhere Verarbeitungsgeschwindigkeit
                    \end{itemize}
            \end{itemize}
        \item Interner Aufbau eines Rechners hat viele Freiheitsgrade
        \item Diese Struktur hat erheblichen Einfluss auf die Leistungsfähigkeit eines Rechnersystems 
        \item \textbf{$n$-Adressmaschinen}
            \begin{itemize}
                \item Einteilung nach der Anzahl der Operanden in einem Maschinenbefehl 
                \item 2-Adressmaschine (Intel Architektur)
                \item 3-Adressmaschine (ARM Architektur)
            \end{itemize}
        \item \textbf{Konstanten in Befehlen (intermediates)}
            \begin{itemize}
                \item Direkt im Befehl untergebebracht $\rightarrow$ Direktwerte
                \item Benötigen kein eigenes Register oder Speicherzugriff
                \item Direktwert ist Zweierkomplementzahl, die 12 Bit breit ist 
                \item Bitbreite der Direktwertzahl vom Befehl abhängig
                    \begin{itemize}
                        \item Befehle haben immer 32 Bit
                        \item Registeradressen werden mit 4 Bit kodiert
                        \item Übrigbleibende Bits für Direktwert
                    \end{itemize}
            \end{itemize}
    \end{itemize}

\subsection{Registersatz}
    \begin{itemize}
        \item[]
            \begin{minipage}{0.2\textwidth}
            \includegraphics[width=3cm]{registersatz.PNG}
            \end{minipage}
            \begin{minipage}[t]{0.7\textwidth}
            \vspace{-3cm}
                \begin{itemize}
                    \item R0: Verwendet für Rückgabe von Werten an die \texttt{Shell}
                    \item R1-R12: General Purpose Register
                    \item R13: Stack Pointer (sp)
                    \item R14: Link Register (lr)
                    \item R15: Program Counter (pc)
                    \item Current Processor Status Register (CPSR)
                \end{itemize}
            \end{minipage}
        \item \textbf{Current Processor Status Register}
            \begin{itemize}
                \item Enthält unter anderem die \texttt{Statusflags}
                \item[] \includegraphics[width=15cm]{statusflags}
                \item Werden oft für Vergleiche (\texttt{b,beq,...}) verwendet 
                \item \texttt{N} (Negative): Wird verwendet um zu zeigen, dass Ergebnis negativ ist
                \item \texttt{Z} (Zero): Wird verwendet um zu zeigen, dass Ergebnis 0 ist 
                \item \texttt{C} (Carry): Zeigt, dass Carry-Bit besteht 
                \item \texttt{V} (OverFlow): Zeigt, dass Overflow geschehen ist 
                \item Namen können je nach Prozessor stark variieren
            \end{itemize}
    \end{itemize}

\subsection{Adressierung des Speichers, Lesen und Schreiben auf Speicher}
    \begin{itemize}
        \item \textbf{Allgemeine Verwendung von Registerspeicher}
            \begin{itemize}
                \item Meist zuviele Daten für die Register 
                \item Kombination des Registers und Hauptspeichers zum Halten von Daten 
                \item Speichern von häufig verwendeten Daten in Registern (Schleifenvariable)
            \end{itemize}
        
        \item \textbf{Wort- und Byte-Adressierung von Daten im Speicher }
            \begin{itemize}
                \item Byte-adressiert: (ARM)
                    \begin{itemize}
                        \item Jedes Byte hat eine eindeutige Adresse (Zugriff auf jedes Byte möglich)
                        \item Ein Wort (hier 32Bit) besteht aus 4 Bytes (32 Bits)
                        \item Wortbreite ist von der Architektur abhängig
                        \item Wortadressen sind immer Vielfache von 4 (Offset von 4)
                        \item[]
                        \item[] \includegraphics[width=12cm]{wortAdresse.PNG}
                        \item Rechts wird ein Byte mit zwei Hexawerten dargestellt ($AB:~1011~1010$)
                    \end{itemize}
            \end{itemize}
        
        \item \textbf{Lesen aus byte-adressiertem Speicher}
            \begin{itemize}
                \item Lesen geschieht durch Ladebefehle (Transportbefehl)
                \item Befehlsname: \texttt{load word (ldr)}
                \item Alternative für Bytes statt Wörtern: \texttt{ldrb}
                \item Adressarithmethik: 
                \begin{itemize}
                    \item Adressen werden relativ zu Register angegeben
                    \item Basisadresse (startet bei Wort 9) plus Distanz (offset)
                    \item Adresse = \texttt{(r5 (Basis) + 8 (offset))}
                \end{itemize}
                \item Beispiel 1:
                    \begin{itemize}
                        \item Lese Datenwort von Speicheradresse \texttt{(r5+8)} und schreibe es in Register \texttt{r7}
                        \item[]
                            \begin{minted}[autogobble]{c}
                            mov r5,#0 /* Transportbefehl, schreibt Konstante 0 in r5 */
                            ldr r7, [r5,#8] /* r7: Zielregister | [r5,#8] Quelle */
                            \end{minted}
                        \item \texttt{r7} enthält das Datenwort der Speicheradresse \texttt{r5+8}
                    \end{itemize}
                \item Beispiel 2:
                    \begin{itemize}
                        \item Lesen Datenwort 3 (Speicheradresse \texttt{0xC} (12er Offset)) nach \texttt{r7}
                        \item (Einschub: \texttt{0x} sagt dem Compiler, dass das Folgende eine Hexzahl ist)
                        \item[]
                            \begin{minted}[autogobble]{c}
                            mov r5,#0 /* Schreibt Konstante 0 in r5 */
                            ldr r7, [r5, #0xC] /* Lädt den Wert (r5+12) in r7 */
                            \end{minted}
                        \item Nach Abarbeiten des Befehls hat \texttt{r7} den Wert \texttt{0x40F30788}
                        \item[]
                        \item[] \includegraphics[width=8cm]{byteAdresseBsp2}
                    \end{itemize}
            \end{itemize}

        \item \textbf{Schreiben in byte-adressierten Speicher}
            \begin{itemize}
                \item Schreiben geschieht durch Speicherbefehle (Transportbefehl)
                \item Befehlsname: \texttt{store word (str)}
                \item Alternative für Bytes statt Wörtern: \texttt{strb}
                \item Beispiel:
                    \begin{itemize}
                        \item Schreibe den Wert aus \texttt{r9} in Speicherwort 5
                        \item[]
                            \begin{minted}[autogobble]{c}
                            mov r1,#0 /* Speichert Konstante 0 in r1 */
                            mov r9,#42 /* Speichert Konstante 42 in r9 */
                            str r9, [r1,#0x14] /* Schreibt Wert des 5. Wortes von r1 in r9 */
                            \end{minted}
                        \item \texttt{\#0x14}: $14_{16} = 0001~0100_2 = 20_{10}$ (5.tes Wort)
                    \end{itemize}
            \end{itemize}
    \end{itemize}
        
\subsection{Kontrollstrukturen in Assembler}
    \begin{itemize}
        \item \textbf{Statusbits}
            \begin{itemize}
                \item Die Wichtigsten:
                    \begin{itemize}
                        \item \texttt{CF (CarryFlag)}
                        \item \texttt{ZF (ZeroFlag)}
                        \item \texttt{SF (SignFlag)}
                        \item \texttt{OF (OverflowFlag)}
                    \end{itemize}
                \item Verwendung:
                    \begin{itemize}
                        \item Vergleiche (\texttt{cmp})
                        \item Gleichheit
                    \end{itemize}
                \item Unterschiede zwischen \texttt{Carry} und \texttt{Overflow}
                    \begin{itemize}
                        \item \texttt{Overflow}: Ergebnis passt nicht in maximale darstellbare Werte (z.B. +8 bei 4 Bit im ZK)
                        \item \texttt{Carry}: Ergebnis passt nicht in Bitbreite ( +5 - 1 = +4)
                        \item \texttt{Sign}: Vorzeichen negativ
                    \end{itemize}
            \end{itemize}
        
        \item \textbf{Sprünge / Verzweigungen}
            \begin{itemize}
                \item Änderung der Ausführungsreihenfolge von Befehlen 
                \item Unbedingte Sprünge
                    \begin{itemize}
                        \item Werden immer ausgeführt
                        \item \mint{c}|b target /* Springt von branch zu target */| 
                    \end{itemize}
                \item Bedingte Sprünge
                    \begin{itemize}
                        \item Sprünge abhängig von Bedingung 
                        \item \mint{c}|beq target /* Ein Beispiel, eq für equal */| 
                    \end{itemize}
                \item Label 
                    \begin{itemize}
                        \item Label sind Namen für Adressen im Programm 
                        \item Name muss unterschiedlich von Maschinenbefehlen (Mnemonics) sein 
                        \item Label müssen mit einem Doppelpunkt abgeschlossen werden
                        \item Werden zur Markierung von Stellen für Sprünge verwendet (target)
                    \end{itemize}
            \end{itemize}
        
        \item \textbf{Bedingte Sprünge}
            \begin{itemize}
                \item[]
                    \begin{minted}[autogobble]{c}
                    mov r0,#4       /* r0 = 4 */
                    add r1,r0,r0    /* r1 = 8 */ 
                    cmp r0, r1      /* r0 - r1 = -4: NZCV = 1000 */
                                    /* StatusBits NZCV */
                    beq there       /* Kein Sprung: Z != 1 */
                                    /* Müsste bei Gleichheit (equal) 0 sein */
                    add r1,r1,#42   /* r1 = r1 + 42 */

                    there:
                    add r1,r1,#78   /* r1 = r1 + 78 */
                    \end{minted}
                \item Weitere Bedingungen: 
                    \begin{itemize}
                        \item \texttt{beq}: Equal / Gleichheit 
                        \item \texttt{bne}: Not Equal / Ungleichheit
                        \item \texttt{bge}: Greater / Größer
                        \item \texttt{ble}: Less / Kleiner
                    \end{itemize}
            \end{itemize}
        
        \item \textbf{if-Anweisung}
            \begin{itemize}
                \item[]
                    \begin{minted}[autogobble]{c}
                    /* r0 = 5; r1 = 10; r2 = f; r3 = i */
                    cmp r0,r1       /* Vergleicht r0 und r1 */ 
                    bne L1          /* Falls Werte ungleich sind, ist hier gegeben */
                    add r2,r3,#1    /* Wird hier übersprungen */
                    L1:             /* Hierhin wird gesprungen */
                    sub r2,r2,r3 
                    \end{minted}
            \end{itemize}

        \item \textbf{if/else-Anweisung}
            \begin{itemize}
                \item[]
                    \begin{minted}[autogobble]{c}
                    /* r0 = 5; r1 = 10; r2 = f; r3 = i */
                    cmp r0,r1 
                    bne L1          /* Potentieller Sprung nach L1 */
                    add r2,r3,#1    /* else-Anweisung (wird übersprungen, falls Bedingung korrekt) */
                    b L2            /* Überspringen der if-Anweisung, sonst wird beides ausgeführt */
                    L1:
                    sub r2,r2,r3 
                    L2:
                    ...
                    \end{minted}
            \end{itemize}

        \item \textbf{while-Schleifen}
            \begin{itemize}
                \item[]
                    \begin{minted}[autogobble]{c}
                    /* r0 = pow; r1 = x */
                    mov r0,#1
                    mov r1,#0
                    WHILE:          /* Label für Schleife*/
                    cmp r0,#128     /* Abbruchbedingung: Falls equal Z = 1 */
                    beq DONE        /* Sprung aus Schleife */   
                    lsl r0,r0,#1    /* Linksshift um 1 Bit / Schleifencode */
                    add r1,r1,#1    /* x = x + 1 / Schleifencode */
                    b WHILE         /* Fortführen der Schleife */
                    DONE:
                    ...
                    \end{minted}
            \end{itemize}

        \item \textbf{for-Schleifen}
            \begin{itemize}
                \item[]
                    \begin{minted}[autogobble]{c}
                    /* r0 = i; r1 = sum */
                    mov r1,#0
                    mov r0,#0
                    FOR:            /* Label für Schleife */
                    cmp r0,#10      /* Abbruchbedingung: Falls i größer als 10 ist */
                    bge DONE 
                    add r1,r1,r0    /* sum = sum + i */
                    add r0,r0,#1    /* i = i + 1 */
                    b FOR           /* Fortführen der Schleife */
                    DONE:
                    ...
                    \end{minted}
            \end{itemize}
    \end{itemize}

\subsection{Nutzung des Hauptspeichers}
    \begin{itemize}
        \item \textbf{Erklärung anhand eines Codebeispiels}
            \begin{itemize}
                \item[] \includegraphics[width=15cm]{codeBeispielHauptspeicher1}
                \item \texttt{.data (Zeile 4)}: 
                    \begin{itemize}
                        \item Variablen, die im Speicher (nicht im Register) abgelegt werden
                        \item \texttt{.word}: Festlegung des Typs (hier 32 Bit)
                        \item Name \texttt{var1}: An sicht frei wählbar
                    \end{itemize}

                \item \texttt{.global main (Zeile 8)}:
                    \begin{itemize}
                        \item Definiert das Label, das als Einsprungspunkt gilt (hier \texttt{main})
                    \end{itemize}

                \item \texttt{adr\_var1: .word var1 (Zeile 18/19)}:
                    \begin{itemize}
                        \item Hier werden die Adressen der Variablen im Speicher in einer Variable abgespeichert
                        \item Wichtig: Unterscheidung zwischen Adresse und Wert
                    \end{itemize}

                \item \texttt{ldr r0, adr\_var1 (Zeile 11)}:
                    \begin{itemize}
                        \item Lädt nun die Adresse unseres Hauptspeicherwertes in ein Register
                        \item Hierfür nutzen wir die eben erstellte \texttt{adr\_var1}
                    \end{itemize}

                \item \texttt{ldr r2,[r0] (Zeile 13)}:
                    \begin{itemize}
                        \item Lädt den Inhalt der Adresse in \texttt{r0} in \texttt{r2}
                        \item Verwendung von \texttt{[]} um dies anzuzeigen
                    \end{itemize}

                \item Variationen:
                    \begin{itemize}
                        \item Zeile 13: \texttt{ldr r2,[r0,\#4]}
                            \begin{itemize}
                                \item Hinzufügen eines Offsets beim Laden des Wertes 
                                \item Dies führt dazu, dass der Wert auf \texttt{r1} geladen wird (12)
                                \item Ausgabe des Programms ist damit 24, statt 17
                            \end{itemize}
                        \item \texttt{mov r5,\#4} | \texttt{ldr r2,[r0,r5]}
                            \begin{itemize}
                                \item In Registern gespeicherte Konstanten auch als Offset möglich
                            \end{itemize}
                    \end{itemize}

                \item Zusätzliche Visualisierung:
                    \begin{itemize}
                        \item[] \includegraphics[width=12cm]{speicherBild.PNG}
                    \end{itemize}
            \end{itemize}
    \end{itemize}

\subsection{Datenfelder (Arrays)}
    \begin{itemize}
        \item \textbf{Eigenschaften}
            \begin{itemize}
                \item Datenfelder bestehen aus mehreren Worten 
                \item Nützlich um auf eine große Zahl von Daten gleichen Typs zuzugreifen
                \item Zugriff auf einzelne Elemente über Index
                \item[] \includegraphics[width=12cm]{datenfeld1.PNG}
            \end{itemize} 

        \item \textbf{Verwendung von Arrays}
            \begin{itemize}
                \item[]
                    \begin{minipage}{0.35\textwidth}
                        \includegraphics[width=6cm]{arraybsp.PNG}
                    \end{minipage}
                    \begin{minipage}{0.55\textwidth}
                        \begin{itemize}
                            \item Array mit 5 Elementen
                            \item Basisadresse: Adresse des ersten Elements (0x1234800)
                            \item Erster Schritt für Zugriff: Lade Basisadresse des Arrays in Register
                        \end{itemize}
                    \end{minipage}
                \item Beispiel:
                \item[]
                    \begin{minted}[autogobble]{c}
                    /* Umsetzung des folgenden C-Codes in Assembler */
                    int i;
                    int scores[200];
                    for (i = 0; i < 200; i = i + 1)
                        scores[i] = scores[i] + 10;
                    \end{minted}
                \item[]
                    \begin{minted}[autogobble]{c}
                    mov r0,#0x14000000  /* Speichern der Basisadresse des Arrays in r0 */
                    mov r1,#0           /* Verwendung als Zählervariable i */
                    LOOP:               
                    cmp r1,#200         /* i < 200 */
                    bge L3              /* Falls i > 200, Verlassen des Loops */
                    lsl r2,r1,#2        /* r2 = i * 4 -> Aufgrund des Offsets des Arrays von 4 */
                    ldr r3,[r0,r2]      /* Laden des Wertes aus Array / r3 = scores[i] */
                    add r3,r3,#10       /* r3 = scores[i] + 10 */
                    str r3,[r0,r2]      /* Zurückschreiben in Speicher / r3 Quellregister (nicht Ziel) */
                                        /* scores[i] = scores[i] + 10 */
                    add r1,r1,#1        /* i = i + 1 / Hochzählen der Laufvariable */
                    b LOOP              /* Wiederholen der Schleife */
                    L3:
                    ...
                    \end{minted}
            \end{itemize}
    \end{itemize}


\subsection{Unterprogramme}
    \begin{itemize}
        \item \textbf{Einführung}
            \begin{itemize}
                \item Unterprogramme helfen bei der strukturierten Programmierung
                \item Betrachtung Hauptprogramm, in dem ein Teilprogramm an versch. Stellen ausgeführt werden soll
                \item Zwei Konzepte: Makrotechnik und Unterprogrammtechnik
            \end{itemize}

        \item \textbf{Makrotechnik}
            \begin{itemize}
                \item[]
                    \begin{minipage}{0.25\textwidth}
                        \includegraphics[width=5cm]{makrotechnik.PNG}
                    \end{minipage}
                    \begin{minipage}{0.65\textwidth}
                        \begin{itemize}
                            \item Teilprogramm wird, an benötigten Stellen, einkopiert
                            \item Zuordnung eines Namens für Teilprogramm (Makroname)
                            \item Nennung des Makronamens an besagter Stelle (Makroaufruf)
                        \end{itemize}
                    \end{minipage}
            \end{itemize}

        \item \textbf{Unterprogrammtechnik}
            \begin{itemize}
                \item[]
                    \begin{minipage}{0.25\textwidth}
                        \includegraphics[width=5cm]{unterprogramm.PNG}
                    \end{minipage}
                    \begin{minipage}{0.65\textwidth}
                        \begin{itemize}
                            \item Teilprogramm nur einmal im Code vorhanden
                            \item Kennzeichnung durch Marke (Unterprogrammname)
                            \item Aufruf: Sprungbefehl + Marke 
                            \item Rückkehr in aufrufendes Programm nach Ausführung
                            \item[] $\Rightarrow$ durch Sprungbefehl auf Rückkehradresse
                            \item Rückkehradresse wird an anderer Stelle gespeichert
                            \item Beachten der Sichtbarkeit von Variablen (global vs lokal)
                        \end{itemize}
                    \end{minipage}
            \end{itemize}

        \item \textbf{Funktions- und Prozeduraufruf}
            \begin{itemize}
                \item Aufrufer:
                    \begin{itemize}
                        \item Ursprung des Funktionsaufrufs
                        \item Übergibt Argumente (aktuale Parameter) an Aufgerufenen
                        \item Springt Aufgerufenen an
                    \end{itemize}

                \item Aufgerufener:
                    \begin{itemize}
                        \item Aufgerufene Funktion
                        \item Führt Funktion/Prozedur aus
                        \item Gibt Rückgabewert an Aufrufer zurück 
                        \item Darf keine Register oder Speicherstellen überschreiben, die im Aufrufer genutzt werden
                            \begin{itemize}
                                \item Beachten mit Sorgfalt und vorhandenem Konzept
                                \item Genutzte Register sollten gesichert werden, um danach wieder zu überschreiben
                            \end{itemize}
                    \end{itemize}
                
                \item Beispiel:
                    \begin{itemize}
                        \item[]
                            \begin{minted}[autogobble]{c}
                            /* Übersetzen des folgenden C-Codes in Assembler */
                            int main() {
                                int y;
                                y = diffofsums(14, 3, 4, 5); 
                            }

                            int diffofsums(int f, int g, int h, int i){ /* 4 formale Parameter */
                                int result;
                                result = (f + g) - (h + i);
                                return result;
                            }
                            \end{minted}
                        \item[]
                        \item[]
                            \begin{minted}[autogobble]{c}
                            /* ASSEMBLER */
                            /* r4 = y */
                            main:
                            mov r0,#14      /* Argument 0 = 14 */
                            mov r1,#3       /* Argument 1 = 3 */
                            mov r2,#4       /* Argument 2 = 4 */
                            mov r3,#5       /* Argument 3 = 5 */
                            bl diffofsums   /* Funktionsaufruf / bl: branch and link */
                            /* Schreibt die Rückkehradresse des folgenden Befehls mov in link register (r14) */
                            mov r4,r0       /* y = Rückgabewert */
                            -------------
                            diffofsums:
                            add r8,r0,r1    /* Überschreiben von r8 / Kein Sichern der Werte vorher */
                            add r9,r2,r3    /* Selbiges gilt für r9 */
                            sub r4,r8,r9
                            mov r0,r4       /* Ablegen von Rückgabewert in r0 (return value register) */
                            mov pc,lr       /* Übergabe der Rückkehradresse an Program Counter */
                            /* Program Counter führt dann den nächsten Befehl (mov r4,r0) aus */
                            \end{minted}
                    \end{itemize}
            \end{itemize}
    \end{itemize}
        

\end{document}