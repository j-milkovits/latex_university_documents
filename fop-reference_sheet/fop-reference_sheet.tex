\input{../reference_sheet_preamble}


\renewcommand{\arraystretch}{1.75} 

\lstset {
	literate={~} {$\sim$}{1},
    language=Java,
    basicstyle=\footnotesize,
    numbers=left,
    stepnumber=1,
    showstringspaces=false,
    tabsize=1,
    breaklines=true,
    breakatwhitespace=false,
    inputencoding=utf8,
    extendedchars=true   
}

\begin{titlepage}
  \title{FOP Reference Sheet} % document_name-type_of_document
  \author{Jonas Milkovits}
  \date{Last Edited: \today}
\end{titlepage}

\begin{document}

\pagenumbering{gobble}
\maketitle
\pagenumbering{roman} % i, ii, iii on beginning pages, that don't have content
\tableofcontents
\clearpage
\pagenumbering{arabic} % 1,2,3 on content pages

\begin{comment}
	\begin{tabular}{ | p{4cm} p{13.5cm} | }
	\hline
	
	
	\end{tabular}
\end{comment}


\section{Stuff that I skipped cuz of chapter 4}

\begin{tabular}{ | p{4cm} p{13.5cm} | }
	\hline
	\makecell[l]{Exceptions aus \\ Lambda-Ausdrücken} &
	\makecell[l]{$\rhd$ Kapitel 5: 47 - 50  } \\ \hline
	
	\makecell[l]{Listen von \\ Lambda-Ausdrücken} & \makecell[l]{$\rhd$ Kapitel 7: 60 - 65 } \\ \hline
	
	\makecell[l]{Methodennamen als \\ Lambda-Ausdrücke} & \makecell[l]{$\rhd$ Kapitel 8: 55 - 84  } \\ \hline

	\makecell[l]{Streams in Racket} & \makecell[l]{$\rhd$ Kapitel 8: 122 - 133  } \\ \hline

	\end{tabular}


\section{Collections}
	\begin{longtable}{ | p{4cm} p{13.5cm} | }
	\hline
	
	\makecell[l]{Informationen } & \makecell[l]{$\rhd$ Sammlungen von Elementen (Objekte eines generischen Typs) \\
	$\rhd$ Struktur: \\
	\hspace{0.4cm} $\diamond$ Alle Klassen und Interfaces in \texttt{java.util} \\
	\hspace{0.4cm} $\diamond$ Interface \texttt{Collection}: Alle Klassen implementieren dieses Interface \\
	\hspace{0.4cm} $\diamond$ Klasse \texttt{Collections}: Basisalgorithmen, Sortieren \\
	\hspace{0.4cm} $\diamond$ Interface \texttt{List}: Erweitert \texttt{Collection}, mehr Funktionalitäten \\
	\hspace{0.4cm} $\diamond$ Klasse \texttt{Iterator}: Iteration über die Elemente einer \texttt{Collection} \\
	$\rhd$ Beispiele für Klasse, die das Interface \texttt{Collection} implementieren: \\
	\hspace{0.4cm} $\diamond$ \texttt{Vector, LinkedList, ArrayList, TreeSet, HashSet} } \\ \hline
	
	\makecell[l]{Interface \texttt{Collection}} & \makecell[l]{$\rhd$ z.B.: \texttt{Collection<Number> c1 = new ArrayList<Number>();} \\
	\hspace{0.4cm} $\diamond$ Speichert leere \texttt{ArrayList} in einer Referenz des Interface \texttt{Collection} \\
	\hspace{0.4cm} $\diamond$ Dies ist möglich, da \texttt{ArrayList} das Interface \texttt{Collection} implementiert \\
	$\rhd$ Methoden: \\
	\hspace{0.4cm} $\diamond$ \texttt{add}  \\
	\hspace{0.6cm} - Fügt zur ArrayList ein neues Element hinzu \\
	\hspace{0.6cm} - Gibt \texttt{true} zurück, falls Hinzufügen erfolgreich \\
	\hspace{0.4cm} $\diamond$ \texttt{addAll} \\
	\hspace{0.6cm} - Hat eine \texttt{Collection} als Parameter und fügt diese hinzu \\
	\hspace{0.4cm} $\diamond$ \texttt{size} \\
	\hspace{0.6cm} - Anzahl der Elemente als int \\
	\hspace{0.4cm} $\diamond$ \texttt{isEmpty} \\
	\hspace{0.6cm} - \texttt{true}, falls \texttt{Collection} keine Elemente enthält (\texttt{size == 0}) \\ 
	\hspace{0.4cm} $\diamond$ \texttt{contains} \\
	\hspace{0.6cm} - Parameter vom Typ \texttt{Object} \\
	\hspace{0.6cm} - Überprüft, ob aktualer Parameter in \texttt{Collection} vorhanden ist \\
	\hspace{0.6cm} - Nutzt \texttt{equals} von \texttt{Object} $\rightarrow$ Wertgleichheit \\
	\hspace{0.4cm} $\diamond$ \texttt{containsAll} \\
	\hspace{0.6cm} - \texttt{true}, falls ganze übergebene \texttt{Collection} enthalten ist \\
	\hspace{0.4cm} $\diamond$ \texttt{clear} \\
	\hspace{0.6cm} - Entfernt alle Elemente aus der \texttt{Collection} \\
	\hspace{0.4cm} $\diamond$ \texttt{remove} \\
	\hspace{0.6cm} - Entfernt übergebenes \texttt{Object} \\
	\hspace{0.6cm} - \texttt{true}, falls \texttt{Object} mindestens einmal vorhanden \\
	\hspace{0.6cm} - Bei mehreren, entscheidet die \texttt{Collection}-Klasse welches entfernt wird } \\ \hline

	\makecell[l]{Interface \texttt{List}} & \makecell[l]{$\rhd$ Erweitert das Interface \texttt{Collection} \\
	$\rhd$ Unterschied: Definition einer Reihenfolge auf den Elementen \\
	$\rhd$ Methoden: \\
	\hspace{0.4cm} $\diamond$ \texttt{indexOf} \\
	\hspace{0.6cm} - Liefert ersten Index zurück, an dem \texttt{Object} zu finden ist \\
	\hspace{0.6cm} - Liefert -1 zurück, falls Parameter nicht in Liste gefunden wird \\
	\hspace{0.4cm} $\diamond$ \texttt{set} \\
	\hspace{0.6cm} - \texttt{T set(int index, T element) ...} \\
	\hspace{0.6cm} - Ersetzt Element an Stelle \texttt{index} durch \texttt{element} \\
	\hspace{0.6cm} - Gibt ersetztes Element zurück \\
	\hspace{0.4cm} $\diamond$ \texttt{add} \\
	\hspace{0.6cm} - Identisch zu Methode \texttt{set}, jedoch ein Unterschied: \\
	\hspace{0.6cm} - Überschreibt das Element \textbf{nicht}, sondern fügt es vor dem Element ein } \\ \hline

	\makecell[l]{Sortieren mit Comparator} & \makecell[l]{$\rhd$ Klasse \texttt{Collections} hat Klassenmethode \texttt{sort} \\
	$\rhd$ \texttt{Collections.sort(list, new MyComparator());} \\
	\hspace{0.4cm} $\diamond$ Erster Parameter: Zu sortierende Liste (z.B.: \texttt{List<Student> list = ...}) \\
	\hspace{0.4cm} $\diamond$ Zweiter Parameter: Selbst erstellte Sortierlogik \\
	\hspace{0.4cm} $\diamond$ Typparameter von \texttt{Comparator} und \texttt{List} müssen gleich sein } \\ \hline

	\makecell[l]{Interface \texttt{Iterator}} & \makecell[l]{$\rhd$ \texttt{Collection} und \texttt{List} erben von Interface \texttt{Iterable} \\
	$\rhd$ Jede Klasse, die \texttt{Collection} implementiert hat eine eigene \texttt{Iterator}-Klasse \\
	$\rhd$ Diese eigene \texttt{Iterator}-Klasse implementiert das Interface \texttt{Iterator} \\
	$\rhd$ \texttt{Collection<Number> c1 = new ArrayList<Number>();} \\
	$\rhd$ \texttt{Iterator<Number> it1 = c1.iterator();} \\
	\hspace{0.4cm} $\diamond$ \texttt{Collection} besitzt die Methode \texttt{iterator()} \\
	\hspace{0.4cm} $\diamond$ Liefert ein Objekt ihrer eigenen \texttt{Iterator}-Klasse zurück \\
	$\rhd$ Methoden: \\
	\hspace{0.4cm} $\diamond$ \texttt{next()} \\
	\hspace{0.6cm} - Liefert ein noch nicht geliefertes Element der \texttt{Collection} \\
	\hspace{0.6cm} - Reihenfolge von Interface abhängig (\texttt{Collection} oder \texttt{List}) \\
	\hspace{0.4cm} $\diamond$ \texttt{hasNext()} \\
	\hspace{0.6cm} - \texttt{true}, falls mindestens ein Element noch nicht durch \\
	\hspace{0.9cm} diesen \texttt{Iterator} zurückgeliefert wurde } \\ \hline

	\makecell[l]{Interface \texttt{Map}} & \makecell[l]{$\rhd$ z.B.: \texttt{Map<String,Integer> map = new HashMap<String,Integer>();} \\
	\hspace{0.4cm} $\diamond$  Erster Typparameter: \texttt{Key} (hier: \texttt{String}) \\
	\hspace{0.4cm} $\diamond$  Typparameter: \texttt{Value} (hier: \texttt{Integer}) \\
	$\rhd$ Eine \texttt{Map} realisiert eine Abbildung von den \texttt{Keys} in die \texttt{Values} \\
	\hspace{0.4cm} $\diamond$  \texttt{Keys} müssen alle unterschiedlich sein \\
	$\rhd$ Methoden: \\
	\hspace{0.4cm} $\diamond$ \texttt{put(key, value) // Fügt Paar in Map ein} \\
	\hspace{0.4cm} $\diamond$ \texttt{get(key) // Gibt value zu bestimmtem key zurück} } \\ \hline

	\makecell[l]{\texttt{LinkedList}} & \makecell[l]{$\rhd$ Aufbau: \\
	\hspace{0.4cm} $\diamond$ Elemente der Liste enthalten: \\
	\hspace{0.6cm} - \texttt{Key} vom Typ T \\
	\hspace{0.6cm} - Attribut vom selben Elementtyp mit Namen \texttt{next} \\
	\hspace{0.4cm} $\diamond$ Abspeichern des sogenannten \texttt{head}, dieser speichert die Liste \\
	\hspace{0.4cm} $\diamond$ Die Liste wird durch die Verkettung untereinander mit \texttt{next} erstellt \\
	$\rhd$ Die folgenden Beispiele sollen nur die Logik hinter der Klasse erläutern
	$\rhd$ Durchlauf durch alle Elemente: (\textbf{LOGIK})\\
	\hspace{0.4cm} $\diamond$ (Die eigentliche Implementation in Java sieht anders aus) \\
	\hspace{0.4cm} $\diamond$ \texttt{for (ListItem<T> p = head; p != null; p = p.next) \{...\}} \\
	\hspace{0.4cm} $\diamond$ Setzen von \texttt{p} zu \texttt{p.next} bis \texttt{p == null} \\
	$\rhd$ Einfügen Element am Anfang: (\textbf{LOGIK}) \\
	\hspace{0.4cm} $\diamond$ Erstellen eines neuen Listitems und Kopieren der Werte \\
	\hspace{0.4cm} $\diamond$ Achtung: Erst \texttt{head} als \texttt{next} abspeichern \\
	\hspace{0.4cm} $\diamond$ Danach neues Listitem als \texttt{head} setzen \\
	\hspace{0.4cm} $\diamond$ (sonst geht die komplette Liste verloren) \\
	$\rhd$ Einfügen Element an Stelle n: (\textbf{LOGIK}) \\
	\hspace{0.4cm} $\diamond$ Fortschreiten des Durchlaufs bis zu n-1 \\
	\hspace{0.4cm} $\diamond$ \texttt{ListItem<T> tmp = new ListItem<T>();} \\
	\hspace{0.4cm} $\diamond$ \texttt{tmp.key = key; // Setzen des Keys} \\
	\hspace{0.4cm} $\diamond$ \texttt{tmp.next = p.next; // Knüpfen des neuen Elements an n+1.Element} \\
	\hspace{0.4cm} $\diamond$ \texttt{p.next = tmp; // Knüpfen des n-1.Elements an neues Element} \\
	$\rhd$ Entfernen Element: (\textbf{LOGIK}) \\ 
	\hspace{0.4cm} $\diamond$ Überspringen des zu löschenden Elements \\
	\hspace{0.4cm} $\diamond$ \texttt{head}: \texttt{head = head.next;} \\
	\hspace{0.4cm} $\diamond$ Sonst: \texttt{p.next = p.next.next;} \\
	\hspace{0.6cm} - Laufpointer muss in diesem Fall eine Stelle davor stehenbleiben \\
	$\rhd$ Allgemein: \\
	\hspace{0.4cm} $\diamond$ Auf korrektes Zwischenspeichern achten! \\
	$\rhd$ Doppelte Verkettung: \\
	\hspace{0.4cm} $\diamond$ Ermöglicht rückwarts und vorwärts Durchlaufen \\
	\hspace{0.4cm} $\diamond$ Kostet Laufzeit und Speicher \\
	\hspace{0.4cm} $\diamond$ Verweisnamen meist \texttt{next} und \texttt{backward} \\
	\hspace{0.4cm} $\diamond$ Erhöhter Aufwand, da doppelte Verweiskopien \\
	$\rhd$ Zyklische Listen: \\
	\hspace{0.4cm} $\diamond$ Letzter Verweis nicht \texttt{null} sondern auf \texttt{head} \\
	} \\ \hline

	\end{longtable}

\section{Computerspeicher}



	\begin{tabular}{ | p{4cm} p{13.5cm} | }
	\hline
	\makecell[l]{Unsere Vorstellung} & 
	\makecell[l]{$\rhd$ gro\ss es Feld aus Maschinenwörtern mit eindeutiger Adresse} \\ \hline
	
	\makecell[l]{Erzeugung eines \\ neuen Objekts} & 
	\makecell[l]{$\rhd$ Reservierung von ungenutztem Speicher in ausreichender Grö\ss e} \\ \hline
	
	\makecell[l]{Referenz} & 
	\makecell[l]{$\rhd$ Name der Variable, die die Anfangsadresse des Objekts speichert \\ 
	$\rhd$ Kann auch an komplett anderer Stelle als das Objekt gespeichert sein } \\ \hline
	
	\makecell[l]{Speicherort primitiver \\ Datentypen} & 
	\makecell[l]{$\rhd$ Name verweist tatsächlich auf Speicherstelle, an der Wert abgespeichet wird } \\ \hline
	
	\makecell[l]{Prozessablauf} & 
	\makecell[l]{$\rhd$ Program Counter enthält Adresse der nächsten Anweisung \\
	\hspace{0.4cm} $\diamond$ Zählt nach jeder Anwendung hoch und verweist auf nächsten Speicher \\
	$\rhd$ CPU verarbeitet parallel die momentane Anweisung aus Program Counter} \\ \hline
	
	\makecell[l]{Methodenausführung} & 
	\makecell[l]{$\rhd$ Einrichtung einer Variable \texttt{StackPointer} bei Programmstart \\
	$\rhd$ StackPointer enthält die Adresse des \texttt{Call-Stacks} \\
	$\rhd$ Bei Methodenaufruf wird im Speicher Platz reserviert, genannt \texttt{Frame} \\
	$\rhd$ \texttt{Frame}  wird dann auf dem Call-Stack abgelegt\\
	$\rhd$ Der \texttt{StackPointer}  wird dann mit der Adresse des neuen\texttt{Frames}  überschrieben \\
	$\rhd$ Methodenaufruf vorbei: Frame wird wieder vom \texttt{Call-Stack} genommen \\
	$\rhd$ \texttt{StackPointer} wird auf Adresse des vorherigen \texttt{Frames}  gesetzt} \\ \hline
	
	\makecell[l]{Methodentabelle} & \makecell[l]{$\rhd$ Enthält bei Objekt die Anfangsadressen der 
	verfügbaren Methoden } \\ \hline
	
	\end{tabular}
	
	\begin{center}
	\includegraphics[scale=0.8]{computerspeicher}
	\end{center}

\section{Datenstrukturen}

\begin{tabular}{ | p{4cm} p{13.5cm} | }
	\hline
	\makecell[l]{Array} & 
	\makecell[l]{$\rhd$ Verwendet zum Speichern von mehreren Variablen des selben Typs \\
	$\rhd$ Erzeugung: \texttt{int[] test = new int[n];} \\
	$\rhd$ \texttt{n} gibt in diesem Fall die feste Anzahl der speicherbaren Variablen an \\
	$\rhd$ Natürlich auch Arrays von Objekten möglich \\
	$\rhd$ Zugriff auf Variablen: \texttt{test[0]} für ersten Wert (Index) \\
	$\rhd$ Zugriff auf Länge: \texttt{test.length} } \\ \hline
	\end{tabular}



\section{Datentypen}

	\begin{tabular}{ | p{4cm} p{13.5cm} | }
	\hline
	\makecell[l]{Konstanten} & \makecell[l]{$\rhd$ Variable/Referenz wird dadurch unveränderbar \\
	$\rhd$ z.B.: \texttt{final myClass ABC = new myClass();} \\
	\hspace{0.4cm} $\diamond$ Referenz zwar nicht veränderbar, Objekt aber schon \\ 
	$\rhd$ \texttt{Integer.MAX\_VALUE / Integer.MIN\_VALUE} \\
	$\rhd$ Unendlich: \texttt{Double.POSITIVE\_INFINITY / Double.NEGATIVE\_INFINITY} \\
	$\rhd$ Müssen initalisiert werden } \\ \hline
	
	\makecell[l]{Primitive Dateitypen} & 
	\makecell[l]{$\rhd$ Ganze Zahlen: byte $\rightarrow$ short $\rightarrow$ int $\rightarrow$ long \\
	$\rhd$ Gebrochene Zahlen: float $\rightarrow$ double \\
	$\rhd$ Logik: boolean \\
	$\rhd$ Zeichen: char \\
	$\rhd$ Mehrere Definitonen: \texttt{int m = 1, n, k = 2;} \\ 
	$\rhd$ Ohne Initialisierung: undefinierter Wert} \\ \hline
	
	\makecell[l]{Literale} & \makecell[l]{$\rhd$ wörtlich hingeschriebene Werte eines Datentyps  \\
	$\rhd$ Zahlen standardmä\ss ig int, falls \texttt{long} gewünscht: \texttt{123L oder 123l} \\ 
	$\rhd$ Bei gebrochenen double, falls \texttt{float} gewünscht: \texttt{12.3F oder 12.3f} \\
	$\rhd$ null: Nutzung für Referenzen $\rightarrow$ verweist auf nichts} \\ \hline
	
	\makecell[l]{Boolean} & \makecell[l]{$\rhd$ nur \texttt{true} und \texttt{false} \\
	$\rhd$ Negation \texttt{!a} \\
	$\rhd$ Logisches Und: \texttt{a \&\& b} \\
	$\rhd$ Logisches Oder: \texttt{a || b} (inklusiv) \\
	$\rhd$ Gleichheit: \texttt{a == b} } \\ \hline
	
	\makecell[l]{Zeichentyp char} & \makecell[l]{$\rhd$ z.B.: \texttt{char c = ´a´;} \\
	$\rhd$ Interne Kodierung als Unicode \\
	$\rhd$ \textbackslash t Horizontaler Tab \\
	$\rhd$ \textbackslash b Backspace \\
	$\rhd$ \textbackslash n Neue Zeile \\
	$\rhd$ Auch Darstellung im Hexacode (\textbackslash u039A)} \\ \hline
	
	\makecell[l]{Enumeration} & \makecell[l]{$\rhd$ Zusammenfassung mehrerer Konstanten (feste Anzahl)\\
	$\rhd$ Erzeugung meist in eigener .java Datei \\
	$\rhd$ \texttt{enum MyDirection \{DOWN, RIGHT\} } \\
	$\rhd$ Keine Objekterzeugung von Enumeration möglich \\
	$\rhd$ Abspeichern in Variable des Enum-Types ist jedoch möglich \\
	$\rhd$ \texttt{MyDirection dir = MyDirection.DOWN;} \\
	$\rhd$ Klassenmethoden: \\
	\hspace{0.4cm} $\diamond$ \texttt{values() // Returns array with all enum components} \\
	\hspace{0.4cm} $\diamond$ \texttt{name() // Returns the name of the calling object as string} \\
	 } \\ \hline
	
	\makecell[l]{Referenztypen} & \makecell[l]{$\rhd$ Alle Typen, die keine primitiven Datentypen sind \\
	$\rhd$ Unterscheidung zwischen Referez und eigentlichem Objekt \\
	$\rhd$ Gleichheitsoperator \texttt{==} vergleicht nur die Referenz (Objektidentität) \\
	\hspace{0.4cm} $\diamond$ Verweis auf dasselbe Objekt \\
	$\rhd$ Wertgleichheit bezieht sich auf das Objekt an sich \\
	\hspace{0.4cm} $\diamond$ Deep Copy $\Rightarrow$ An allen parallelen Stellen Wertgleichheit \\
	\hspace{0.4cm} $\diamond$ Shallow Copy $\Rightarrow$ Nur Kopie der Adressen \\
	$\rhd$ Ohne Initialisierung: Null} \\ \hline
	\end{tabular}


\section{Exceptions (java.lang.Exception;)}

\begin{tabular}{ | p{4cm} p{13.5cm} | }
	\hline
	\makecell[l]{Exception-Klassen} & \makecell[l]{$\rhd$ Alle Klassen, die direkt oder indirekt von java.lang.Exception abgeleitet sind \\
	$\rhd$  } \\ \hline

	\makecell[l]{Exception werfen} & \makecell[l]{$\rhd$ \texttt{throws Exception \{...\}} nach Parameterliste im Methodenkopf \\
	$\rhd$ Dies signalisiert, dass die Methode mindestens einen Fehler wirft \\
	$\rhd$ Die geworfene Exception muss vom \texttt{throws}-Typ oder Subtyp sein \\
	$\rhd$ Auch mehrere Exceptions möglich, mit einem Komma getrennt \\
	$\rhd$ Werfen der Exception: \\
	\hspace{0.4cm} $\diamond$ z.B.: \texttt{throw new Exception ("No lower case letter!");} \\
	\hspace{0.4cm} $\diamond$ Hier wird als Parameter für die Objekterstellung ein String übergeben \\
	$\rhd$ \texttt{throws}: \\
	\hspace{0.4cm} $\diamond$ Führt zur Beendung der Methode \\
	\hspace{0.4cm} $\diamond$ Liefert das geworfene Exception-Objekt zurück } \\ \hline

	\makecell[l]{Exception fangen} & \makecell[l]{$\rhd$ Bei Methoden, die Exceptions werfen, wird ein \texttt{try-catch}-Block benötigt \\
	$\rhd$ Aufbau: \\
	\hspace{0.4cm} $\diamond$ Methoden, die Exceptions werfen in \texttt{try \{...\}} aufrufen \\
	\hspace{0.4cm} $\diamond$ Falls Exception auftritt wird \texttt{catch (Exception exc) \{...\}} aufgerufen \\
	\hspace{0.4cm} $\diamond$ \texttt{catch} muss direkt im Anschluss nach \texttt{try} stehen \\
	\hspace{0.4cm} $\diamond$ Falls kein Fehler auftritt, wird \texttt{catch} übersprungen \\
	\hspace{0.4cm} $\diamond$ Das Programm wird dann normal weiter ausgeführt \\
	$\rhd$ Es sind auch mehrere \texttt{catch}-Blöcke mit versch. Parametern möglich \\
	$\rhd$ Methoden: \\
	\hspace{0.4cm} $\diamond$ \texttt{getMessage(); // Returns the error message as a string} \\
	\hspace{0.4cm} $\diamond$ \texttt{printStackTrace(); // Ausgabe des Call-Stacks} \\
	$\rhd$ Alle möglichen Exceptions müssen durch den \texttt{catch}-Block abgedeckt sein \\
	$\rhd$ Falls Exception zu mehreren \texttt{catch}-Blöcken 'passt', wird der Erste ausgeführt \\
	\hspace{0.4cm} $\diamond$ Deswegen Reihung der \texttt{catch}-Blöcke von Subtyp nach Supertyp \\
	$\rhd$ Auch mehrere Exceptions in einem \texttt{catch}-Block möglich mit \texttt{||}} \\ \hline

	\makecell[l]{Weiterreichen} & \makecell[l]{$\rhd$ Weiterreichen der Fehlermeldung durch \texttt{throws} im Methodenkopf möglich \\
	$\rhd$ Kein \texttt{try-catch}-Block notwendig \\
	$\rhd$ Main-Methode kann z.B. keine Exceptions weiterreichen} \\ \hline

	\makecell[l]{ \texttt{try-with-ressources} } & \makecell[l]{$\rhd$ Für Ressourcen, die unbedingt wieder geschlossen werden müssen \\
	$\rhd$ Öffnung der Ressource in runden Klammern: \texttt{try (Printer p =... ) \{...\}} \\
	$\rhd$ Mehrere Ressourcen möglich, getrennt durch Semikolon } \\ \hline

	\makecell[l]{Runtime Exceptions} & \makecell[l]{$\rhd$ Ausnahme zu \texttt{try}-Blöcken \\
	$\rhd$ Exceptions von java.lang.RuntimeException und Subtypen \\
	$\rhd$ z.B.: IndexOutOfBoundsException, NullPointerException \\ 
	$\rhd$ Grund: Vermeidung von dauerenden \texttt{try}-Blöcken} \\ \hline
	
	\makecell[l]{Throwable und Error} & \makecell[l]{$\rhd$ Exception und Error sind beide von Throwable abgeleitet \\
	$\rhd$ Alle drei befinden sich im Paket java.lang \\
	$\rhd$ Error: \\
	\hspace{0.4cm} $\diamond$ Werden geworfen, falls Fehlerbehandlung keinen Sinn macht \\
	\hspace{0.4cm} $\diamond$ Programmabbruch als Ausweg \\
	$\rhd$ AssertionError: \\
	\hspace{0.4cm} $\diamond$ \texttt{throw new AssertionError("Bad!");} \\
	\hspace{0.4cm} $\diamond$ Kurzform: \texttt{assert x == 2: "Bad!";} \\
	\hspace{0.4cm} $\diamond$ \textbf{Wichtig:} Bedingung muss negiert werden! \\
	\hspace{0.4cm} $\diamond$ Assertanweisungen sinnvoll, da kurz und übersichtlich \\
	\hspace{0.4cm} $\diamond$ Können zusätzlich vom Compiler an- und abgeschaltet werden \\
	\hspace{0.4cm} $\diamond$ z.B.: Verwendung für Tests für Methoden und späteres Abschalten \\
	$\rhd$ Solche Tests werden White-Box-Tests genannt } \\ \hline

	\end{tabular}

\section{Fehler}
	\begin{tabular}{ | p{4cm} p{13.5cm} | }
	\hline
	\makecell[l]{Kompilierzeitfehler \\ (compile-time errors)} & 
	\makecell[l]{$\rhd$ Falsche Klammersetzung, falsche Schlüsselwörter,..\\
	$\rhd$ Programm wird nicht übersetzt $\Rightarrow$ Fehlermeldung vom Compiler } \\ \hline
	
	\makecell[l]{Laufzeitfehler \\ (run-time errors)} & 
	\makecell[l]{$\rhd$ Tritt während der Ausführung auf \\
	$\rhd$ Führt zum Abbruch des Programms $\Rightarrow$ Ausgabe der Fehlermeldung \\
	$\rhd$ Kann nicht vom Compiler entdeckt werden \\
	$\rhd$ IndexOutOfBounds, NullPointerException,.. } \\ \hline
	\end{tabular}

\section{Files}
	\begin{longtable}{ | p{4cm} p{13.5cm} | }
	\hline
	
	\makecell[l]{System Properties \\ (java.lang.System)} & \makecell[l]{$\rhd$ Attribute der Umgebung, in denen das Java Programm abläuft \\
	$\rhd$ Methoden: \\
	\hspace{0.4cm} $\diamond$ \texttt{getProperty} \\
	\hspace{0.6cm} - Erhält \texttt{String} und gibt \texttt{String} zurück \\ 
	\hspace{0.4cm} $\diamond$ z.B.: \texttt{String homeDir = System.getProperty(\string"user.home\string");} \\
	\hspace{0.4cm} $\diamond$ Mögliche Strings: \\
	\hspace{0.6cm} - \texttt{\string"user.home\string" // Home directory} \\
	\hspace{0.6cm} - \texttt{\string"user.dir\string" // Working directory} \\
	\hspace{0.6cm} - \texttt{\string"user.name\string" // Account name} \\
	\hspace{0.6cm} - \texttt{\string"file.separator\string" // Zeichen zur Dateitrennung} \\
	\hspace{0.6cm} - \texttt{\string"line.separator\string" // Zeichen zur Zeilentrennung} \\
	$\rhd$ \texttt{System.out}: \\
	\hspace{0.4cm} $\diamond$ Klassenattribut \texttt{out} von System ist von Klasse \texttt{PrintStream} \\
	\hspace{0.4cm} $\diamond$ \texttt{PrintStream} hat also auch Methoden wie \texttt{println} \\
	$\rhd$ \texttt{System.err}: \\
	\hspace{0.4cm} $\diamond$ Auch \texttt{err} ist von Klasse \texttt{PrintStream} \\
	\hspace{0.4cm} $\diamond$ Hierhin werden die Fehlerausgaben geschrieben \\
	\hspace{0.4cm} $\diamond$ z.B. sinnvoll um Fehler in seperate Log-Datei umzuleiten \\
	$\rhd$ \texttt{System.in}: \\
	\hspace{0.4cm} $\diamond$ Auch \texttt{in} ist von Klasse \texttt{PrintStream} \\
	\hspace{0.4cm} $\diamond$ Liest Tastatureingaben \\
	$\rhd$ Diese drei Attribute können auch auf andere Streams gesetzt werden \\
	\hspace{0.4cm} $\diamond$ z.B.: andere \texttt{FileInputStreams/FileOutputStreams} \\
	\hspace{0.4cm} $\diamond$ \texttt{System.setIn(in); System.setOut(out); System.setErr(err);}
	} \\ \hline

	\makecell[l]{Klasse Path / Paths} & \makecell[l]{$\rhd$ Beide in \texttt{java.nio.file} \\
	$\rhd$ Objekt der Klasse \texttt{Path} verwaltet einen Pfadnamen \\
	\hspace{0.4cm} $\diamond$ Dort muss nicht unbedingt etwas existieren \\
	$\rhd$ \texttt{Paths} wird nur dazu genutzt um Objekt von \texttt{Path} zu erzeugen \\
	\hspace{0.4cm} $\diamond$ z.B.: \texttt{Path path = Paths.get(homeDir, \string"fop.txt\string");}   } \\ \hline

	\makecell[l]{Klasse Files} & \makecell[l]{$\rhd$ Aus Package \texttt{java.nio.file} \\
	$\rhd$ Nützliche Sammlung von Klassenmethoden rund um Dateien \\
	$\rhd$ Methoden: \\
	\hspace{0.4cm} $\diamond$ \texttt{lines // Files.lines(path);} \\
	\hspace{0.6cm} - Öffnet Datei an übergebenem Pfad \\
	\hspace{0.6cm} - Liefert einen Stream von Strings, ein String pro Zeile \\
	\hspace{0.6cm} - Zeilenende durch \texttt{\string"file.separator\string"} gekennzeichnet \\
	\hspace{0.6cm} - \texttt{IOException}, falls Problem beim Öffnen der Datei (\texttt{java.io}) \\
	\hspace{0.4cm} $\diamond$ \texttt{exists // Files.exists(path);} \\
	\hspace{0.6cm} - \texttt{true}, wenn es dort Datei/Verzeichnis gibt \\
	\hspace{0.4cm} $\diamond$ \texttt{isReadable(path)} \\
	\hspace{0.6cm} - Fragt lesende Zugriffsrechte ab \\
	\hspace{0.4cm} $\diamond$ \texttt{isWritable(path)} \\
	\hspace{0.6cm} - Fragt schreibende Zugriffsrechte ab \\
	\hspace{0.4cm} $\diamond$ \texttt{isRegularFile(path)} \\
	\hspace{0.6cm} - \texttt{true}, falls es eine reguläre Datei ist (kein Verzeichnis) \\
	\hspace{0.4cm} $\diamond$ \texttt{isDirectory(path)} \\
	\hspace{0.6cm} - \texttt{true}, falls es ein Verzeichnis ist \\
	\hspace{0.4cm} $\diamond$ \texttt{size(path) // long size = Files.size(path);} \\
	\hspace{0.6cm} - Fragt die Grö\ss e der Datei ab \\
	\hspace{0.6cm} - \texttt{long}, da die Dateigröe oft nicht in \texttt{int} passt \\
	\hspace{0.4cm} $\diamond$ \texttt{createFile(path)} \\
	\hspace{0.6cm} - Richtet Datei an der übergebenen Stelle ein \\
	\hspace{0.4cm} $\diamond$ \texttt{copy(path1, path2)} \\
	\hspace{0.6cm} - Kopieren von Pfad 1 nach Pfad 2 \\
	\hspace{0.4cm} $\diamond$ \texttt{move(path1, path2)} \\
	\hspace{0.6cm} - Umbenennen einer Datei, oft auch Bewegen genannt \\
	\hspace{0.4cm} $\diamond$ \texttt{delete(path)} \\
	\hspace{0.6cm} - Entfernen einer Datei \\
	\hspace{0.6cm} - \texttt{NoSuchElementException}, falls nicht vorhanden \\
	\hspace{0.4cm} $\diamond$ \texttt{deleteIfExists(path)} \\
	\hspace{0.6cm} - Falls das Objekt nicht existiert, passiert garnichts} \\ \hline
	
	\makecell[l]{Beispiel: \\ Einlesen einer Datei \\  in einen String} & \makecell[l]{
	1 \hspace{0.1cm} \texttt{String homeDir = System.getProperty(\string"user.home\string");} \\
	2 \hspace{0.1cm} \texttt{Path path = Paths.get(homeDir, \string"fop\string", \string"streams.txt\string");} \\
	3 \hspace{0.1cm} \texttt{try (Stream<String> stream = Files.lines(path)) \{ }  \\
	4 \hspace{0.5cm} \texttt{String fileContentAsString = stream.reduce(String::concat);} \\
	5 \hspace{0.1cm} \texttt{\} catch (IOException exc) \{ } \\
	6 \hspace{0.5cm} \texttt{System.out.print(\string"Could not open file\string")} \\
	7 \hspace{0.1cm} \texttt{\}} \\
	$\rhd$ \texttt{try-with-resources} wird für Interface \texttt{AutoCloseable} verwendet } \\ \hline

	\makecell[l]{Bytedaten} & \makecell[l]{$\rhd$ Direkt, ohne Bezug zu Streams \\
	$\rhd$ Klassen und Interfaces finden sich in \texttt{java.io} \\
	$\rhd$ Byteweise Verarbeitung sinnvoll für Audio oder Bilddateien, nicht für Text \\
	$\rhd$ Wird aber meist durch Bibliotheken oder Ähnliches gehandhabt} \\ \hline

	\makecell[l]{Bytedaten lesen} & \makecell[l]{$\rhd$ Verwendung eines \texttt{InputStream}-Objekts \\
	$\rhd$ \texttt{InputStream} abstrakt, deswegen nur Subtypen z.B.: \texttt{FileInputStream} \\
	\hspace{0.4cm} $\diamond$ \texttt{FileInputStream} nutzt den Namen der Datei als String im Konstruktor \\
	$\rhd$ Methoden: \\
	\hspace{0.4cm} $\diamond$ \texttt{read()} \\
	\hspace{0.6cm} - Liest nächstes Byte in ein \texttt{int} \\
	\hspace{0.6cm} - Überprüfung, ob -1 um zu prüfen, ob Dateiende erreicht ist \\
	$\rhd$ Beispiel: \\
	\hspace{0.4cm} 1 \hspace{0.1cm} \texttt{FileInputStream in = new FileInputStream (fileName);} \\
	\hspace{0.4cm} 2 \hspace{0.1cm} \texttt{int n = in.read();} \\
	\hspace{0.4cm} 3 \hspace{0.1cm} \texttt{if (n == 1) return;} } \\ \hline

	\makecell[l]{Bytedaten schreiben} & \makecell[l]{$\rhd$ Verwendung eines \texttt{OutputStream}-Objekts \\
	$\rhd$ \texttt{OutputStream} abstrakt, deswegen nur Subtypen z.B.: \texttt{FileOutputStream} \\
	\hspace{0.4cm} $\diamond$ \texttt{FileOutputStream} nutzt den Namen der Datei als String im Konstruktor \\
	\hspace{0.4cm} $\diamond$ Existiert die Datei schon, geht der Inhalt verloren \\
	\hspace{0.4cm} $\diamond$ Existiert die Datei nicht, wird sie erstellt \\
	\hspace{0.4cm} $\diamond$ Zweiter Konstruktor mit \texttt{boolean} als zweiten Paramter: \\
	\hspace{0.6cm} - Falls \texttt{false}: Verhält sich wie normaler Konstruktor \\
	\hspace{0.6cm} - Falls \texttt{true}: Inhalt geht nicht verloren, wird hinten angehangen  \\
	$\rhd$ Methoden: \\
	\hspace{0.4cm} $\diamond$ \texttt{write()} \\
	\hspace{0.4cm} $\diamond$ Hat \texttt{int} als formalen Parametertyp \\
	\hspace{0.4cm} $\diamond$ Schreibt nur unterestes Byte dieses \texttt{int} \\
	$\rhd$ Beispiel: \\
	\hspace{0.4cm} 1 \hspace{0.1cm} \texttt{FileOutputStream out = new FileOutputStream(fileName);} \\  
	\hspace{0.4cm} 2 \hspace{0.1cm} \texttt{int i = 5;} \\
	\hspace{0.4cm} 3 \hspace{0.1cm} \texttt{out.write(i);}} \\ \hline

	\makecell[l]{Relevante Subtypen  von \\Input-/OutputStream} & \makecell[l]{
	$\rhd$ Geschwindigkeit beim Lesen/Schreiben ist relevant \\
	$\rhd$ \texttt{BufferedInputStream}: \\
	\hspace{0.4cm} $\diamond$ liest mehrere Bytes auf einmal ein \\
	\hspace{0.4cm} $\diamond$ Konstruktor: \texttt{BufferedInputStream(InputStream in)} \\
	\hspace{0.4cm} $\diamond$ Verwendet im Konstruktor z.B. einen \texttt{FileInputStream} \\
	$\rhd$ \texttt{BufferedOutputStream}: \\
	\hspace{0.4cm} $\diamond$ Schreibt zuerst in internen Puffer \\
	\hspace{0.4cm} $\diamond$ Falls dieser voll ist, wird in die Datei geschrieben \\
	\hspace{0.4cm} $\diamond$ Konstruktor: \texttt{BufferedOutputStream(OutputStream out)} \\
	\hspace{0.4cm} $\diamond$ Schreibt die Daten auf den OutputStream im Parameter \\
	$\rhd$ \texttt{PrintStream}: \\
	\hspace{0.4cm} $\diamond$ Ersatz für OutputStream im Package \texttt{java.io} \\
	\hspace{0.4cm} $\diamond$ Konstruktor: \texttt{PrintStream(OutputStream out)} \\
	\hspace{0.4cm} $\diamond$ Dient als Konvertierer von primitiven Datentypen und String \\
	\hspace{0.8cm} in die byteweise Darstellung \\
	\hspace{0.4cm} $\diamond$ Das eigentliche Schreiben übernimmt der übergebene \texttt{OutputStream} \\
	\hspace{0.4cm} $\diamond$ Methode \texttt{print} \\ 
	\hspace{0.6cm} - z.B.: \texttt{out1.print("pi = "); out1.print(3.14);} \\
	\hspace{0.6cm} - Byteweise Ausgabe von übergebenen Werten \\
	\hspace{0.4cm} $\diamond$ \texttt{System.out.print()}: \texttt{out} ist von Klasse \texttt{PrintStream} \\
	\hspace{0.4cm} $\diamond$ Methode \texttt{println} \\
	\hspace{0.6cm} - Ausgabe von Werten mit Zeilenumbruch} \\ \hline

	\makecell[l]{Mehr Subtypen von \\Input-/OutputStream} & \makecell[l]{
	$\rhd$ \texttt{java.util.zip.ZipInputStream} \\
	\hspace{0.4cm} $\diamond$ Zum Einlesen von komprimierten Zip-Dateien \\
	$\rhd$ \texttt{java.util.jar.JarInputStream} \\
	\hspace{0.4cm} $\diamond$ Zum Einlesen von Jar-Dateien \\
	\hspace{0.4cm} $\diamond$ Jar-Dateien enthalten kompilierte Java-Dateien, mit zip komprimiert \\
	$\rhd$ \texttt{javax.sound.sampled.AudioInputStream} \\
	\hspace{0.4cm} $\diamond$ für Audio-Dateien \\
	$\rhd$ \texttt{java.io.PipedInputStream / java.io.PipedOutputStream} \\
	\hspace{0.4cm} $\diamond$ Zwei aneinander gekoppelte Lese/Schreib-Klassen
	} \\ \hline

	\makecell[l]{Textdaten direkt} & \makecell[l]{$\rhd$ Bequemere Zugriffsmöglichkeiten für Textdaten vorhanden \\
	$\rhd$ \texttt{Reader} und \texttt{Writer} aus Package \texttt{java.io} \\
	$\rhd$ Textdatei besteht aus einzelnen Zeichen aka \texttt{char} \\
	\hspace{0.4cm} $\diamond$ Jedes \texttt{char} ist zwei Byte gro\ss} \\ \hline

	\makecell[l]{Textdaten lesen} & \makecell[l]{$\rhd$ Komplett analog zu \texttt{InputStream} und \texttt{FileInputStream} \\
	$\rhd$ \texttt{Reader} abstrakt, deswegen nur Subtypen z.B. \texttt{FileReader} \\
	\hspace{0.4cm} $\diamond$ \texttt{FileReader} nutzt den Namen der Datei als String im Konstruktor \\
	$\rhd$ Methoden: \\
	\hspace{0.4cm} $\diamond$ \texttt{read} \\
	\hspace{0.6cm} - Liest \texttt{char}-Werte ein \\
	\hspace{0.6cm} - Verschiedene Implementationen z.B.: kein Parameter $\rightarrow$ einzelner \texttt{char} \\
	\hspace{0.6cm} - Mit \texttt{char-Array}: Liest soviele ein, bis \texttt{Array} voll ist \\
	$\rhd$ Beispiel: \\
	\hspace{0.4cm} 1 \hspace{0.1cm} \texttt{FileReader reader1 = new FileReader(fileName);} \\
	\hspace{0.4cm} 2 \hspace{0.1cm} \texttt{char[] buffer = new char[256];} \\
	\hspace{0.4cm} 3 \hspace{0.1cm} \texttt{int n = reader1.read(buffer);} \\
	\hspace{0.4cm} 4 \hspace{0.1cm} \texttt{// n ist in diesem Fall die Anzahl der gelesenen chars} \\
	$\rhd$ \texttt{BufferedReader} \\
	\hspace{0.4cm} $\diamond$ Konstruktor: \texttt{BufferedReader(Reader in)} \\
	\hspace{0.4cm} $\diamond$ Methode \texttt{readLine();} \\
	\hspace{0.6cm} - Liest alles vom letzten gelesenen Zeichen bis zum Zeilenende \\
	\hspace{0.6cm} - Also meist eine ganze Zeile \\
	$\rhd$ Verknüpfung mit byteweisem Einlesen: \\
	\hspace{0.4cm} $\diamond$ evtl. sinnvoll, falls offener \texttt{InputStream} auf Text-Datenquelle \\
	\hspace{0.4cm} $\diamond$ Die Brücke bildet hier der Subtyp \texttt{InputStreamReader} \\
	\hspace{0.4cm} 1 \hspace{0.1cm} \texttt{InputStream in = ...;} \\
	\hspace{0.4cm} 2 \hspace{0.1cm} \texttt{Reader reader = new InputStreamReader(in);}} \\ \hline

	\makecell[l]{Textdaten schreiben} & \makecell[l]{
	$\rhd$ \texttt{Writer} abstrakt, deswegen nur Subtypen z.B. \texttt{FileWriter} \\
	\hspace{0.4cm} $\diamond$ \texttt{FileWriter} benutzt den Namen der Datei als String im Konstruktor \\
	$\rhd$ Methoden: \\
	\hspace{0.4cm} $\diamond$ \texttt{write} \\
	\hspace{0.6cm} - Schreibt einzelnen \texttt{char} oder ganzen \texttt{String} \\
	$\rhd$ Beispiel: \\
	\hspace{0.4cm} 1 \hspace{0.1cm} \texttt{FileWriter writer1 = new FileWriter(fileName);} \\
	\hspace{0.4cm} 2 \hspace{0.1cm} \texttt{writer1.write('H');} \\
	\hspace{0.4cm} 3 \hspace{0.1cm} \texttt{writer1.write(\string"ello World\string");} \\ 
	$\rhd$ Verknüpfung mit byteweisem Schreiben: \\
	\hspace{0.4cm} $\diamond$ Die Brücke bildet hier der Subtyp \texttt{OutputStreamWriter} \\
	\hspace{0.4cm} 1 \hspace{0.1cm} \texttt{OutputStream out = ...;} \\
	\hspace{0.4cm} 2 \hspace{0.1cm} \texttt{Writer writer = new OutputStreamWriter(out);} } \\ \hline

	\end{longtable}

\section{Generics}
	\begin{longtable}{ | p{4cm} p{13.5cm} | }
	\hline
	\makecell[l]{Wrapper-Klassen} & \makecell[l]{$\rhd$ primitive Datentypen nicht mit Generizität vereinbar \\
	$\rhd$ Deswegen benötigen wir eine stellvertretende Klasse $\rightarrow$ Wrapper-Klassen \\
	$\rhd$ selber Name, nur mit gro"sem Anfangsbuchstaben (Integer, Long, Character,..) \\
	$\rhd$ Konstruktor mit Parameter des zugehörigen Datentyps \\
	$\rhd$ Methoden: \\
	\hspace{0.4cm} $\diamond$ \texttt{intValue(); // Returns specific value of class} \\
	\hspace{0.4cm} $\diamond$ \texttt{MAX\_VALUE; // Returns max value} \\
	$\rhd$ Boxing/Unboxing: \\
	\hspace{0.4cm} $\diamond$ Primitiver Datentyp und Wrapper-Klasse sind austauschbar \\
	\hspace{0.4cm} $\diamond$ Automatische Umwandlung ineinander \\
	\hspace{0.4cm} $\diamond$ Boxing: \texttt{Integer i = 123;} \\
	\hspace{0.4cm} $\diamond$ Unboxing: \texttt{System.out.print(i); // 123} } \\ \hline
	
	\makecell[l]{Generische Klassen} & \makecell[l]{$\rhd$ \texttt{public class Pair <T1, T2> \{...\}} \\
	$\rhd$ Klasse \texttt{Pair} ist \textbf{generisch} / Klasse \texttt{Pair} ist mit T1 und T2 \textbf{parametrisiert} \\
	$\rhd$ \texttt{T1} und \texttt{T2} sind die \textbf{Typparameter} von Klasse \texttt{Pair} \\
	$\rhd$ \texttt{T1} und \texttt{T2} können als Datentypen/Rückgabewerte verwendet werden \\
	$\rhd$ Können \textbf{nicht} in Klassenmethoden verwendet werden  \\
	$\rhd$ Bei Einrichtung von Objekten von \texttt{Pair} werden die Typparamter festgelegt \\
	\hspace{0.4cm} $\diamond$ \texttt{Pair<Integer,Double> pair = new Pair<Integer,Double>(2,3.5);} \\
	\hspace{0.4cm} $\diamond$ \texttt{Pair} ist mit \texttt{Integer} und \texttt{Double} \textbf{instanziiert}\\
	\hspace{0.4cm} $\diamond$ Typparameter können natürlich auch vom selben Typ sein} \\ \hline

	\makecell[l]{Generische Methoden} & \makecell[l]{$\rhd$ Auch in \textbf{nicht-generischen Klassen} generische Methoden möglich \\
	$\rhd$ \texttt{public class X \{...\}} \\
	$\rhd$ Einzelne Methode parametrisiert: \\
	\hspace{0.4cm} $\diamond$ \texttt{public <T1,T2> Pair<T1,T2> makePair(T1 t1, T2 t2) \{...\}} \\
	\hspace{0.4cm} $\diamond$ \textbf{Parametrisierung} der Methode (\texttt{<T1,T2>}) steht vor dem Rückgabetyp \\
	$\rhd$ Aufurf: \\
	\hspace{0.4cm} $\diamond$ \texttt{Pair<A,B> pair1 = x.makePair(new A(), new B());} \\
	\hspace{0.4cm} $\diamond$ Compiler erkennt selbst die Typen für die Methode \\
	$\rhd$ Falls \texttt{T1} z.B. schon die Klasse \texttt{X} parametrisiert: \\
	\hspace{0.8cm} \texttt{public class X <T1>} \{ \\
	\hspace{1.2cm} \texttt{public <T2> Pair<T1,T2> makePair(T1 t1, T2 t2) \{...\} } \\
	\hspace{0.8cm} \} } \\ \hline 

	\makecell[l]{Typparameter} & \makecell[l]{$\rhd$ Alle Arten von Klassen und Arrays möglich \\
	$\rhd$ Auch parametrisierte Klassen sind als Typparamter möglich \\
	$\rhd$ Typparameter dürfen jedoch nicht vom primitiven Datentyp sein \\
	$\rhd$ Vererbung von Typparametern ist jedoch nicht übertragbar \\ 
	\hspace{0.4cm} $\diamond$ Bei bereits instanziierten Parametern sind keine Subklassen möglich \\
	$\rhd$ Kurzform: \\
	\hspace{0.4cm} $\diamond$ \texttt{Pair<String,Integer> pair;} \\
	\hspace{0.4cm} $\diamond$ \texttt{pair = new Pair<> ("Hello", 123);} \\
	\hspace{0.4cm} $\diamond$ \texttt{"Diamond-Operator"}: Compiler erkennt selbstständig die Instanziierung } \\ \hline

	\makecell[l]{Eingeschränkte \\ Typparameter} & \makecell[l]{$\rhd$ Werden bei der Definition von generischen Klassen/Methoden verwendet \\
	$\rhd$ \texttt{<T extends X> // T gleich X, oder direkt/indirekt Subtyp von X} \\
	\hspace{0.4cm} $\diamond$ Notwendig um sicherzustellen, dass aufgerufene Methoden definiert sind \\
	\hspace{0.4cm} $\diamond$ z.B.: \texttt{<T extends Number> // z.B.: doubleValue() immer vorhanden} \\
	$\rhd$ Mehrfache Einschränkung:  \\
	\hspace{0.4cm} $\diamond$ \texttt{<T extends X \& Interface1 \& Interface2} \\
	\hspace{0.4cm} $\diamond$ Klasse muss, falls vorhanden, an erster Stelle stehen} \\ \hline

	\makecell[l]{Wildcards} & \makecell[l]{$\rhd$ Werden bei der Instanziierung von Typparametern verwendet \\
	$\rhd$ \texttt{public double m (X<? extends Number> n) \{...\}} \\
	\hspace{0.4cm} $\diamond$ Ermöglicht nun die Verwendung von Subklassen bei aktualen Parametern \\
	\hspace{0.4cm} $\diamond$ (Siehe Einschränkung \texttt{Typparameter / 4. Stichpunkt}) \\
	$\rhd$ \textbf{Unterschied:} \\
	\hspace{0.4cm} $\diamond$ \texttt{public <T extends Number> double m (X<T> n) \{...\}} \\
	\hspace{0.6cm} $\diamond$ Generische Methode mit eingeschränkt wählbarem Typparameter \\
	\hspace{0.4cm} $\diamond$ \texttt{public double m (X<? extends Number> n) \{...\}} \\
	\hspace{0.6cm} $\diamond$ Nichtgenerische Methode mit generischem Parameter mit eingeschränkt \\
	\hspace{1cm} wählbarem Typparameter \\
	$\rhd$ Weitere Wildcard: \texttt{X<?>} \\
	\hspace{0.4cm} $\diamond$ Allgemeinst möglichste, \texttt{extends Object} \\
	$\rhd$ \texttt{X<? super Double>} \\
	\hspace{0.4cm} $\diamond$ Mit allen Supertypen (direkt/indirekt) und alle implementieren Interfaces} \\ \hline

	\makecell[l]{Empfehlungen} & \makecell[l]{$\rhd$ Oracle-Empfehlungen im Bezug auf Wildcards \\
	$\rhd$ In-Parameter (Werte einer Methode, die nur gelesen werden): \\ 
	\hspace{0.4cm} $\diamond$ Verwendung von \texttt{extends} \\
	$\rhd$ Out-Paramter (Werte einer Methode, die nur geschrieben werden): \\
	\hspace{0.4cm} $\diamond$ Verwendung von \texttt{super} \\
	$\rhd$ In/Out-Parameter: \\
	\hspace{0.4cm} $\diamond$ Keine Verwendung von Wildcards \\
	$\rhd$ Rückgaben: \\
	\hspace{0.4cm} $\diamond$ Keine Verwendung von Wildcards} \\ \hline

	\makecell[l]{Interface Comparator} & \makecell[l]{$\rhd$  \texttt{Functional Interface} im Package \texttt{java.util} \\
	$\rhd$ Verwendung: \\
	\hspace{0.4cm} $\diamond$ Erstellen einer Vergleichsklasse, die \texttt{Comparator<T>} implementiert \\
	\hspace{0.4cm} $\diamond$ \texttt{..class MyComp<T extends Number> implements Comparator<T> \{...\}} \\
	\hspace{0.4cm} $\diamond$ Generisch mit einem Typparameter \\
	$\rhd$ Methode: \texttt{public int compare (T t1, T2) \{...\}} \\
	\hspace{0.4cm} $\diamond$ Methode, muss abhängig vom Fall, selbst implementiert werden \\
	\hspace{0.4cm} $\diamond$ 0, falls beide Objekte äquivalent \\
	\hspace{0.4cm} $\diamond$ Negative Zahl, falls 1.Objekt-Wert dem 2.Objekt-Wert vorangehend ist \\
	\hspace{0.4cm} $\diamond$ Positive Zahl, falls 1.Objekt-Wert dem 2.Objekt-Wert nachfolgend ist \\
	$\rhd$ \texttt{String} hat bereits eine Methode \texttt{compareTo}: sortiert lexikographisch }  \\ \hline

	\makecell[l]{Einschränkungen} & \makecell[l]{$\rhd$ Keine primitiven Datentypen als Instanziierung von Typparametern \\
	$\rhd$ Keine Erzeugung von Objekten/Arrays von Typparametern mit \texttt{new} \\
	$\rhd$ Keine Klassenattribute von Typparametern \\
	$\rhd$ Kein Downcast oder \texttt{instanceof} von Typparametern \\
	$\rhd$ Kein \texttt{throw-catch} mit Typparametern \\
	$\rhd$ Keine Methodenüberladung mit Typparametern } \\ \hline

	\end{longtable}



\section{Graphics (java.awt.Graphics;)}
	\begin{tabular}{ | p{4cm} p{13.5cm} | }
	\hline
	\makecell[l]{Applet} & \makecell[l]{$\rhd$ leichtgewichtige Variante an Graphikprogrammen \\
	$\rhd$ \texttt{import java.awt.Applet;} \\
	$\rhd$ 1. Erstellen eigener Applet-Klasse (\texttt{extends Applet}) \\
	$\rhd$ 2. Überschreiben der Methode \texttt{paint} \\
	\hspace{0.8cm} \texttt{public void paint (Graphics graphics) \{...\}} \\
	\hspace{0.8cm} Klasse \texttt{Graphics} verknüpft Programm mit Zeichenfläche \\
	$\rhd$ 2.1 \texttt{GeomShape2D}-Array \\
	\hspace{0.8cm} \texttt{GeomShape2D pic = new GeomShape2D[3];} \\
	\hspace{0.8cm} Füllen des erstellten Arrays mit Formen (z.B.: \texttt{ new Circle(0,0,0);})\\
	$\rhd$ 2.2 Erstellen jeder Form mithilfe Randfarbe, Füllfarbe und Zeichnen \\
	\hspace{0.8cm} \texttt{pic[0].setBoundaryColor(Color.RED); // Randfarbe} \\
	\hspace{0.8cm} \texttt{pic[0].setFillColor(Color.RED);	  // Füllfarbe} \\
	\hspace{0.8cm} \texttt{pic[0].paint(graphics); // Eigentliches Zeichnen}} \\ \hline
	
	\makecell[l]{GeomShape2D} & \makecell[l]{$\rhd$ Abstrake Klasse (Methode \texttt{paint} ist abstrakt) \\
	$\rhd$ Attribute: \\
	\hspace{0.4cm} \texttt{int positionX; int positionY; int rotationAngle;} \\
	\hspace{0.4cm} \texttt{int transparencyValue; Color boundaryColor; Color fillColor;} \\
	$\rhd$ Subklassen: \texttt{Rectangle, Circle, StraightLine} } \\ \hline
	\end{tabular}


\section{Interfaces}
	\begin{tabular}{ | p{4cm} p{13.5cm} | }
	\hline
	\makecell[l]{Erzeugung} & \makecell[l]{$\rhd$ Meist in eigener Datei \\
	$\rhd$ \texttt{public interface MyInterface \{...\}} \\
	$\rhd$ Alle Methodes und das Interface \textbf{müssen} \texttt{public} sein \\ } \\ \hline
	
	\makecell[l]{Methoden} & 
	\makecell[l]{$\rhd$ Werden hier nicht implementiert, sondern nur definiert \\
	$\rhd$ \texttt{public} kann weggelassen werden, da ohnehin notwending \\
	$\rhd$ Implementierte Methoden müssen dann auch \texttt{public} sein \\
	$\rhd$ Falls eine der Methoden nicht implementiert wird $\Rightarrow$ Klasse abstrakt} \\ \hline
	
	\makecell[l]{Verwendung} & \makecell[l]{$\rhd$ \texttt{implements MyInterface} nach Klassenname  \\
	$\rhd$ Beliebig viele Interfaces möglich (seperiert durch ,) \\
	$\rhd$ Ein Interface kann mehrere andere Interfaces erweitern (\texttt{extends}} \\ \hline
	\end{tabular}

\section{JUnit-Tests}


\begin{tabular}{ | p{4cm} p{13.5cm} | }
	\hline

	\makecell[l]{Allgemein} & \makecell[l]{$\rhd$ Tests als Ganzes - Black-Box-Tests \\
	$\rhd$ JUnit-Tests werden in eine seperate Quelldatei geschrieben \\
	$\rhd$ Die zu testende Einheit/Klasse wird dann importiert } \\ \hline

	\makecell[l]{Imports} & \makecell[l]{
	$\rhd$ \texttt{import static org.junit.Assert.assertEquals;} \\
	$\rhd$ \texttt{import static org.junit.Assert.asserTrue;} \\
	$\rhd$ \texttt{import org.junit.jupiter.api.Test;} \\
	$\rhd$ \texttt{import org.junit.jupiter.api.BeforeEach;} \\
	$\rhd$ \texttt{import static org.junit.jupiter.api.Assertions.assertThrows;}} \\ \hline

	\makecell[l]{Methoden:} & 
	\makecell[l]{$\rhd$ \texttt{assertEquals(...,...); // \texttt{true}, falls beide Parameter identisch} \\
	\hspace{0.4cm} $\diamond$ Existiert auch mit 3 Parametern, 3. Wert entspricht maximalen Unterschied \\ 
	$\rhd$ \texttt{assertTrue(...); // \texttt{true}, falls der Parameter \texttt{true} ist} \\
	$\rhd$ \texttt{assertThrows(...,...); // Wirft Exception abhängig von Executable} \\
	\hspace{0.4cm} $\diamond$ Erster Parameter zu werfende Exception.class \\
	\hspace{0.4cm} $\diamond$ Zweiter Paramter Functional Interface aus dem Package java.lang.reflect } \\ \hline
	
	\makecell[l]{Test} & 
	\makecell[l]{$\rhd$ \texttt{@Test} vor der Methode \\
	$\rhd$ \texttt{void} als Rückgabewert \\
	$\rhd$ Nutzung einer \texttt{assert}-Methode (siehe Methoden)} \\ \hline

	\makecell[l]{BeforeEach} & \makecell[l]{$\rhd$ \texttt{@BeforeEach} vor der Methode \\
	$\rhd$ Wird vor jeder einzelnen Testmethode einmal ausgeführt  } \\ \hline
	
	
	
	\end{tabular}

\section{Klassen}

	\begin{tabular}{ | p{4cm} p{13.5cm} | }
	\hline
	\makecell[l]{Erzeugung} & \makecell[l]{$\rhd$ meist in seperater .java Datei  \\
	$\rhd$ \texttt{public class MyClass \{\}} \\
	$\rhd$ \texttt{new MyClass();}: \\
	\hspace{0.4cm} $\diamond$ Reserviert ausreichend Speicherplatz für das Objekt \\ 
	$\rhd$ \texttt{MyClass x = new MyClass();}: \\
	\hspace{0.4cm} $\diamond$ Speichern der Adresse des neuen Objekts in der Referenz x } \\ \hline
	
	\makecell[l]{Attribute} & \makecell[l]{$\rhd$ Eigenschaften der Objekte/Klassen \\
	$\rhd$ z.B.: \texttt{private int x;} (Objektattribut) \\
	$\rhd$ z.B.: \texttt{private static int x;} (Klassenattribut)  } \\ \hline
	
	\makecell[l]{Konstruktor} & 
	\makecell[l]{$\rhd$ Wird zur Erzeugung von neuen Objekten einer Klasse verwendet \\
	$\rhd$ Methode mit selben Namen wie Klasse und ohne Rückgabetyp \\
	$\rhd$ z.B.: \texttt{public MyClass (int x, int y) \{this.x = x; this.y = y;\}} \\
	$\rhd$ Erzeugung eines neuen Objekts: \texttt{MyClass test = new MyClass(2,4);} \\
	$\rhd$ Falls kein Konstruktur angegeben wird $\rightarrow$ Default Constructor \\
	\hspace{0.4cm} $\diamond$ Basisklasse muss auch Konstruktor mit leerer Parameterliste haben \\
	$\rhd$ Konstruktoren werden \texttt{nicht} vererbt \\
	$\rhd$ \texttt{Static Initializer} \\
	\hspace{0.4cm} $\diamond$ Methodenkopf besteht nur aus \texttt{static \{...\}} \\
	\hspace{0.4cm} $\diamond$ Wird genutzt um auf jeden Fall Klassenkonstanten zu initialisieren \\
	$\rhd$ Aufruf anderen Konstruktors in Konstruktor mit \texttt{this(Parameter);}} \\ \hline

	\makecell[l]{Abstraktion} & \makecell[l]{$\rhd$ \texttt{abstract public class MyClass \{...\}} \\
	$\rhd$ Notwendig, sobald Klasse eine abstrakte Methode beinhaltet \\
	$\rhd$ Keine Objekterzeugung möglich \\
	$\rhd$ Meist als Klasse mit Rahmenbedingungen für Subklassen verwendet }  \\ \hline
	
	\makecell[l]{Klasse aller Klassen} & \makecell[l]{$\rhd$ \texttt{java.lang.Object} \\
	$\rhd$ Jede Klasse ist direkt oder indirekt von \texttt{Object} abgeleitet \\
	$\rhd$ Methoden: \\
	\hspace{0.4cm} $\diamond$ \texttt{boolean equals (Object obj) \{...\} // Test auf Wertgleichheit} \\
	\hspace{0.4cm} $\diamond$ \texttt{String toString() \{...\} // Zustand des Objekts als String } \\
	\hspace{0.4cm} $\diamond$ Werden oft an jeweilige Klasse angepasst } \\ \hline
	
	\makecell[l]{Verborgene Informationen} & 
	\makecell[l]{$\rhd$ Jedes Objekt einer Klasse erhält einen Verweis auf ein anonymes Objekt \\
	$\rhd$ Dieses anonyme Objket wird für jede Klasse nur einmal eingerichtet \\
	$\rhd$ Enthät Informatiuonen zur Klasse, Attribute und Methoden der Klasse \\
	$\rhd$ Methodentabelle: \\
	\hspace{0.4cm} $\diamond$ Gibt an, welche Implementationen aller Methoden verwendet wird \\
	\hspace{0.4cm} $\diamond$ Ermöglicht, die Feststellung der Klasse zur Laufzeit \\
	\hspace{0.4cm} $\diamond$ Methode in Supertyp und Substyp haben den selben Index (Position) } \\ \hline
	
	\end{tabular}

\section{Konversionen}

	\begin{tabular}{ | p{4cm} p{13.5cm} | }
	\hline
	\makecell[l]{Implizit} & 
	\makecell[l]{$\rhd$ Immer möglich, wenn kein Informationsverlust entstehen kann \\
	$\rhd$ z.B.: kleinerer Datentyp in grö\ss eren } \\ \hline
	
	\makecell[l]{Explizit} & \makecell[l]{$\rhd$ Meist Informationsverlust \\
	$\rhd$ Durchführung durch Angabe des Datentyps in Klammern davor \\
	$\rhd$ z.B.: \texttt{int i = (int)testDouble;} } \\ \hline
	\end{tabular}


\section{Methoden}
	\begin{tabular}{ | p{4cm} p{13.5cm} | }
	\hline
	\makecell[l]{Methodenaufbau} & 
	\makecell[l]{$\rhd$  Modifier Rückgabewert Identifier (Parameterliste) \{Anweisung\} \\
	$\rhd$ Alles vor den Anweisung: Methodenkopf (Head) \\
	$\rhd$ Alles in den geschweiften Klammern: Methodenrumpf (Body) \\
	$\rhd$ z.B.: \texttt{public void setX (int x) \{this.x = x;\}} (Objektmethode) \\
	$\rhd$ z.B.: \texttt{public static void setY (int y) \{this.y = y;\}} (Klassenmethode) \\
	$\rhd$ \texttt{this.x} steht hier für das Objektattribut und nicht den Parameter} \\ \hline
	
	\makecell[l]{Ausführung} & \makecell[l]{$\rhd$ Objektmethoden: \texttt{myObject.setX(2);} \\
	$\rhd$ Klassenmethoden: \texttt{MyClass.setY(2);}} \\ \hline
	
	\makecell[l]{return} & 
	\makecell[l]{$\rhd$ Wird für Rückgabe bei Methoden mit Rückgabewert benötigt } \\ \hline
	
	\makecell[l]{Abstraktion} & \makecell[l]{$\rhd$ \texttt{abstract} vor Modifier (\texttt{z.B.: public)} \\
	$\rhd$ Abstrakte Methoden haben keinen Methodenrumpf } \\ \hline
	
	\makecell[l]{Parameter} & \makecell[l]{$\rhd$ Parameterliste in Definition: Formale Parameter \\
	$\rhd$ Parameterliste bei Methodenaufruf: Aktuale Parameter \\
	\hspace{0.4cm} $\diamond$ Kommt von actual $\Rightarrow$ tatsächlich, vorliegend \\
	$\rhd$ Verhalten bei Referenzen: \\
	\hspace{0.4cm} $\diamond$ Kopie der Adresse des Objekts bei Initialisierung des formalen durch \\
	\hspace{0.8cm} aktualen Parameter \\
	$\rhd$ Variable Parameterzahl: \\
	\hspace{0.4cm} $\diamond$ \texttt{void m (double... args) \{...\}} \\
	\hspace{0.4cm} $\diamond$ Drei Punkte deuten variable Parameteranzahl an \\
	\hspace{0.4cm} $\diamond$ Compiler macht aus den übergebenen Werten selbstständig ein Array \\
	\hspace{0.4cm} $\diamond$ Ermöglicht variable Anzahl von Werten \texttt{(1.42,2.7)} \\
	\hspace{0.4cm} $\diamond$ z.B.: Funktion, die das Maximum von übergebenen Variablen bestimmt} \\ \hline

	\makecell[l]{Signatur} & \makecell[l]{$\rhd$ Besteht aus Identifier und Parameterliste \\
	$\rhd$ Eine Klasse kann keine zwei Methoden mit derselben Signatur haben  } \\ \hline
	

	\makecell[l]{Klassenmethoden} & 
	\makecell[l]{$\rhd$ Wird mithilfe von \texttt{static} zwischen Modifier und Rückgabewert definiert \\
	$\rhd$ Klassenmethoden werden über den Klassennamen aufgerufen \\
	$\rhd$ \textbf{Nicht erlaubt:} Lesen und Schreiben von Objektmethoden und -Attributen \\
	$\rhd$ \textbf{Nicht erlaubt:} Objektmethoden aufrufen \\
	$\rhd$ \textbf{Erlaubt:} Klassenattribute lesen und schreiben \\
	$\rhd$ \textbf{Erlaubt:} Klassenmethoden aufrufen \\
	$\rhd$ Workaround: Objekt als Parameter übergeben \\
	$\rhd$ \texttt{static}-Import funktioniert auch bei Klassenmethoden \\
	$\rhd$ Die Implementation wird hier durch den statischen Typ bestimmt } \\ \hline
	
	\end{tabular}

\section{Optional (java.lang.Optional;)}
	\begin{tabular}{ | p{4cm} p{13.5cm} | }
	\hline
	
	\makecell[l]{Informationen} & \makecell[l]{$\rhd$ Objekt der Klasse \texttt{Optional} kapselt ein Objekt seines Typparameters ein \\
	$\rhd$ Bietet bequemem Umgang mit der Möglichkeit, dass eine Referenz \texttt{null} ist } \\ \hline

	\makecell[l]{Methoden} & \makecell[l]{
	\hspace{0.4cm} $\diamond$ \texttt{ofNullable} \\
	\hspace{0.6cm} - Bekommt ein Objekt oder \texttt{null} übergeben und kapselt dieses ein \\
	\hspace{0.6cm} - Gibt ein Objekt der Klasse \texttt{Optional} zurück \\
	\hspace{0.4cm} $\diamond$ \texttt{get} \\
	\hspace{0.6cm} - Liefert das eingekapselte Objekt zurück \\
	\hspace{0.6cm} - Falls \texttt{null}: \texttt{NoSuchElementException} \\
	\hspace{0.4cm} $\diamond$ \texttt{orElseGet} \\
	\hspace{0.6cm} - Zurücklieferung eines anderen Wertes vom Typparameter, falls \texttt{null} \\
	\hspace{0.6cm} - Formaler Parameter: \texttt{java.util.function.Supplier;} \\
	\hspace{0.4cm} $\diamond$ \texttt{ifPresent} \\
	\hspace{0.6cm} - Ausführung des Parameters, falls Objekt vorhanden (nicht \texttt{null}) \\
	\hspace{0.6cm} - Formaler Parameter: \texttt{java.util.function.Consumer;} \\
	\hspace{0.6cm} - z.B.: \texttt{opt1.ifPresent(x -> \{System.out.print(x);\});} \\
	\hspace{0.6cm} - z.B.: Falls \texttt{opt1} ein Objekt einkapselt, wird es ausgegeben \\
	\hspace{0.4cm} $\diamond$ \texttt{map} \\
	\hspace{0.6cm} - Abbildung basierend auf Paramter \\
	\hspace{0.6cm} - z.B.: \texttt{Optional<Number> opt2 = opt1.map(x -> x * x);} \\
	\hspace{0.6cm} - z.B.: Hier \texttt{opt2} auch \texttt{null}, da \texttt{opt1 == null} \\
	\hspace{0.4cm} $\diamond$ \texttt{filter} \\
	\hspace{0.6cm} - Liefert \texttt{Optional} vom selben generischen Typ zurück \\
	\hspace{0.6cm} - Formaler Parameter: \texttt{java.util.function.Predicate;} \\
	\hspace{0.6cm} - Filter \texttt{true}: Neues \texttt{Optional}-Objekt mit selbem Kapselinhalt \\ 
	\hspace{0.6cm} - Filter \texttt{false}: Leeres \texttt{Optional}-Objekt wird zurückgegeben \\
	\hspace{0.6cm} - z.B.: \texttt{Optional<Number> opt3 = opt1.filter(x -> x + 2 == 1);} \\
	\hspace{0.6cm} - Gibt selbes Objekt zurück, falls Gleichung erfüllt } \\ \hline

	\makecell[l]{Beispiel} & \makecell[l]{$\rhd$ \texttt{Optional<Number> opt1 = Optional.ofNullable(null);} \\
	$\rhd$ \texttt{Number n1 = opt1.get(); // NoSuchElementException} \\
	$\rhd$ \texttt{Number n2 = opt1.orElseGet(() -> 0); // Falls null -> 0}  } \\ \hline
	
	\end{tabular}

\section{Packages und Zugriffsrechte}
	\begin{tabular}{ | p{4cm} p{13.5cm} | }
	\hline
	
	\makecell[l]{Package} & \makecell[l]{$\rhd$ Zusammenfassung von mehreren Dateien \\
	$\rhd$ Wird zur Gruppierung von ähnlichen Funktionalitäten verwendet \\
	$\rhd$ Ermöglicht selbe Dateinamen in unterschiedlichen Packages \\
	$\rhd$ Bestehen nur aus Kleinbuchstaben \\
	$\rhd$ Am Anfang der Quelldatei: \texttt{package mypackage;} \\
	\hspace{0.4cm} $\diamond$ Datei gehört damit zum Package \texttt{mypackage} \\
	\hspace{0.4cm} $\diamond$ \texttt{mypackage} wird automatisch importiert } \\ \hline
	
	\makecell[l]{Import} & \makecell[l]{
	$\rhd$ \texttt{import package.*;} \\
	$\rhd$ \texttt{*} steht für alle Definitionen aus \texttt{package} \\
	$\rhd$ \texttt{*} importiert aber nicht die Inhalte von Subpackages \\
	$\rhd$ Import-Anweisungen müssen immer am Anfang des Quelltextes stehen \\
	$\rhd$ Durch Importanweisungen sind Teile danach nur noch mit Namen ansprechbar \\
	$\rhd$ Wichtigstes Package: \texttt{java.lang.*} (automatisch importiert) \\
	$\rhd$ Konstanten: \texttt{import static java.lang.Math.PI;} \\
	\hspace{0.4cm} $\diamond$ Ermöglicht Schreiben von \texttt{PI} statt \texttt{Math.PI}} \\ \hline
	
	\makecell[l]{Zugriffsrechte} & \makecell[l]{$\rhd$ Klassen/Enum: nur \texttt{public} oder nichts \\
	\hspace{0.4cm} $\diamond$ Nur eine Klasse darf \texttt{public} sein (Damit auch Dateiname) \\
	$\rhd$ \texttt{private:} Zugriff innerhalb der Klasse \\
	$\rhd$ \texttt{Keine Angabe:} \texttt{private} + im Package \\
	$\rhd$ \texttt{protected:} \texttt{Keine Angabe} + in allen Subklassen \\
	$\rhd$ \texttt{public:} \texttt{protected} + an jeder Import-Stelle } \\ \hline
	\end{tabular}



\section{Programme und Prozesse}

	\begin{tabular}{ | p{4cm} p{13.5cm} | }
	\hline
	\makecell[l]{Quelltest} & \makecell[l]{$\rhd$ z.B. selbst geschriebener Java-Code } \\ \hline
	
	\makecell[l]{Java-Bytecode} & \makecell[l]{$\rhd$ Wird durch Übersetzung des Java-Quelltextes erzeugt 
	} \\ \hline
	
	\makecell[l]{Programm} & \makecell[l]{$\rhd$ Sequenz von Informationen} \\ \hline
		
	\makecell[l]{Aufruf eines Programms} & \makecell[l]{$\rhd$ Starten eines Prozesses, 
	der die Anweisungen des	Programmes abarbeitet } \\ \hline
	
	\makecell[l]{Prozesse} & \makecell[l]{$\rhd$ CPU besteht aus mehreren Prozessorkernen \\
	$\rhd$ Mehrere Prozesse laufen dementsprechend parallel \\
	$\rhd$ Allerdings bearbeitet jeder Kern nur einen Prozess gleichzeitig (sehr kurz) \\
	\hspace{0.4cm}$\diamond$ Illusion von Multitasking } \\ \hline
	\end{tabular}

\section{Random (java.util.Random;)}
	\begin{tabular}{ | p{4cm} p{13.5cm} | }
	\hline
	\makecell[l]{Verwendung} & \makecell[l]{$\rhd$ Erzeugung eines neuen Objekts \\
	\hspace{0.4cm} $\diamond$ \texttt{Random random = new Random();} \\
	$\rhd$ Zahlenerzeugung mithilfe von: \\
	\hspace{0.4cm} $\diamond$ \texttt{random.nextInt();} \\
	\hspace{0.4cm} $\diamond$ \texttt{random.nextLong();} \\
	\hspace{0.4cm} $\diamond$ \texttt{random.nextFloat();} \\
	\hspace{0.4cm} $\diamond$ \texttt{random.nextDouble();} \\
	$\rhd$ Bei \texttt{float} und \texttt{double}: Zwischen 0 und 0.1 \\
	$\rhd$ Bei \texttt{int} und \texttt{long}: Zahl aus Wertebereich } \\ \hline

	\makecell[l]{Methoden} & \makecell[l]{
	$\rhd$ \texttt{nextInt(), nextDouble(),..} \\
	\hspace{0.4cm} $\diamond$ Generierung von Zufallszahlen \\
	$\rhd$ \texttt{ints(), longs(), doubles()} \\
	\hspace{0.4cm} $\diamond$ Liefern jeweils Stream mit zufälligen Zahlen zurück \\
	\hspace{0.4cm} $\diamond$ In diesem Fall unendliche Länge \\
	\hspace{0.4cm} $\diamond$ Werden in Verbindung mit IntStreams (etc..) verwendet } \\ \hline
	
	\end{tabular}
	
\section{Schleifen, if, switch}

	\begin{tabular}{ | p{4cm} p{13.5cm} | }
	\hline
	\makecell[l]{while-Schleife} & \makecell[l]{$\rhd$ \texttt{while (Bedingung) \{Anweisung;\}} \\ 
	$\rhd$ Schleife wird ausgeführt, solange die Bedingung wahr ist \\ 
	$\rhd$ \{\} kann bei einzelner Anweisung auch weggelassen werden } \\ \hline
	
	\makecell[l]{do-while-Schleife} & 
	\makecell[l]{$\rhd$ \texttt{do \{Anweisung;\} while (Bedingung);} \\ 
	$\rhd$ Anweisungsblock wird immer mindestens einmal ausgeführt } \\ \hline
	
	\makecell[l]{for-Schleife} & 
	\makecell[l]{$\rhd$ \texttt{for (Anweisung davor; Bedingung; Anweisung danach) \{Anweisung\}} \\
	$\rhd$ z.B.: \texttt{for (int i = 0; i < 10; i++) \{...\}} \\
	\hspace{0.4cm}$\diamond$ Zehnmalige Ausführung der Anweisung \\
	$\rhd$ Kurzform: \texttt{for (Position p : positions) \{\}} \\
	\hspace{0.4cm} $\diamond$ (Komponententyp Identifier : ArrayName)  } \\ \hline
	
	\makecell[l]{if-Anweisung} & \makecell[l]{$\rhd$ \texttt{if (Bedingung) \{...\}} \\
	\hspace{0.4cm} $\diamond$ Führt den Code in der Anweisung nur aus, falls die Bedingung erfüllt ist \\
	$\rhd$ \texttt{if (Bedingung) \{\} else \{\}} \\
	\hspace{0.4cm} $\diamond$ Code, der ausgeführt wird, falls Bedingung nicht erfüllt ist} \\ \hline

	\makecell[l]{switch-Anweisung} & \makecell[l]{$\rhd$ Abfrage von mehreren Fällen \\
	$\rhd$ \texttt{switch (i) \{ case 2: ... break; case 3: ... break; default: ... \}} \\
	$\rhd$\texttt{break;} Ohne break, geht es mit der Anweisung für den nächsten Fall weiter \\
	$\rhd$ Keine Variablen als Abfragen für Fälle / kein Ausdruck, nur EIN Wert \\
	$\rhd$ \texttt{default} wird dann ausgeführt, wenn kein anderer Fall eintritt}  \\ \hline

	\end{tabular}

	
\section{Streams (java.util.stream.Stream;)}
	\begin{tabular}{ | p{4cm} p{13.5cm} | }
	\hline
	
	\makecell[l]{Information} & \makecell[l]{$\rhd$ Generisches Interface \texttt{Stream} \\
	$\rhd$ Einheitliche Schnittstelle für Listen, Arrays, Dateien \\
	$\rhd$ Relevante Kapitel: \texttt{Optional} \\
	} \\ \hline

	\makecell[l]{Methodenzusammenfassung} & \makecell[l]{$\rhd$ filter, map, max, of \\
	$\rhd$ \texttt{filter} \\
	\hspace{0.4cm} $\diamond$ Liefert Stream vom selben generischen Typ zurück \\
	\hspace{0.4cm} $\diamond$ Formaler Parameter: \texttt{java.util.function.Predicate;} \\
	$\rhd$ \texttt{map} \\
	\hspace{0.4cm} $\diamond$ Liefert Stream von evtl. anderem Typparameter zurück \\
	\hspace{0.4cm} $\diamond$ Dieser Typ ist abhängig vom aktualen Parameter \\
	\hspace{0.4cm} $\diamond$ Formaler Parameter: \texttt{java.util.function.Function;} \\
	$\rhd$ \texttt{max} \\
	\hspace{0.4cm} $\diamond$ Liefert nur einzelnes Element zurück abhängig vom \texttt{Comparator} \\
	$\rhd$ \texttt{of} \\
	\hspace{0.4cm} $\diamond$ Dient der direkten Erzeugung von Streams \\
	\hspace{0.4cm} $\diamond$ Beliebige Anzahl an Parametern des Typarameters \\
	\hspace{0.4cm} $\diamond$ Rückgabe eines Streams mit diesen Elementen \\
	\hspace{0.4cm} $\diamond$ z.B.: \texttt{Stream<Number>.of(new Integer(2), new Integer(3));} \\
	$\rhd$ \texttt{reduce} \\
	\hspace{0.4cm} $\diamond$ Erstellt aus allen Elementen des Streams ein einzelnes Ergebnis \\
	\hspace{0.4cm} $\diamond$ Durch sukzessiven Aufruf der Funktion im aktualen Parameter \\
	\hspace{0.4cm} $\diamond$ z.B.: \texttt{String fileContent = stream.reduce(String::concat);} } \\ \hline

	\makecell[l]{Stream aus Liste} & \makecell[l]{
	$\rhd$ \texttt{List<Number> list = new LinkedList<Number>(); // Erstellt Liste}	\\
	$\rhd$ \texttt{Stream<Number> stream1 = list.stream();} \\
	\hspace{0.4cm} $\diamond$ Liefert Stream vom selben generischen Typ \\
	\hspace{0.4cm} $\diamond$ Methode der Klasse \texttt{List} \\
	$\rhd$ \texttt{... stream1.filter(myPred); // Anwenden eines Filter} \\
	$\rhd$ \texttt{... stream1.map(myFct); // Anwenden einer Abbildung} \\
	$\rhd$ \texttt{Optional<Number> opt = stream.max(new MyComp());} \\
	\hspace{0.4cm} $\diamond$ Hier \texttt{Optional}, da der Stream auch leer sein kann \\
	$\rhd$ Methoden wie \texttt{filter} und \texttt{map} werden \textbf{intermediate operations} genannt \\
	$\rhd$ Methoden wie \texttt{max} werden \textbf{terminal operations} genannt \\
	$\rhd$ Zusammenfassung dieser Operationen möglich: \\
	$\rhd$ \texttt{... =  list.stream().filter(myPred).map(myFct).max(new MyComp());} } \\ \hline

	\makecell[l]{Stream aus Array} & \makecell[l]{$\rhd$ \texttt{Number[] a = new Number[100]; // Erstellt Array} \\
	$\rhd$ \texttt{Stream<Number> stream1 = Arrays.stream(a); // Erzeugt Stream} \\
	\hspace{0.4cm} $\diamond$ Aufruf der \texttt{Arrays}-Klassenmethoden \texttt{stream(Array a)} } \\ \hline

	\makecell[l]{Iterator} & \makecell[l]{$\rhd$ \texttt{Iterator iter = stream.iterator(); // Erzeugt Iterator Objekt} \\
	$\rhd$ \texttt{iter.hasNext() // Verwendung als Abbruchbedingung} \\
	$\rhd$ \texttt{iter.next() // Zum Fortschreiten im Iterator}  } \\ \hline

	\makecell[l]{Liste aus Stream} & \makecell[l]{$\rhd$ \texttt{List<String> list = stream.collect(Collectors.toList());} \\
	\hspace{0.4cm} $\diamond$ \texttt{Collectors} besitzt viele Klassenmethoden zur Verarbeitung von Streams \\
	\hspace{0.4cm} $\diamond$ \texttt{toList()} liefert das generische Interface \texttt{Collector} } \\ \hline

	\makecell[l]{Array aus Stream} & \makecell[l]{$\rhd$ \texttt{Number[] a = stream.toArray(Number[]::new);} \\
	$\rhd$ Art der Erzeugung abhängig vom Parameter \\
	$\rhd$ Parameter: Siehe Methodennamen als Lambda-Ausdrücke } \\ \hline %% TOOOOOODOOOOOOOOOO!!!!

	\makecell[l]{Int-/Long-/\\ DoubleStreams} & \makecell[l]{$\rhd$ Methoden sind genau diesselben wie bei normalen Streams \\
	$\rhd$ z.B.: \texttt{IntStream stream1 = IntStream.of(1,2,3);} \\
	$\rhd$ Nutzen der Klasse \texttt{Random} für unendlichen Stream mit Zufallszahlen \\
	\hspace{0.4cm} $\diamond$ \texttt{IntStream stream1 = new Random().ints();}} \\ \hline

	
	
	
	\end{tabular}
	
\section{String (java.lang.String)}	
	\begin{tabular}{ | p{4cm} p{13.5cm} | }
	\hline
	\makecell[l]{Eigenschaften} & \makecell[l]{$\rhd$ Sonderrolle, da Klasse, aber trotzdem Literale in Java \\
	$\rhd$ Zeichenketten, die aus allen möglichen chars bestehen} \\ \hline
	
	\makecell[l]{Methoden:} & \makecell[l]{$\rhd$ \texttt{String str = "Hello World";} \\
	\hspace{0.8cm} $\diamond$ \texttt{str.length; // 11} \\
	\hspace{0.8cm} $\diamond$ \texttt{str.charAt(2); // e} \\
	\hspace{0.8cm} $\diamond$ \texttt{str.indexOf('e'); // 2} \\
	\hspace{0.8cm} $\diamond$ \texttt{str.matches("He.+rld"); // true} \\
	\hspace{1.5cm} \texttt{.+} $\Rightarrow$ \texttt{.} als Platzhalter für beliebiges Zeichen, 
	\texttt{+} erlaubt Wiederholung \\ 
	\hspace{2.03cm} $\Rightarrow$ Regular Expression \\
	\hspace{0.8cm} $\diamond$ \texttt{String str 2 = str.concat("b"); // Anhängen } \\
	\hspace{0.8cm} $\diamond$ \texttt{String str 2 = str1 + "b"; // Kurzform}  } \\ \hline
	\end{tabular}
	
\section{Syntax}

	\begin{tabular}{ | p{4cm} p{13.5cm} | }
	\hline
	\makecell[l]{Keywords} & \makecell[l]{$\rhd$ Können nur an bestimmten Stellen im Code stehen \\
	$\rhd$ z.B. \texttt{class, import, public, while,..}} \\ \hline
	
	\makecell[l]{Identifier} & \makecell[l]{$\rhd$ Namen für Klassen, Variablen, Methoden,.. \\
	$\rhd$ Erstes Zeichen darf keine Ziffer sein \\
	$\rhd$ Keine Keywords als Identifier
	$\rhd$ Identifier sind case-sensitive } \\ \hline
	
	\makecell[l]{Konventionen} & \makecell[l]{
	$\rhd$ Variablen / Methoden beginnen mit Kleinbuchstaben (\texttt{testInt}) \\
	$\rhd$ Klassen beginnen mit Gro\ss buchstaben (\texttt{testClass}) \\
	$\rhd$ Wortanfänge im Inneren mit Gro\ss buchstaben \\
	$\rhd$ Konstanten bestehen aus $\_$ und Gro\ss buchstaben (\texttt{CENTS$\_$PER$\_$EURO}) \\
	$\rhd$ Packagenamen nur aus Kleinbuchstaben und \_ bei unzulässigen Zeichen} \\ \hline
	
	\makecell[l]{Kommentare} & \makecell[l]{$\rhd$ \texttt{//} Einzelne Zeile \\
	$\rhd$ \texttt{/*...*/} Mehrere Zeilen \\
	$\rhd$ \texttt{/**...*/} Erzeugung von Javadoc }  \\ \hline

	\makecell[l]{Javadoc} & \makecell[l]{$\rhd$ Erzeugung mithilfe von \texttt{/**} und Enter \\
	$\rhd$ Bei Methodenköpfen: \\
	\hspace{0.4cm} $\diamond$ \texttt{@param x the dividend} \\
	\hspace{0.4cm} $\diamond$ \texttt{@return x divided by x}  \\
	\hspace{0.4cm} $\diamond$ \texttt{@throws class IndexOutOfBoundsException if c is not an int} \\
	$\rhd$ Bei Quelldateien: \\
	\hspace{0.4cm} $\diamond$ \texttt{@author} \\
	\hspace{0.4cm} $\diamond$ \texttt{@version}} \\ \hline

	\makecell[l]{Rechtsausdrücke} & \makecell[l]{$\rhd$ Haben Typ und Wert \\
	$\rhd$ z.B.: \texttt{2*3+1}  } \\ \hline

	\makecell[l]{Linksausdrücke} & \makecell[l]{$\rhd$ Verweisen auf Speicherstellen \\
	$\rhd$ z.B.: \texttt{int n}   } \\ \hline

	\end{tabular}
	
\section{Vererbung}
	\begin{tabular}{ | p{4cm} p{13.5cm} | }
	\hline
	\makecell[l]{Zweck} & \makecell[l]{$\rhd$ Weitergabe von allen Methoden und Attributen } \\ \hline
	
	\makecell[l]{Verwendung} & 
	\makecell[l]{$\rhd$ \texttt{public class MySubClass extends MyClass \{\}} } \\ \hline
	
	\makecell[l]{Konstruktor} & 
	\makecell[l]{$\rhd$ Aufruf des Konstruktors der Superklasse mithilfe von \texttt{super(Parameter);} \\
	$\rhd$ Dieser Aufruf erfolgt im Konstruktor der Subklasse \\
	$\rhd$ z.B.: \texttt{public MySubClass (int x) \{ super(x);<v\}}} \\ \hline
	
	\makecell[l]{Overwrite} & \makecell[l]{$\rhd$ Methoden in Subklassen können auch neu geschrieben werden \\
	\hspace{0.4cm} $\diamond$ Die Implementation der Superklasse wird sozusagen überschrieben \\
	$\rhd$ Selber Name und Parameterliste notwendig \\
	$\rhd$ Signatur der Methoden muss identisch sein \\
	\hspace{0.4cm} $\diamond$ Die anderen Bestandteile können variieren: \\
	\hspace{0.4cm} $\diamond$ Zugriffsrechte dürfen in abgeleiteter Klasse erweitert sein \\
	\hspace{0.4cm} $\diamond$ private $\rightarrow$ $\epsilon$ $\rightarrow$ protected $\rightarrow$ public \\
	\hspace{0.4cm} $\diamond$ Bei Referenztypen Rückgabetyp durch Subtyp ersetzbar \\
	\hspace{0.4cm} $\diamond$ Exceptionklassen durch Subtypen ersetzbar \\
	$\rhd$ Aufruf der überschriebenen Methode mit \texttt{super.m();} \\
	$\rhd$ Exceptions: \\
	\hspace{0.4cm} $\diamond$ Exception Klasse darf durch Subtyp ersetzt werden} \\ \hline
	
	\makecell[l]{Overload} & 
	\makecell[l]{$\rhd$ Methoden mit selbem Bezeichner, aber unterschiedlicher Parameterliste \\
	$\rhd$ Die Methode wird überladen \\ 
	$\rhd$ Konstruktoren kann man auch überladen \\
	\hspace{0.4cm} $\diamond$ Für manche Werte werden dann Standardwerte gesetzt \\
	\hspace{0.4cm} $\diamond$ Anderer Konstruktor auch in Konstruktor aufrufbar (\texttt{this(1);}) \\
	$\rhd$ Alle Methoden einer Klasse müssen unterschiedliche Signatur haben } \\ \hline
		
	\makecell[l]{Subtypen} & \makecell[l]{$\rhd$ Abgeleitete Klassen / Interfaces (\texttt{extends}) \\
	$\rhd$ Überall wo ein Referenztyp (Supertyp) erwartet wird: \\
	\hspace{0.4cm} $\diamond$ Verwendung eines Objekts eines Subtyps möglich \\
	\hspace{1.2cm} in Zuweisung an Variable \\
	\hspace{1.2cm} als Parameterwert \\
	\hspace{1.2cm} als Rückgabewert	} \\ \hline
	
	
	\makecell[l]{Statischer Typ} & \makecell[l]{$\rhd$ Der Typ, mit dem Referenz definiert wird \\
	$\rhd$ Statischer Typ unveränderlich mit Referenz verknüpft $\Rightarrow$ statisch \\
	$\rhd$ z.B.: \texttt{X a = new Y();} $\Rightarrow$ \texttt{X} hier statischer Typ \\
	$\rhd$ \textbf{Entscheidet}, auf welche Attribute/Methoden zugegriffen werden darf \\
	\hspace{0.4cm} $\diamond$ Müssen im statischen Typ vorhanden sein (definiert oder ererbt)\\
	 } \\ \hline
	
	\makecell[l]{Dynamischer Typ} & 
	\makecell[l]{$\rhd$ Der Typ des Objekts einer Referenz, auf das diese Referenz \\
	$\rhd$ Muss gleich dem statischen Typ oder ein Subtyp des statischen Typs sein \\
	$\rhd$ Kann sich beliebig häufig ändern $\Rightarrow$ dynamisch \\
	$\rhd$ z.B.: \texttt{X a = new Y();} $\Rightarrow$ \texttt{Y} hier dynamischer Typ \\
	$\rhd$ \textbf{Entscheidet}, welche Implementation der Methode aufgerufen wird} \\ \hline
	
	\makecell[l]{Downcast} & \makecell[l]{$\rhd$ \texttt{if (y instanceof X) \{...\}} \\
	\hspace{0.4cm} $\diamond$ Gibt \texttt{true} zurück, falls \texttt{y} (Variable von Referenztyp) gleich 
	dem Typen \\
	\hspace{0.7cm}  von \texttt{X} oder ein Subtyp von \texttt{X} ist \\
	$\rhd$ Downcast \\
	\hspace{0.4cm} $\diamond$ Vorherige Überprüfung mit \texttt{isinstanceof} \\
	\hspace{0.4cm} $\diamond$ Ermöglicht z.B.: \texttt{X z;} \\
	\hspace{3.6cm} \texttt{z = (X) y;} \\
	\hspace{0.4cm} $\diamond$ 
	\textbf{Warum?} Zugriff auf Funktionen, die nicht im statischen Typ existieren } \\ \hline	
	
	\makecell[l]{Garbage Collector} & \makecell[l]{$\rhd$ Teil des Laufzeitsystems \\
	$\rhd$ Wird selbstständig aufgerufen, um Objekte ohne Referenz zu löschen \\
	$\rhd$ Kann zwecks Laufzeitoptimierung konfiguriert werden} \\ \hline
	
	\end{tabular}


\end{document}