\input{../reference_sheet_preamble}

\renewcommand{\arraystretch}{1.75} 

\begin{titlepage}
  \title{Racket Reference Sheet} % document_name-type_of_document
  \author{Jonas Milkovits}
  \date{Last Edited: \today}
\end{titlepage}

\begin{document}

\pagenumbering{gobble}
\maketitle
\pagenumbering{roman} % i, ii, iii on beginning pages, that don't have content
\tableofcontents
\clearpage
\pagenumbering{arabic} % 1,2,3 on content pages

\section{Einleitung: Funktionales Programmiern}

  \begin{tabular}{ | p{0.2\textwidth} p{0.75\textwidth} | } 
  \hline 
  
  \makecell[l]{Funktionale \\ Programmierkonzepte} & \makecell[l]{
  $\triangleright$ Auch \texttt{Java} enthält auch funktionale Konzepte \\
  $\triangleright$ Unser gewähltes Beispiel: \texttt{HtDP-TL} \\
  \hspace{0.4cm} $\diamond$ Dialekt von \texttt{Racket} \\
  \hspace{0.4cm} $\diamond$ \texttt{Racket} Dialekt von \texttt{Scheme} \\
  $\triangleright$ Wir sprechen hier aber der Einfachheit halber von \texttt{Racket}} \\ \hline
  
  \makecell[l]{Funktionales \\ Programmieren} & \makecell[l]{
  $\triangleright$ Funktionen sind zentrale Bausteine \\
  \hspace{0.4cm} $\diamond$ $f: D_1 ~ x ~ D_2 ~ x ~ ... ~ x ~ D_n \rightarrow R$ \\
  $\triangleright$ Programmdesign \\
  \hspace{0.4cm} $\diamond$ Zerlegung der zu erstellenden Funktionalität in Funktionen \\
  \hspace{0.4cm} $\diamond$ Funktionen rufen andere grundlegende Funktionen auf \\
  $\triangleright$ Funktionen werden variiert durch Parameter, die auch Funktionen sind } \\ \hline

  \makecell[l]{Deklaratives \\ Programmieren} & \makecell[l]{
  $\triangleright$ Grö\ss ere Sprachfamilie \\
  \hspace{0.4cm} $\diamond$ Funktionales Programmieren: Untersprache \\
  $\triangleright$ Grundsätzlicher Gedanke des deklarativen Programmierens: \\
  \hspace{0.4cm} $\diamond$ Nur Angabe der "Formel" für das Ergebnis \\
  \hspace{0.4cm} $\diamond$ Nicht Angabe der Befehle, die ausgeführt werden sollen \\
  $\triangleright$ \texttt{Java}: imperativer Programmierstil \\
  $\triangleright$ Konsequenzen: \\
  \hspace{0.4cm} $\diamond$ Keine zeitlichen Abläufe \\
  \hspace{0.4cm} $\diamond$ Keine Vererbungskonzepte/Objektidentität \\
  $\triangleright$ Jeder Aufruf einer Funktion kann durch den Rückgabewert ersetzt werden \\
  $\triangleright$ Funktion liefert für selbe Parameter \textbf{immer} das selbe Ergebnis \\
  $\triangleright$ Funktionen haben nur Rückgabewerte, keine Seiteneffekte \\
  $\triangleright$ Fachbegriff: \texttt{referenzielle Transparenz} } \\ \hline

  \end{tabular}




\section{Datentypen} 

  \begin{tabular}{ | p{0.2\textwidth} p{0.75\textwidth} | } 
  \hline 
  
  \makecell[l]{Zahlen (number)} & \makecell[l]{
  $\triangleright$ Exakte Zahlen: \\
  \hspace{0.4cm} $\diamond$ ganzzahlig: \texttt{123} \\
  \hspace{0.4cm} $\diamond$ rational: \texttt{3/5} \\
  $\triangleright$ Nichtexakte Zahlen: \\
  \hspace{0.4cm} $\diamond$ \texttt{(sqrt 2)} \\
  \hspace{0.6cm} - Setzen in Klammern, da "Funktionsaufruf" \\
  \hspace{0.4cm} $\diamond$ Ergebnisdarstellung mit \texttt{\#i} vor Zahl \\
  \hspace{0.6cm} - \texttt{(sqrt 5) ; \#i6.480...} \\
  $\triangleright$ Komplexe Zahlen: \\
  \hspace{0.4cm} $\diamond$ \texttt{3.14159+3/5i} \\
  \hspace{0.4cm} $\diamond$ Realteil + Imaginärteil + i} \\ \hline 

  \makecell[l]{Symbole} & \makecell[l]{
  $\triangleright$ Symbol steht für nichts, hat nur für Programmierer eine Bedeutung \\ 
  $\triangleright$ Erzeugung: \\
  \hspace{0.4cm} $\diamond$ \texttt{(define last-name 'Spielberg)} \\
  $\triangleright$ Funktionen: \\
  \hspace{0.4cm} $\diamond$ \texttt{(symbol=? 'Hello 'World)} \\
  \hspace{0.6cm} - Liefert genau dann \texttt{\#t}, falls beide Symbole gleich sind \\
  $\triangleright$ Vergleich auf Gleichheit: \texttt{(symbol=? param1 param2)}} \\ \hline

  \makecell[l]{Boolean} & \makecell[l]{
  $\triangleright$ \texttt{\#t} für \texttt{true} \\
  $\triangleright$ \texttt{\#f} für \texttt{false} \\
  $\triangleright$ Boolesche Verknüpfungsoperatoren: \\
  \hspace{0.4cm} $\diamond$ Veroderung: \texttt{(or b1 b2 b3)} \\
  \hspace{0.4cm} $\diamond$ Verundung: \texttt{(and b1 b2 b3)} \\
  \hspace{0.4cm} $\diamond$ Negation: \texttt{(not b1)} \\
  $\triangleright$ Vergleichsoperatoren: \\
  \hspace{0.4cm} $\diamond$ \texttt{(= x1 x2 x3) ; (and (= x1 x2)(= x2 x3))} \\
  \hspace{0.4cm} $\diamond$ \texttt{(< x1 x2 x3) ; (and (< x1 x2)(< x2 x3))} \\
  \hspace{0.4cm} $\diamond$ \texttt{(<= x1 x2 x3)} \\
  $\triangleright$ Boolsche Funktionen \\
  \hspace{0.4cm} $\diamond$  \texttt{(integer? value)} \\
  \hspace{0.6cm} - Liefert \texttt{\#t} zurück, falls \texttt{value} ganzzahlig \\
  \hspace{0.6cm} - z.B. \texttt{(if (integer? (- x y)) \#t \#f)} \\
  \hspace{0.4cm} $\diamond$ \texttt{(number? value)} \\
  \hspace{0.6cm} - \texttt{\#t}, falls \texttt{value} eine Zahl ist \\
  \hspace{0.4cm} $\diamond$ \texttt{(real? value)} \\
  \hspace{0.6cm} - \texttt{\#t}, falls \texttt{value} keine imaginäre Zahl ist \\
  \hspace{0.4cm} $\diamond$ \texttt{(rational? value)} \\
  \hspace{0.6cm} - \texttt{\#t}, falls \texttt{value} eine rationale Zahl ist \\
  \hspace{0.4cm} $\diamond$ \texttt{(natural? value)} \\
  \hspace{0.6cm} - \texttt{\#t}, falls \texttt{value} natürliche Zahl \\
  \hspace{0.4cm} $\diamond$ \texttt{(symbol? value)} \\
  \hspace{0.6cm} - \texttt{\#t}, falls \texttt{value} ein Symbol ist \\
  \hspace{0.4cm} $\diamond$ \texttt{(empty? list)} \\
  \hspace{0.6cm} - \texttt{\#t}, falls \texttt{list} leer ist \\
  \hspace{0.4cm} $\diamond$ \texttt{(struct-name? value)} \\
  \hspace{0.6cm} - \texttt{\#t}, falls \texttt{value} vom Typ des \texttt{Structs} \texttt{struct-name} ist} \\ \hline
  
  \end{tabular}

\section{filter, map und fold}

  \begin{tabular}{ | p{0.2\textwidth} p{0.75\textwidth} | } 
  \hline 
  
  \makecell[l]{\texttt{filter}} & \makecell[l]{
  $\triangleright$ Fitlerung gewisser Elemente aus einer Liste mittels Prädikat \\
  $\triangleright$ Vertrag: \texttt{(X -> boolean) (list of X) -> (list of X)} \\
  $\triangleright$ \texttt{(filter pred list)} \\
  \hspace{0.4cm} $\diamond$ Übergabe des Prädikats als ersten Parameter \\
  \hspace{0.4cm} $\diamond$ Parameter des Prädikats muss hier von \texttt{X} sein \\
  \hspace{0.4cm} $\diamond$ Übergabe der Liste als zweiten Parameter \\
  $\triangleright$ Lambda-Beispiel: \\
  \hspace{0.4cm} $\diamond$ \texttt{(filter (lambda (x) -> (< x 10)) list1)} \\
  \hspace{0.6cm} - Gibt Liste zurück mit Werten kleiner gleich 10 \\
  \hspace{0.4cm} $\diamond$ Verträge bei Verwendung solcher Lambda-Funktionen notwendig \\
  \hspace{0.6cm} - z.B. innerhalb der verwendenden Methode} \\ \hline  
  
  \makecell[l]{\texttt{map}} & \makecell[l]{
  $\triangleright$ Abbildung von Werten auf einen anderen Wert \\
  $\triangleright$ Vertrag: \texttt{(X -> Y) (list of X) -> (list of Y)} \\
  $\triangleright$ \texttt{(map fct list)} \\
  \hspace{0.4cm} $\diamond$ Übergabe der anzuwendenden Funktion als ersten Parameter \\
  \hspace{0.4cm} $\diamond$ Übergabe der Liste als zweiten Parameter \\
  $\triangleright$ Lambda-Beispiel: \\
  \hspace{0.4cm} $\diamond$ \texttt{(map (lambda(x) -> (* x 10)) list1)} \\
  \hspace{0.6cm} - Multipliziert alle Werte der Liste mit 10 \\
  \hspace{0.4cm} $\diamond$ Vertrag genau wie bei \texttt{filter} } \\ \hline

  \makecell[l]{\texttt{fold}} & \makecell[l]{
  $\triangleright$ Faltungsoperation, in Racket \texttt{lfold} und \texttt{rfold} \\
  \hspace{0.4cm} $\diamond$ \texttt{lfold}: von links nach rechts \\
  \hspace{0.4cm} $\diamond$ \texttt{rfold}: von rechts nach links \\
  $\triangleright$ Faltungsoperation rechnet alle Werte nach Berechnungsvorschrift zusammen \\
  $\triangleright$ Vertrag: \texttt{X (X Y -> X) (list of Y) -> X} \\
  $\triangleright$ (rfold init fct list) \\
  \hspace{0.4cm} $\diamond$ Übergabe des Startwerts als ersten Parameter \\
  \hspace{0.4cm} $\diamond$ Übergabe der Funktion als zweiten Parameter \\
  \hspace{0.4cm} $\diamond$ Übergabe der Liste als dritten Parameter \\
  $\triangleright$ Lambda-Beispiel: \\
  \hspace{0.4cm} $\diamond$ \texttt{(rfold 0 (lambda (x,y) -> (+ x y)) list1)} \\
  \hspace{0.6cm} - Rechnet alle Werte der Liste zu einem einzigen Wert mit \texttt{+} zusammen \\
  \hspace{0.4cm} $\diamond$ Vertrag genau wie bei \texttt{filter} \\
  $\triangleright$ Bei Listen Verwendung von \texttt{empty} als Initialwert} \\ \hline

  \end{tabular}

\section{Funktionen} 

  \begin{tabular}{ | p{0.2\textwidth} p{0.75\textwidth} | } 
  \hline 
  
  \makecell[l]{Erzeugung} & \makecell[l]{
  $\triangleright$ \texttt{(define (name param1 param2) (Ausdruck)) ; Funktion}   \\
  \hspace{0.4cm} $\diamond$ z.B. \texttt{(define (add x y) (+ x y))} \\
  \hspace{0.4cm} $\diamond$ \texttt{define} sagt, dass Konstante oder Funktion definiert wird \\
  \hspace{0.4cm} $\diamond$ Konstante: \texttt{(define name value)} \\
  \hspace{0.4cm} $\diamond$ kein \texttt{return} notwendig} \\ \hline
  
  \makecell[l]{Aufruf} & \makecell[l]{
  $\triangleright$ \texttt{(name param1 param2)} \\
  \hspace{0.4cm} $\diamond$ z.B. \texttt{(add 2.71 3.14)} \\
  \hspace{0.4cm} $\diamond$ Ergebnis wird ins Ausgabefenster des Bildschirms geschrieben} \\ \hline  

  \makecell[l]{Arithmetische \\ Operationen} & \makecell[l]{
  $\triangleright$ \texttt{(+ 2 3) ; 5} \\
  $\triangleright$ \texttt{(- -2 3 ; -5)}
  $\triangleright$ \texttt{(/ 37 30) ; 1.23..} \\
  $\triangleright$ \texttt{(modulo 20 3) ; 2} \\
  $\triangleright$ Verkettung: \\
  \hspace{0.4cm} $\diamond$ \texttt{(* (+ 2 3) 4) ; 20} \\
  $\triangleright$ Auch mehrere Operanden \\
  \hspace{0.4cm} $\diamond$ \texttt{(+ 3 4 5)} \\
  \hspace{0.4cm} $\diamond$ \texttt{(- 1 2 3) ; 1 - (2 + 3)} \\
  \hspace{0.4cm} $\diamond$ \texttt{(/ 1 2 3) ; 1 / (2 * 3)} \\
  } \\ \hline

  \makecell[l]{Mathematische \\ Funktionen} & \makecell[l]{
  $\triangleright$ \texttt{(floor 3.14) ; 3} \\
  \hspace{0.4cm} $\diamond$ Abrunden des übergebenen Wertes \\
  $\triangleright$ \texttt{(ceiling 3.14) ; 4} \\
  \hspace{0.4cm} $\diamond$ Aufrunden des übergebenen Wertes \\
  $\triangleright$ \texttt{(gcd 357 753 573)} \\
  \hspace{0.4cm} $\diamond$ Grö\ss ter gemeinsamer Teiler \\
  \hspace{0.4cm} $\diamond$ \texttt{greatest common denominator} \\
  $\triangleright$ \texttt{(modulo 753 357)} \\ 
  \hspace{0.4cm} $\diamond$ Rest der ganzzahigen Division } \\ \hline

  \makecell[l]{Typ einer Funktion} & \makecell[l]{
  $\triangleright$ Prüfung erst zur Laufzeit, ob Typen der Operanden zur Operation passen \\
  $\triangleright$ Typenzusicherung deswegen über Verträge (siehe Vertrag)  } \\ \hline

  \makecell[l]{Definitionen \\ verstecken} & \makecell[l]{
  $\triangleright$ Zugriff auf definierte Funktionen nur innerhalb des \texttt{local}-Blocks \\
  $\triangleright$ Verwendung von \texttt{(local ... )} \\
  \hspace{0.4cm} 1 \hspace{0.1cm} \texttt{(define (fct x)} \\
  \hspace{0.4cm} 2 \hspace{0.5cm} \texttt{(local ( ; Öffnen des Blocks für lokale Definition} \\
  \hspace{0.4cm} 3 \hspace{0.7cm} \texttt{(define const 10)} \\
  \hspace{0.4cm} 4 \hspace{0.7cm} \texttt{(define (mult-const y) (* const y))) ; Blockschlie\ss ung} \\
  \hspace{0.4cm} 5 \hspace{0.5cm} \texttt{(+ const (mult-const x)))) ; Schlie\ss en von local und define} \\
  \hspace{0.4cm} $\diamond$ \texttt{local} enthält in sich einen Block für lokale Definitionen \\
  \hspace{0.4cm} $\diamond$ Zeile 5: Die letzte Zeile stellt den Wert des \texttt{local}-Ausdrucks dar} \\ \hline
  
  \end{tabular}

\section{Funktionen als Daten} 

  \begin{tabular}{ | p{0.2\textwidth} p{0.75\textwidth} | } 
  \hline 
  
  \makecell[l]{Beispiele} & \makecell[l]{
  $\triangleright$ \texttt{(define add +)} \\
  \hspace{0.4cm} $\diamond$ Konstante \texttt{add} vom Typ: \texttt{number number -> number} \\
  \hspace{0.4cm} $\diamond$ Operationen sind in \texttt{Racket} auch Funktionen \\
  $\triangleright$ \texttt{(define-struct functions (fct1 fct))} \\
  \hspace{0.4cm} $\diamond$ Auch Abspeichern von Funktionen als \texttt{Struct} \\
  $\triangleright$ \texttt{(list fct1 3 fct2 +)} \\
  \hspace{0.4cm} $\diamond$ Funktionen auch als Listenelemente möglich \\
  } \\ \hline
  
  \makecell[l]{Funktionen höherer \\ Ordnung} & \makecell[l]{
  $\triangleright$ Funktionen, die Funktionen als Parameter enthalten \\
  $\triangleright$ z.B. \texttt{(define (add fct1 x fct2 y) (+ (fct1 x) (fct2 y)))} \\
  \hspace{0.4cm} $\diamond$ Verwendung der Funktion gemä\ss  ihres erwarteten Typs (Vertrag) \\
   } \\ \hline

  \end{tabular}

\section{Klassen}

\section{Konstanten} 

  \begin{tabular}{ | p{0.2\textwidth} p{0.75\textwidth} | } 
  \hline 
  
  \makecell[l]{Allgemein} & \makecell[l]{
  $\triangleright$ In Racket stellt jeder Wert, der definiert wird, eine Konstante dar} \\ \hline  
  
  \makecell[l]{Erzeugung} & \makecell[l]{
  $\triangleright$ (define name ausdruck) \\
  \hspace{0.4cm} $\diamond$ z.B. \texttt{(define my-pi 3.14159)} \\
  \hspace{0.4cm} $\diamond$ \texttt{(define my-pi (+ 3 0.14159)) }} \\ \hline

  \makecell[l]{Wichtige \\ Konstanten} & \makecell[l]{
  $\triangleright$ \texttt{pi} \\
  $\triangleright$ \texttt{e}   } \\ \hline

  \end{tabular}

\section{Lambda-Ausdrücke}

  \begin{tabular}{ | p{0.2\textwidth} p{0.75\textwidth} | } 
  \hline 
  
  \makecell[l]{Aufbau} & \makecell[l]{
  $\triangleright$ \texttt{(lambda (x y) -> (+ (* x x) (* y y))} \\
  \hspace{0.4cm} $\diamond$ Aufbau vergleichbar mit Kurzform in Java} \\ \hline  
  
  \makecell[l]{Beispiel} & \makecell[l]{
  \hspace{0.2cm} 1 \hspace{0.1cm} \texttt{(define (add-unary-functions fct1 fct2)} \\
  \hspace{0.2cm} 2 \hspace{0.5cm} \texttt{(lambda (x,y) -> (+ (fct1 x) (fct2 y))))} \\
  $\triangleright$ Die Funktion liefert eine Funktion zurück, die eine Zahl zurückliefert \\
  $\triangleright$ \texttt{Closure} analog zu Java \\
  $\triangleright$ Anwendung: \\
  \hspace{0.4cm} $\diamond$ \texttt{(define (times10 a) (* 10 a))} \\
  \hspace{0.4cm} $\diamond$ \texttt{(define (div5 a) (/ a 5))} \\
  \hspace{0.4cm} $\diamond$ \texttt{((add-unary-functions times10 a) 3.14 2.71)} \\
  \hspace{0.6cm} - \texttt{(+ (* 3.14 10) (/ 2.71 5))} \\
  \hspace{0.6cm} - \texttt{add-unary-functions} liefert Lambda-Ausdruck zurück \\
  \hspace{0.6cm} - Dieser wird dann mit \texttt{3.14} und \texttt{2.71} aufgerufen} \\ \hline

  \end{tabular}

\section{Laufzeitchecks und Fehler}

  \begin{tabular}{ | p{0.2\textwidth} p{0.75\textwidth} | } 
  \hline 
  
  \makecell[l]{Allgemein} & \makecell[l]{
  $\triangleright$ Möglichkeit des Testens von Funktionen zur Laufzeit} \\ \hline
  
  \makecell[l]{Verwendung} & \makecell[l]{
  $\triangleright$ \texttt{(check-expect param1 param2)} \\
  \hspace{0.4cm} $\diamond$ Abbruch mit Fehlermeldung, falls inkorrekt \\
  \hspace{0.4cm} $\diamond$ z.B. \texttt{(check-expect (divide 15 3) 5) ; \#t} \\
  $\triangleright$ \texttt{(check-within param1 param2 param3)} \\
  \hspace{0.4cm} $\diamond$ Test, ob Werte ausreichend nahe beeinander liegen \\
  \hspace{0.4cm} $\diamond$ \texttt{param3} ist dieser maximale Abstand \\
  \hspace{0.4cm} $\diamond$ z.B. \texttt{(check-within (divide pi e) 1.15 0.01)} \\
  $\triangleright$ \texttt{(check-error (divide 15 0) \string"/: division by zero\string")} \\
  \hspace{0.4cm} $\diamond$ Test, ob Fehler im Fehlerfall wirklich geworfen wird \\
  \hspace{0.4cm} $\diamond$ Fehlermeldung des 1. Parameters muss dem 2. Parameter entsprechen \\
  \hspace{0.4cm} $\diamond$ \texttt{\string"\string"} geben hier einen String an \\
  \hspace{0.4cm} $\diamond$ Nachgucken der entsprechenden Fehlermeldung in Racket Dokumentation \\
  $\triangleright$ Wichtig: Abprüfung aller Randfälle} \\ \hline

  \makecell[l]{Werfen eines Fehlers} & \makecell[l]{
  $\triangleright$ "Laufzeittests" können auch innerhalb einer Methode ausgeführt werden \\
  $\triangleright$ Bei "falschem" Parameter kann man selbst einer \texttt{Error} werfen \\
  $\triangleright$ \texttt{(if (= y 0) (error \string"Division by 0\string") (/x y))} \\
  \hspace{0.4cm} $\diamond$ \texttt{error} führt zum Programmabbruch und Ausgabe der Fehlermeldung  } \\ \hline

  \end{tabular}

\section{Listen}

    \begin{tabular}{ | p{0.2\textwidth} p{0.75\textwidth} | } 
    \hline 
    
    \makecell[l]{Erzeugung \\ einfacher Listen} & \makecell[l]{
    $\triangleright$ \texttt{(define list1 (list 1 2 3))} \\
    \hspace{0.4cm} $\diamond$ Erstellt eine Liste mit den Werten 1,2,3 \\
    \hspace{0.4cm} $\diamond$ Funktion \texttt{list} kann beliebig viele Parameter haben \\
    \hspace{0.4cm} $\diamond$ Die Elemente der Liste sind ihr Rückgabewert \\
    $\triangleright$ Listen müssen nicht homogen sein (auch heterogen möglich)} \\ \hline  
    
    \makecell[l]{Erzeugung von Listen \\ aus Listen} & \makecell[l]{
    $\triangleright$ \texttt{(define list2 (cons 7 list1))} \\
    \hspace{0.4cm} $\diamond$ Funktion \texttt{cons} fügt \texttt{7} und \texttt{list1} zu \texttt{list2} zusammen \\
    \hspace{0.4cm} $\diamond$ Zweiter Parameter muss zwingend eine Liste sein \\
    \hspace{0.4cm} $\diamond$ Erster Parameter in Liste dann auch an erster Stelle} \\ \hline

    \makecell[l]{\texttt{empty}} & \makecell[l]{
    $\triangleright$ Name für die leere Liste \\
    $\triangleright$ z.B. \texttt{(define list1 (cons 1 empty))} \\
    $\triangleright$ \texttt{empty?} überprüft, ob die Liste leer ist \\
    \hspace{0.4cm} $\diamond$ Wird gerne als Rekursionsanker verwendet} \\ \hline
    

    \makecell[l]{Funktionen auf \\ Listen} & \makecell[l]{
    $\triangleright$ \texttt{(first list1)} \\
    \hspace{0.4cm} $\diamond$ Liefert den ersten Wert der Liste zurück \\
    \hspace{0.4cm} $\diamond$ Erwartet, dass die Liste nicht leer ist \\
    $\triangleright$ \texttt{(rest list1)} \\
    \hspace{0.4cm} $\diamond$ Liefert Liste zurück, die alle Elemente au\ss er dem Ersten enthält \\
    \hspace{0.4cm} $\diamond$ Erwartet, dass die Liste nicht leer ist} \\ \hline

    \end{tabular}

\section{Objektmodell}

  \begin{tabular}{ | p{0.2\textwidth} p{0.75\textwidth} | } 
  \hline 
  
  \makecell[l]{Allgemein} & \makecell[l]{
  $\triangleright$ Es gibt keine Objekte, nur Werte \\
  \hspace{0.4cm} $\diamond$ Werte sind \textbf{immer} Konstante, \textbf{nie} Variable \\
  \hspace{0.4cm} $\diamond$ Werte werden \textbf{immer} kopiert \\
  \hspace{0.6cm} - Formaler Paramater innerhalb Funktion ist Kopie des aktualen Parameters \\
  $\triangleright$ Laufzeitsystem kann intern zur Optimierung von Grundlogik abweichen} \\ \hline  

  \makecell[l]{Aufweichung des \\ Objektmodells} & \makecell[l]{
  $\triangleright$ \texttt{begin} \\
  \hspace{0.4cm} $\diamond$ \texttt{(begin (fct1 ...) (fct2 ...))} \\
  \hspace{0.4cm} $\diamond$ \texttt{begin} leitet mehrere Anweisungen ein \\
  \hspace{0.4cm} $\diamond$ Die letzte Anweisung ist der Wert des \texttt{begin}-Ausdrucks \\
  $\triangleright$ \texttt{set!} \\
  \hspace{0.4cm} $\diamond$ (set! new 'test) \\
  \hspace{0.4cm} $\diamond$ Überschreibt Wert des ersten Parameters mit dem des Zweiten \\
  \hspace{0.4cm} $\diamond$ \texttt{set!} hat keinen Rückgabewert \\
  $\triangleright$ \texttt{\#<void>} \\
  \hspace{0.4cm} $\diamond$ z.B. \texttt{(define new \#<void>)} \\
  \hspace{0.4cm} $\diamond$ Konstante hat damit einen leeren Wert \\
  $\triangleright$ Objektidentität: \\
  \hspace{0.4cm} $\diamond$ generelle Vermeidung wird empfohlen \\
  \hspace{0.4cm} $\diamond$ \texttt{(eq? a b)} \\
  \hspace{0.4cm} $\diamond$ Testet ob zwei Objekte dasselbe Objekt sind \\
  \hspace{0.4cm} $\diamond$ Systemabhängig, interne Implementation} \\ \hline
  
  \end{tabular}

\section{Rekursion} 

    \begin{longtable}{ | p{0.2\textwidth} p{0.75\textwidth} | } 
    \hline 
    
    \makecell[l]{Allgemein} & \makecell[l]{
    $\triangleright$ Grundlegendes Konzept zur Steuerung des Programmablaufs in Funktion \\
    \hspace{0.4cm} $\diamond$ Verwendung anstatt von Schleifen wie in z.B. Java \\
    \hspace{0.4cm} $\diamond$ Schleifen widersprechen funktionaler Programmierung} \\ \hline  
    
    \makecell[l]{Beispiel \\ Normale Berechnung} & \makecell[l]{
    $\triangleright$ z.B. \texttt{(define (factorial n) (if (= n 0) 1 (* n (factorial (- n 1)))))} \\
    \hspace{0.4cm} $\diamond$ Zurückliefern von \texttt{1}, falls \texttt{n} gleich 0 ist \\
    \hspace{0.6cm} - Ermöglicht Multiplizieren mit 1 auf niedrigster Rekursionsstufe \\
    \hspace{0.6cm} - Verändert damit den Rückgabewert nicht und beendet Rekursion \\
    \hspace{0.4cm} $\diamond$ Beispiel für \texttt{factorial 2} \\
    \hspace{0.6cm} 1 \hspace{0.1cm} \texttt{(factorial 2)} \\
    \hspace{0.6cm} 1 \hspace{0.1cm} \texttt{(* 2 (factorial 1))} \\
    \hspace{0.6cm} 1 \hspace{0.1cm} \texttt{(* 2 (* 1 (factorial 0)))} \\
    \hspace{0.6cm} 1 \hspace{0.1cm} \texttt{(* 2 (* 1 1)) ; Ergebnis: 2} \\
    } \\ \hline

    \makecell[l]{Rekursion auf \\ Listen} & \makecell[l]{
    $\triangleright$ z.B.: Summe einer Listen von Zahlen: \\
    \hspace{0.4cm} $\diamond$ Falls Liste leer ist: Summe = \texttt{0} \\
    \hspace{0.4cm} $\diamond$ Sonst Summe = erstes Elemente plus Summe der Restliste \\
    \hspace{0.4cm} $\diamond$ Folgendes Beispiel im Rahmen einer Methode \texttt{sum} \\
    \hspace{0.4cm} $\diamond$ Addiert rekursiv die Werte der Liste \\
    \hspace{0.4cm} $\diamond$ Falls Liste leer ist, wird 0 zurückgegeben und Rekursion \string"fällt zusammen\string" \\
    \hspace{0.6cm} 1 \hspace{0.1cm} \texttt{(if (empty? list)} \\
    \hspace{0.6cm} 2 \hspace{0.5cm} \texttt{0} \\
    \hspace{0.6cm} 3 \hspace{0.5cm} \texttt{(+ (first list) (sum (rest list)))} \\
    $\triangleright$ z.B.: Liste der Quadratwurzeln einer Liste \\
    \hspace{0.4cm} $\diamond$ Kerngedanke: Sukzessiver Aufbau einer neuen Liste der Quadratwurzeln \\
    \hspace{0.4cm} $\diamond$ Alle Wurzeln müssen durch die Rekursion \string"geschleift\string" werden \\
    \hspace{0.4cm} $\diamond$ Hinzufügen von \texttt{empty}, falls die Liste leer ist \\
    \hspace{0.4cm} $\diamond$ Folgendes Beispiel im Rahmen einer Methode \texttt{sqrts} \\
    \hspace{0.6cm} 1 \hspace{0.1cm} \texttt{(if (empty? list)} \\
    \hspace{0.6cm} 2 \hspace{0.5cm} \texttt{empty} \\
    \hspace{0.6cm} 3 \hspace{0.5cm} \texttt{(cons (sqrt (first list)) (sqrts (rest list))))} \\
    $\triangleright$ z.B.: Filterung einer Liste \\
    \hspace{0.4cm} $\diamond$ Selbes Konzept wie bei den Quadratwurzeln einer Liste \\
    \hspace{0.4cm} $\diamond$ Meist mit zwei \texttt{if}-Anweisungen (Rekursionsanker + Filter) \\
    \hspace{0.4cm} $\diamond$ Falls die Bedingung nicht erfüllt ist, \string"Überspringen\string" des Elements \\
    \hspace{0.6cm} - Aufruf der rekursiven Methode ohne \texttt{cons} davor \\
    \hspace{0.6cm} 1 \hspace{0.1cm} \texttt{(define (filter-fct list x)} \\
    \hspace{0.6cm} 2 \hspace{0.5cm} \texttt{(if (empty? list)} \\
    \hspace{0.6cm} 3 \hspace{0.9cm} \texttt{empty} \\
    \hspace{0.6cm} 4 \hspace{0.9cm} \texttt{(if (< (first list) x)} \\
    \hspace{0.6cm} 5 \hspace{1.3cm} \texttt{(cons (first list) (filter-fct (rest list) x))} \\
    \hspace{0.6cm} 6 \hspace{1.3cm} \texttt{(filter-fct (rest list) x))))}} \\ \hline

    \makecell[l]{Objektmodell} & \makecell[l]{
    $\triangleright$ Liste ist eine Folge von \textbf{Werten}, nicht von \textbf{Objekten} \\
    $\triangleright$ Eine gefilterte Liste enthält \textbf{Kopien} von Werten  } \\ \hline

    \makecell[l]{Randfälle bei \\ Listen} & \makecell[l]{
    $\triangleright$ Ausgabeliste leer, trotz nicht leerer Eingabeliste \\
    $\triangleright$ Alle Elemente der Eingabeliste in Ausgabeliste \\
    $\triangleright$ Test auf Vorzeichen bei Filterungen \\
    $\triangleright$ Eingabeliste leer} \\ \hline

    \makecell[l]{Akkumulatoren} & \makecell[l]{
    $\triangleright$ Wird meist durch lokale Hilfsmethode implementiert \\
    $\triangleright$ Beispielsmethode: Akkumulation einer Liste \\
    \hspace{0.4cm} 1 \hspace{0.1cm} \texttt{(define (list-of-sums input-list)} \\ 
    \hspace{0.4cm} 2 \hspace{0.3cm} \texttt{(local} \\
    \hspace{0.4cm} 3 \hspace{0.5cm} \texttt{((define (list-of-sum-with-accu list accu))} \\
    \hspace{0.4cm} 4 \hspace{0.7cm} \texttt{(cond } \\
    \hspace{0.4cm} 5 \hspace{0.9cm} \texttt{[(empty? list) (list accu)]} \\
    \hspace{0.4cm} 6 \hspace{0.9cm} \texttt{[else (cons accu (list-of-sums-with-accu (rest list)} \\
    \hspace{0.4cm} 7 \hspace{6cm} \texttt{(+ (first list) accu)))]))} \\
    \hspace{0.4cm} 8 \hspace{0.3cm} \texttt{(list-of-sums-with-accu (rest input-list) (first input-list))))} \\
    \hspace{0.4cm} $\diamond$ Zeile 2: Einrichtung einer lokalen Umgebung \\
    \hspace{0.4cm} $\diamond$ Zeile 3: Definitionsstart der lokalen Methode mit Akkumulator \\
    \hspace{0.4cm} $\diamond$ Zeile 8: Letzter Ausdruck des \texttt{local}-Ausdrucks und deswegen Rückgabewert \\
    \hspace{0.4cm} $\diamond$ Zeile 5: Rekursionsanker: Falls Liste leer, Rückgabe des \texttt{accu} als Liste \\
    \hspace{0.4cm} $\diamond$ Beispielaufruf: \texttt{(list-of-sums (10 18 22 30))} \\
    \hspace{0.6cm} - Ausgabe: \texttt{(list 10 28 50 80)}
    } \\ \hline

    \end{longtable}

\section{Structs}

    \begin{tabular}{ | p{0.2\textwidth} p{0.75\textwidth} | } 
    \hline 
    
    \makecell[l]{Allgemein} & \makecell[l]{
    $\triangleright$ Zusammenfassung von Elementen, vergleichbar mit Klasse ohne Methoden  } \\ \hline 

    \makecell[l]{Erzeugung} & \makecell[l]{
    $\triangleright$ \texttt{(define-struct name (attribute1 attribute2 attribute3))} \\
    \hspace{0.4cm} $\diamond$ Attribute werden in \texttt{Racket} Felder genannt } \\ \hline

    \makecell[l]{\string"Objekterzeugung\string"} & \makecell[l]{
    $\triangleright$ z.B. \texttt{(define test (make-name 'Hallo 2 (list 1 2 3)))} \\
    $\triangleright$ \string"Konstruktor\string" wird automatisch erzeugt \\
    $\triangleright$ Initialisierungen der Felder werden in selber Reihenfolge übergeben  } \\ \hline
    
    \makecell[l]{Zugriff} & \makecell[l]{
    $\triangleright$ \texttt{(name-attribute1 object-name)} \\
    \hspace{0.4cm} $\diamond$ z.B. \texttt{student-last-name 247852} \\
    \hspace{0.4cm} $\diamond$ Abfrage des Nachnamens des \texttt{student}-Objektes mit den Namen 247852 } \\ \hline
    \end{tabular}

\section{Syntax}

  \begin{tabular}{ | p{0.2\textwidth} p{0.75\textwidth} | } 
  \hline 
  
  \makecell[l]{Präfixnotation} & \makecell[l]{
  $\triangleright$ Zuerst der Operand, danach die Operanden \\
  \hspace{0.4cm} $\diamond$ (+ 1 2)} \\ \hline

  \makecell[l]{Klammersetzung} & \makecell[l]{
  $\triangleright$ Jede Einheit, die nicht atomar ist, wird in Klammern gesetzt \\
  \hspace{0.4cm} $\diamond$ Zusammengesetzte Ausdrücke \\
  \hspace{0.4cm} $\diamond$ Funktionen allgemein \\
  $\triangleright$ Keine unterschiedlichen Bindungsstärken, immer Setzen aller Klammern  } \\ \hline

  \makecell[l]{Kommentare} & \makecell[l]{
  $\triangleright$ Einzelne Zeile: \texttt{;} \\
  } \\ \hline

  \makecell[l]{Identifier} & \makecell[l]{
  $\triangleright$ Keine Zahlen \\
  $\triangleright$ Keine Whitespaces \\
  $\triangleright$ Konventionen: \\
  \hspace{0.4cm} $\diamond$ Keine Gro\ss buchstaben \\
  \hspace{0.4cm} $\diamond$ Bindestriche zwischen den einzelnen Wörtern \\
  \hspace{0.6cm} - z.B. \texttt{this-identifier-conforms-to-all-conventions} } \\ \hline  
  
  \end{tabular}

\section{Verzweigung, cond} 

  \begin{tabular}{ | p{0.2\textwidth} p{0.75\textwidth} | } 
  \hline 
  
  \makecell[l]{if-Anweisung} & \makecell[l]{
  $\triangleright$ Boolsche Funktion mit drei Parametern \\
  $\triangleright$ \texttt{( if(bedindung) anweisung-if-true anweisung-if-false)} \\
  \hspace{0.4cm} $\diamond$ Muss wiede jeder andere Funktion in Klammern stehen \\
  \hspace{0.4cm} $\diamond$ Liefert ersten Parameter zurück falls \texttt{true} \\
  \hspace{0.4cm} $\diamond$ z.B. \texttt{(define (my-abs x) (if (< 0 x) -x x))} \\
  $\triangleright$ Verschachtelung von \texttt{if}-Anweisungen auch möglich} \\ \hline  

  \makecell[l]{cond Funktion} & \makecell[l]{
  $\triangleright$ Bei mehreren \texttt{if}-Anweisungen meist der bessere Ersatz \\
  $\triangleright$ Stark an \texttt{switch}-Anweisung aus \texttt{Java} angelegt \\
  $\triangleright$ Wird bei Rekursion z.B. für Randfälle oder Rekursionsanker verwendet \\
  $\triangleright$ Aufbau: \\
  \hspace{0.6cm} 1 \hspace{0.1cm} \texttt{(cond } \\
  \hspace{0.6cm} 2 \hspace{0.5cm} \texttt{[(empty? list) 2]} \\
  \hspace{0.6cm} 3 \hspace{0.5cm} \texttt{[(number? a) 0])} 
  \hspace{0.6cm} 3 \hspace{0.5cm} \texttt{[else 1])} \\
  $\triangleright$ \texttt{cond}-Funktion hat eine variable Anzahl von Anweisungen \\
  $\triangleright$ Jede Anweisung wird in \texttt{[]} gefasst und bildet einen Fall ab \\
  $\triangleright$ Aufbau eines Falls: \texttt{[(bedingung) anweisung]} \\
  $\triangleright$ Überprüfung aller Fälle der Reihe nach \\
  \hspace{0.4cm} $\diamond$ Falls ein Fall eintritt, ist die Anweisung dort der Rückgabewert \\
  $\triangleright$ \texttt{else} deckt den Fall ab, falls keiner der vorangehenden eintritt \\
  } \\ \hline
  
  \end{tabular}



\section{Vertrag}

  \begin{tabular}{ | p{0.2\textwidth} p{0.75\textwidth} | } 
  \hline 
  
  \makecell[l]{Allgemein} & \makecell[l]{
  $\triangleright$ Warum? \\
  \hspace{0.4cm} $\diamond$ Typprüfung erst zur Laufzeit \\
  \hspace{0.4cm} $\diamond$ Fehlervermeidung \\
  $\triangleright$ "Vertrag": \\
  \hspace{0.4cm} $\diamond$ Nutzer erfüllt seinen Teil des Vertrags (Precondition) \\
  \hspace{0.4cm} $\diamond$ Dann erfüllt Funktion ihren Teil des Vertrags  } \\ \hline  
  
  \makecell[l]{Aufbau} & \makecell[l]{
  \texttt{;; Type: number number -> number} \\
  \texttt{;;} \\
  \texttt{;; Returns: the sum of two parameters} \\
  $\triangleright$ \texttt{Type:} Aufzählung der Paramater nach Reihenfolge des Auftretens \\
  $\triangleright$ \texttt{->}: Angabe des Rückgabetyps nach dem Pfeil \\
  $\triangleright$ \texttt{Returns}: Kurze Beschreibung des Rückgabewertes \\
  $\triangleright$ Nutzung von \texttt{;;} statt \texttt{;} ist hier Konvention } \\ \hline

  \makecell[l]{Weitere \\ Elemente} & \makecell[l]{
  $\triangleright$ \texttt{;; Precondition}: Angabe für Parameterrichtlinien \\
  $\triangleright$ \texttt{(list of number)} im \texttt{Type} für Listen \\
  \hspace{0.4cm} $\diamond$ z.B. \texttt{(list of number) -> number} \\
  $\triangleright$ Unterschiedliche Typen in Liste: \texttt{(list of ANY)} \\
  \hspace{0.4cm} $\diamond$ Verwendung mehrerer \texttt{ANY}: Keine Abhängigkeit voneinander \\
  $\triangleright$ Feste Typen in Liste: \texttt{(list of student)} \\
  $\triangleright$ \texttt{X}: Platzhalter für beliebigen Datentyp \\
  \hspace{0.4cm} $\diamond$ Bei Verwendung von mehreren \texttt{X}: \texttt{X} sind vom gleichen Typ \\
  \hspace{0.4cm} $\diamond$ Falls diese unterschiedlich sein sollen: Verwendung von \texttt{Y,Z} \\
  } \\ \hline

  \makecell[l]{Funktionen höherer \\ Ordnung} & \makecell[l]{
  $\triangleright$ z.B. \texttt{(define (add fct1 x fct2 y) (+ (fct1 x) (fct2 y)))} \\
  \hspace{0.4cm} $\diamond$ \texttt{(number -> number) number (number -> number) number -> number} \\
  \hspace{0.4cm} $\diamond$ Beschreibung des Funktionstyps an sich \\
  $\triangleright$ Vertrag für Lambda-Funktionen vom selben Aufbau \\
  \hspace{0.4cm} $\diamond$ z.B. \texttt{... -> (number number -> number)} \\
  \hspace{0.4cm} $\diamond$ Prädikat: \texttt{(X -> boolean) ... -> ...} \\
  \hspace{0.4cm} $\diamond$ Vertrag für jede Lambda-Funktion notwendig \\
  \hspace{0.4cm} $\diamond$ sowohl innerhalb, als auch im oberen Vertrag} \\ \hline

  \end{tabular}




\end{document}